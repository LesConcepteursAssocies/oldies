          MANUEL DE REFERENCE DU LANGAGE DE DEVELOPPEMENT DE NEOSERV
          ==========================================================

TYPES ET ENTREE DES DONNEES
---------------------------

N‚oServ reconnait 4 types de donn‚es :

   - Le type NUMBER (nombre), repr‚sentant les nombres
     (entiers, flottants, ...).
     Les nombres peuvent ˆtres entr‚s de diverse fa‡on :
     (Par d‚faut, la base d'entr‚e est 10 (d‚cimal)) 

     exemples : 125e35        // Notation scientifique
                3.14159       // Notation … virgule flottante
                -25           // Nombre n‚gatif (signe devant le nombre)
                FFEh          // Base h‚xad‚cimal ('h' … la fin du nombre)
                010011101b    // Base binaire ('b' … la fin du nombre)
                1257o         // Base octal ('o' … la fin du nombre)
                +56.7         // le signe '+' est facultatif mais autoris‚

   - Le Type NUMBER[], repr‚sentant les tableaux de nombres.

   - Le type CHAR, repr‚sentant les caractŠres
     (simples, chaines).

     exemples : "A"           // caractŠre 'A'
                "Bonjour"     // Chaine

   - Le type CHAR[], repr‚sentant les tableaux de caractŠres.

   En interne, tous les nombres de N‚oServ sont repr‚sent‚s en format
   flottant (32 bits), avec la pr‚cision suivante :

   - Plus grand nombre repr‚sentable = 3.402823466e+38
   - Plus petit nombre repr‚sentable = 1.175494351e-38

   La longueur des chaines n'est limit‚e que par la m‚moire disponible.

COMPILATION DES PROGRAMMES
--------------------------

Chaque ligne est convertie en majuscules, ainsi "MAIN", "MaIn", "MAin" sont
identiques et d‚signent la mˆme proc‚dure.

CONVENTIONS
-----------

Dans les explications qui suivent, les symboles suivants sont utilis‚s :

   - n : repr‚sente un nombre quelconque
   - c : repr‚sente une chaine de caractŠre quelconque
         (contenant un ou plusieurs caractŠres)
   - s : repr‚sente un symbole quelconque (son type est indiff‚rent)

Les commentaires sur les paramŠtres d'entr‚e et de sortie des proc‚dures
du langage suivent la convention suivante :

   // se1 ... sen --- ssn ... ss1

   se1 est le paramŠtre d'entr‚e situ‚ au sommet de la pile
   sen est le dernier paramŠtre d'entr‚e (situ‚ au fond de la pile)
   ssn est le dernier paramŠtre de sortie (situ‚ au fond de la pile)
   ss1 est le paramŠtre de sortie situ‚ au sommet de la pile

   exemples : // D‚finition de l'addition
              // n1 est au sommet de la pile, n2 est juste en dessous
              // n3 est le r‚sultat empil‚
              : + // n1 n2 --- n3
                 ...
              ;
              // D‚finition de la proc‚dure locate
              // nLig est au sommet de la pile, nCol est juste en dessous
              // Aucun paramŠtre n'est renvoy‚ (empil‚)
              : LOCATE // nLig nCol ---
                 ...
              ;

En clair, il suffit de se repr‚senter la pile comme ceci :

        Avant           AprŠs

Sommet-> se1             ss1 <-Sommet
         ...      ---    ...
         sen             ssn

   // se1 ... sen --- ssn ... ss1


DESCRIPTION DES INSTRUCTIONS
============================

LE MINITEL
----------

CLS                     ---

   Efface l'‚cran du minitel.
   La position du curseur est mise … jour.

   Syntaxe : CLS

ENQROM                  ---

   Demande d'identification du minitel.
   La prochaine donn‚e … recevoir contiendra la s‚quence d'identification.

   Syntaxe : ENQROM

SETCOLOR                n ---

   D‚finition de la couleur des caractŠres.

   Syntaxe : Couleur SETCOLOR

             Couleur = 0 pour NOIR
                       1  "   ROUGE
                       2  "   VERT
                       3  "   JAUNE
                       4  "   BLEU
                       5  "   MAGENTA
                       6  "   CYAN
                       7  "   BLANC

   Exemple : MAGENTA SETCOLOR  // Passage en Magenta

SETBACKGROUND           n ---

   D‚finition de la couleur du fond.

   Syntaxe : Couleur SETBACKGROUND

             Couleur = 0 pour NOIR
                       1  "   ROUGE
                       2  "   VERT
                       3  "   JAUNE
                       4  "   BLEU
                       5  "   MAGENTA
                       6  "   CYAN
                       7  "   BLANC

   Exemple : GREEN SETBACKGROUND  // Passage en fond Vert

   Rappel : pour que la couleur de fond devienne active, il faut
            envoyer un espace (SetBackGround le fait automatiquement).

   Note : l'attribut de d‚finition de la couleur de fond n'est valable
          que sur la ligne courante du minitel.

GETCURSORPOS            --- nLig nCol

   R‚cupŠre la position du curseur du minitel.

   Syntaxe : GETCURSORPOS --- Ligne Colonne

             Empile les valeurs Ligne et Colonne de la position du curseur.

   Exemple : GETCURSORPOS
             vcol := vlig :=  // On conserve les valeurs

LOCATE                  nLig nCol ---

   Positionnement du curseur.

   Syntaxe : Ligne Colonne LOCATE

             Ligne   = Num‚ro de ligne (1..24)
             Colonne = Num‚ro de colonne (1..40)

   En fait, les limites ligne et colonnes d‚pendent de la taille actuelle
   des caractŠres (simple, double hauteur, double largeur, double taille,
   voir SETFONT).

   Exemple : 4 25 LOCATE  // Ligne 4 colonne 25
             " Salut" PRINT

   Note : Si la fin de la chaine d‚passe la largeur de l'‚cran, celle-ci
          continue sur la ligne suivante.

LINE0                   str ---

   Envoi d'un message sur la ligne 0 du minitel.

   Syntaxe : Msg LINE0

             Msg = Message … envoyer

   Sur un minitel, la ligne 0 est en g‚n‚ral r‚serv‚e … l'affichage de messages
   d'informations.

   Exemple : " Vous avez re‡u un message en BAL" LINE0

CLEAR0                  ---

   Effacement de la ligne 0 du minitel.

   Syntaxe : CLEAR0

   Exemple : " Vous avez re‡u un message en BAL" LINE0
             ...
             CLEAR0

SETFONT                 n ---

   D‚finition de la taille des caractŠres.

   Syntaxe : Taille SETFONT

             Taille = 0 pour SIMPLE TAILLE
                      1  "   DOUBLE HAUTEUR
                      2  "   DOUBLE LARGEUR
                      3  "   DOUBLE TAILLE

   La taille des caractŠres conditionne le nombre de lignes et/ou de colonnes
   d'affichage.

        Taille         Nbre de lignes     Nbre de colonnes
   +----------------+-------------------+-------------------+
   | SIMPLE TAILLE  |        24         |        40         |
   | DOUBLE HAUTEUR |        12         |        40         |
   | DOUBLE LARGEUR |        24         |        20         |
   | DOUBLE TAILLE  |        12         |        20         |
   +----------------+-------------------+-------------------+

   Exemple : 1 SETFONT  // Passage en double hauteur

   Note : l'attribut de d‚finition de la taille des caractŠres n'est valable
          que sur la ligne courante du minitel.

REPLICATE               c n ---

   R‚p‚tition d'un caractŠre.

   Syntaxe : c n REPLICATE

             c = caractŠre … r‚p‚ter
             n = nombre de r‚p‚tition

   Exemple : " a" 5 REPLICATE  // Affiche " aaaaa" … l'‚cran
             " coucou" 3 REPLICATE  // Affiche " coucouuu" … l'‚cran

SETTMODE                n ---

   Initialise le mode du terminal du connect‚ courant.

   Syntaxe : <Mode> SETTMODE

   <Mode> est un des modes reconnus par le serveur, une des constantes
   TMODEVDT, TMODEMIXTE ou TMODETELEINFO.

   Si le mode actuel le permet, le nouveau mode est initialis‚, sinon
   rien ne se passe.

   Exemple : TMODEMIXTE SETTMODE
             GETTMODE TMODEMIXTE ==
             IF
                " Passage en mode mixte 80 colonnes" print cr
                ...
             ENDIF

SENDPAGE                str ---

   Envoi d'une page vid‚otex vers le terminal connect‚.

   Syntaxe : NomPage SENDPAGE

             NomPage = Nom du fichier … envoyer

   Exemple : " MENU.PAG" SENDPAGE  // Affichage du menu principal

   Note : Voir les directives #PATHVTX et #PATH pour la d‚finition de
          l'emplacement des pages.

EMIT                    n ---

   Envoi un caractŠre vers le terminal connect‚.

   Syntaxe : c EMIT

             c = code ascii du caractŠre … envoyer (0 ... 127)

   Rappel : le minitel ne "comprend" que les codes ASCII compris entre
            0 et 127.

   Exemple :  // D‚finition de la commande CLS
              : CLS  // ---
                 0Ch EMIT  // Envoi du caractŠre ASCII 12.
              ;

USING                   s ---

   D‚finit le format d'affichage des nombres.

   Syntaxe : Format USING

             Format = Chaine de caractŠre repr‚sentant le format
                      d'affichage … utiliser.
             Les caractŠres suivants sont autoris‚:
             "%+-0123456789.eEfgGbdilouxX "
             %     : d‚marre le processus de formatage (OBLIGATOIRE)
             +     : le signe est affich‚
             0...9 : affiche n chiffres (avant ou aprŠs le point d‚cimal)
             .     : point d‚cimal
             eE    : format scientifique (+-XX.XXXeE+-XXX)
             fgG   : format flottant (+-XXXX.XXXX)
             b     : affichage en binaire (sur 32 bits maximum)
             di    : affichage d'un entier
             l     : affichage d'un entier long
             o     : affichage en octal
             u     : affichage non sign‚
             xX    : affichage en hexad‚cimal (x=lettres en minuscules,
                     X=lettres en majuscules)

   Le format d‚finit avec USING reste actif jusqu'… une nouvelle d‚finition
   de format, ou l'appel … USINGOFF.

   Exemples : LOCAL NUMBER NOMBRE := 13.14159
              NOMBRE PRINT        // Affiche "13.141590"
              " %.0f" USING
              NOMBRE PRINT        // Affiche "13"
              " %.2f" USING
              NOMBRE PRINT        // Affiche "13.14"
              " %d" USING
              NOMBRE PRINT        // Affiche "2080825756"
              " %b" USING
              NOMBRE PRINT        // Affiche "1111100000001101110000110011100"
              " %X" USING
              NOMBRE PRINT        // Affiche "7C06E19C"
              " %E" USING
              NOMBRE PRINT        // Affiche "1.314159E+001"
              " %.0E" USING
              NOMBRE PRINT        // Affiche "1E+001"
              " %o" USING
              NOMBRE PRINT        // Affiche "17401560634"

   Note : Il n'y a pas de format d'affichage par d‚faut.

USINGOFF                ---

   D‚sactive le formatage des nombres d‚finit avec USING, et repasse en
   affichage par d‚faut.

   Syntaxe : USINGOFF

   Exemple : " %x" USING  // Affichage en H‚xa
             ...
             USINGOFF     // Affichage normal.

GETUSING                --- s

   Empile l'‚ventuel format d'affichage des nombres courant.

   Syntaxe : GETUSING

   Exemple : : PRINT0
                GETUSING         // Sauvegarde le format courant.
                " %0.f" USING    // Initialise un format.
                ...
                USING            // Restaure le format pr‚c‚dent.
             ;

PRINT                   s ---

   Primitive d'affichage.

   Syntaxe : Sym PRINT

             Sym = Symbole … afficher. Peut ˆtre de n'importe quel type.

   Exemple : " Bonjour" PRINT  // Affiche " Bonjour" … l'‚cran
             35 PRINT  // Affiche  " 35.000" … l'‚cran
             TOTO PRINT  // Affiche le contenu de la variable TOTO

   Note : Pour les chaines de caractŠres, il est possible d'ins‚rer
          des codes de contr“les, sous la forme suivante:
          " \xx ..."
          le caractŠre d'‚chappement '\' doit pr‚c‚der le code num‚rique
          (d‚cimal) du caractŠre de contr“le … g‚n‚rer.
          Exemples : " \27\87\27\66 Fond Blanc caractŠre cyan" print
                     char chaine := " \27\87\27\64 Fond blanc/car bleu"

PRINTUSING              fmt sym ---

   Primitive d'affichage format‚ des nombres.

   Syntaxe : Sym Fmt PRINTUSING

             Sym = Symbole … afficher. Peut ˆtre de n'importe quel type,
                   mais le format ne s'applique qu'aux nombres.
             Fmt = Format d'affichage, appliqu‚ si sym est un nombre
                   (voir USING pour plus de d‚tail).

   Exemple : 13.1459 " %X" PRINTUSING // Affiche "7C06E19C"
             35.5 " %0.f" PRINTUSING  // Affiche  " 35" … l'‚cran

   Note : L'‚ventuel format courant (voir USING) n'est pas modifi‚.

CR                      ---

   Envoi un retour chariot (0Dh + 0Ah) au terminal connect‚.

   Syntaxe : CR

   Le curseur est alors positionn‚ … la ligne suivante, colonne 0.

   Exemple : " COUCOU" print CR

CURSORON                ---

   Rend le curseur visible sur le minitel du connect‚.

   Syntaxe : CURSORON

   Exemple : PSEUDO !
             IF
                CURSORON
                " Entrez votre pseudo" print
             ENDIF

CURSOROFF               ---

   Rend le curseur invisible sur le minitel du connect‚.

   Syntaxe : CURSOROFF

   Exemple : PSEUDO
             IF
                CURSOROFF
                ...
             ENDIF

BEEP                    ---

   Emet un beep vers le terminal connect‚.

   Syntaxe : BEEP

   Exemple : PSEUDO !
             IF
                BEEP
                " Vous devez vouz certifier !" LINE0
             ENDIF

BLINKON                 ---

   Active le clignotement.

   Syntaxe : BLINKON

   Le reste de la ligne courante sera affich‚e en clignotant.

   Exemple : BLINKON " Ca clignote" print

   Rappel : les attributs ne sont actifs que sur la ligne courante.

BLINKOFF                ---

   D‚sactive le clignotement.

   Syntaxe : BLINKOFF

   Le reste de la ligne courante redevient normal.

   Exemple : BLINKON " Ca clignote" print BLINKOFF
             " c'est normal" print

   Rappel : les attributs ne sont actifs que sur la ligne courante.

UNDERLON                ---

   Active le soulignement.

   Syntaxe : UNDERLON

   Le reste de la ligne courante sera affich‚e en soulign‚.

   Exemple : UNDERLON " soulign‚" print

   Rappel : les attributs ne sont actifs que sur la ligne courante.

UNDERLOFF               ---

   D‚sactive le soulignement.

   Syntaxe : UNDERLOFF

   Le reste de la ligne courante sera affich‚e en normal.

   Exemple : UNDERLON " soulign‚" print UNDERLOFF
             " normal" print

   Rappel : les attributs ne sont actifs que sur la ligne courante.

INVERTON                ---

   Active l'affichage en inversion vid‚o.

   Syntaxe : INVERTON

   Le reste de la ligne courante sera affich‚e en inverse.

   Exemple : INVERTON " invers‚" print

   Rappel : les attributs ne sont actifs que sur la ligne courante.

INVERTOFF               ---

   D‚sactive l'affichage en inversion vid‚o.

   Syntaxe : INVERTOFF

   Le reste de la ligne courante sera affich‚e en normal.

   Exemple : INVERTON " invers‚" print INVERTOFF
             " normal" PRINT

   Rappel : les attributs ne sont actifs que sur la ligne courante.

UPPER                   ---

   Passage du minitel en majuscules.

   Syntaxe : UPPER

   Exemple : UPPER " Entrez votre nom" print

LOWER                   ---

   Passage du minitel en minuscules.

   Syntaxe : LOWER

   Exemple : LOWER " Entrez votre pr‚nom" print

INPUT                   --- s

   Primitive de saisie.
   Permet la saisie d'informations … partir du terminal connect‚, la saisie
   commencant … la position courante du curseur.

   Syntaxe : INPUT

   Pendant la saisie, certaines touches de fonction du minitel ont un effet
   particulier :

   - ANNULATION : Annule la saisie en cours, remet le curseur … sa position
                  initiale.
   - CORRECTION : Recule d'un caractŠre.

   Toute autre touche de fonction provoque la fin de la saisie.

   A la sortie, les donn‚es saisie sont empil‚e, sous  forme de chaine de
   caractŠre.

   Exemple : " Entrez votre nom : " print
             INPUT
             NOM :=

INPUTVAR                v ---

   Primitive de saisie dans une variable.
   Permet la saisie d'informations … partir du minitel, et le stockage
   dans la variable donn‚e.

   Syntaxe : NomVar INPUTVAR

   Pendant la saisie, certaines touches de fonction du minitel ont un effet
   particulier :

   - ANNULATION : Annule la saisie en cours, remet le curseur … sa position
                  initiale.
   - CORRECTION : Recule d'un caractŠre.

   Toute autre touche de fonction provoque la fin de la saisie.

   A la sortie, les donn‚es saisie sont sotck‚es dans la variable donn‚e.
   La variable doit ˆtre de type CaractŠre.

   Exemple : LOCAL CHAR cNOM
             ...
             " Entrez votre nom : " print
             cNOM INPUTVAR
             ...

MLINPUT                 lsize lmax --- l1 ... ln

   Primitive de saisie multi-lignes.
   Permet la saisie "au kilomŠtre" … partir du terminal connect‚.

   Syntaxe : lmax lsize MLINPUT

   <lmax> est le nombre total de lignes … saisir.
   <lsize> est la largeur des lignes … saisir, en caractŠres.

   Au d‚marrage de la saisie, N‚oServ conserve la position du curseur,
   afin de g‚rer correctement les d‚placements de celui-ci pendant la
   saisie.

   Pendant la saisie, certaines touches de fonction du minitel ont un effet
   particulier :

   - ANNULATION : Annule la saisie de la ligne courante, remet le curseur
                  au d‚but de la ligne.

   - CORRECTION : Recule d'un caractŠre, dans la ligne courante.

   - SUITE      : Passe … la ligne suivante, si la ligne courante n'est pas
                  la derniŠre.

   - RETOUR     : Passe … la ligne pr‚cedente, si la ligne courante n'est pas
                  la premiŠre.

   Toute autre touche de fonction provoque la fin de la saisie.

   A la sortie, les <lmax> lignes sont empil‚es, la derniŠre ‚tant au
   sommet de la pile.

   Exemple : LOCAL CHAR L1 L2 L3 L4
             ...
             " Tapez votre message (4 lignes)" LINE0
             5 1 LOCATE     // Positionne le curseur sur la premiŠre ligne de saisie.
             4 40 MLINPUT   // Saisie de 4 lignes de 40 caractŠres.
             L4 :=          // Stockage
             L3 :=          // dans les
             L2 :=          // variables
             L1 :=          // pour sauvegarde
             ...

MANIPULATION DE LA PILE DE DONNEES
----------------------------------

STACK#                  --- n

   Empile le nombre d'‚l‚ments pr‚sents sur la pile de donn‚es du
   connect‚ courant.

   Syntaxe : STACK#

   Exemple : : TOTO
               1
               STACK#   // Empile 1
               4
               STACK#   // Empile 2
             ;

DUP                     s --- s s

   Duplique le symbole situ‚ au sommet de la pile.

   Syntaxe : Sym DUP

   Exemple : 3 DUP  // 3 --- 3 3

              Pile Avant                Pile AprŠs
             +----------+              +----------+
             |    3     | <- Sommet    |    3     | <- Sommet
                 ....                  +----------+
                                       |    3     |
                                           ....

             TOTO DUP  // TOTO --- TOTO TOTO

              Pile Avant                Pile AprŠs
             +----------+              +----------+
             |   TOTO   | <- Sommet    |   TOTO   | <- Sommet
                 ....                  +----------+
                                       |   TOTO   |
                                           ....

   IMPORTANT : DUP duplique un symbole, quel que soit son type.
               En cons‚quence, si vous devez dupliquer un ‚l‚ment de tableau,
               et non le tableau lui-mˆme, utilisez @ avant DUP.

SWAP                    s1 s2 --- s1 s2

   Echange les deux symboles situ‚s au sommet de la pile.

   Syntaxe : Sym1 Sym2 SWAP

   Exemple : 4 3 SWAP  // 3 4 --- 3 4

              Pile Avant                Pile AprŠs
             +----------+              +----------+
             |    3     | <- Sommet    |    4     | <- Sommet
             +----------+              +----------+
             |    4     |              |    3     |
                 ....                      ....

             TITI TOTO SWAP  // TOTO TITI --- TOTO TITI

              Pile Avant                Pile AprŠs
             +----------+              +----------+
             |   TOTO   | <- Sommet    |   TITI   | <- Sommet
             +----------+              +----------+
             |   TITI   |              |   TOTO   |
                 ....                      ....

OVER                    s1 s2 --- s2 s1 s2

   Duplique le symbole situ‚ sous le premier.

   Syntaxe : Sym1 Sym2 OVER

   Exemple : 4 3 OVER  // 3 4 --- 4 3 4

              Pile Avant                Pile AprŠs
             +----------+              +----------+
             |    3     | <- Sommet    |    4     | <- Sommet
             +----------+              +----------+
             |    4     |              |    3     |
                 ....                  +----------+
                                       |    4     |
                                           ....

ROT                     s1 s2 s3 --- s2 s1 s3

   Effectue une permutation circulaire sur les trois symboles situ‚s
   au sommet de la pile.

   Syntaxe : Sym1 Sym2 Sym3 ROT

   Exemple : 1 2 3 ROT  // 3 2 1 --- 2 3 1

              Pile Avant                Pile AprŠs
             +----------+              +----------+
             |    3     | <- Sommet    |    1     | <- Sommet
             +----------+              +----------+
             |    2     |              |    3     |
             +----------+              +----------+
             |    1     |              |    2     |
                 ....                      ....

NIP                     s1 s2 --- s1

   Supprime le symbole situ‚ sous le premier.

   Syntaxe : Sym1 Sym2 NIP

   Exemple : 1 2 NIP  // 2 1 --- 2

              Pile Avant                Pile AprŠs
             +----------+              +----------+
             |    2     | <- Sommet    |    2     | <- Sommet
             +----------+                  ....    
             |    1     |
                 ....

DROP                    s ---

   Supprime le symbole situ‚ au sommet de la pile.

   Syntaxe : Sym DROP

   Exemple : 2 DROP  // 2 ---

              Pile Avant                Pile AprŠs
             +----------+              +----------+
             |    2     | <- Sommet        ....     <- Sommet
                 ....

   Note : NIP est ‚quivalent … la s‚quence SWAP DROP.

PICK                    n --- s

   Duplique le niŠme symbole de la pile de donn‚e.

   Syntaxe : n PICK

   n va de 1 au nombre de symboles empil‚s.

   Exemple : : TEST
                1 2 3
                3 PICK            // duplique 1 au dessus de la pile
             ;

   Note : DUP est ‚quivalent … 1 PICK
          OVER est ‚quivalent … 2 PICK

I                       --- n

   Empile l'indice courant de la boucle la plus interne.

   Syntaxe : I

   Exemple : 3 0
             DO
                I PRINT
             LOOP

J                       --- n

   Empile l'indice de la boucle externe, dans le cas de deux boucles
   imbriqu‚es.

   Syntaxe : J

   Exemple : 5 0
             DO  <------+
                3 0     | Indice courant
                DO <--+ | de la boucle externe
                      | |
                   I -+ |
                   J ---+
                   PRINT
                LOOP
                CR
             LOOP

K                       --- n

   Empile l'indice courant de la boucle la plus externe, dans le cas de
   trois boucles imbriqu‚es.

   Syntaxe : K

   Exemple : 10 0
             DO <--------------+
                5 0            |
                DO <--------+  |
                   3 0      |  |
                   DO <--+  |  |
                         |  |  |
                      I -+  |  |
                      J ----+  |
                      K -------+
                      PRINT
                   LOOP
                   CR
                LOOP
                CR
             LOOP

LES TEST
--------

==                      s1 s2 --- b

   Empile VRAI si les deux symboles situ‚s au sommet de la pile sont
   ‚gaux.

   Syntaxe : Sym1 Sym2 ==

   Exemple : TOTO 3 ==
             IF
                ...
             ENDIF

   Note : Les symboles peuvent de type quelconque (num‚rique ou caractŠre).

<                       s1 s2 --- b

   Empile VRAI si Sym1 est inf‚rieur … Sym2.

   Syntaxe : Sym1 Sym2 <

   Exemple : TOTO 5 <
             IF
                ...
             ENDIF

   Note : Les symboles peuvent de type quelconque (num‚rique ou caractŠre).

>                       s1 s2 --- b

   Empile VRAI si Sym1 est sup‚rieur … Sym2.

   Syntaxe : Sym1 Sym2 >

   Exemple : TOTO 78 >
             IF
                ...
             ENDIF

   Note : Les symboles peuvent de type quelconque (num‚rique ou caractŠre).

!=                      s1 s2 --- b

   Empile VRAI si Sym1 est diff‚rent de Sym2.

   Syntaxe : Sym1 Sym2 !=

   Exemple : TOTO 75 !=
             IF
                ...
             ENDIF

   Note : Les symboles peuvent de type quelconque (num‚rique ou caractŠre).

<=                      s1 s2 --- b

   Empile VRAI si Sym1 est inf‚rieur ou ‚gal … Sym2.

   Syntaxe : Sym1 Sym2 <=

   Exemple : TOTO TITI <=
             IF
                ...
             ENDIF

   Note : Les symboles peuvent de type quelconque (num‚rique ou caractŠre).

>=                      s1 s2 --- b

   Empile VRAI si Sym1 est sup‚rieur ou ‚gal … Sym2.

   Syntaxe : Sym1 Sym2 >=

   Exemple : TOTO " COUCOU" >=
             IF
                ...
             ENDIF

   Note : Les symboles peuvent de type quelconque (num‚rique ou caractŠre).

LES STRUCTURES DE CONTROLE
--------------------------

Note : Vous pouvez imbriquer les structures suivantes … l'infini (dans les
       limites de la m‚moire disponible).

IF ELSE ENDIF           b ---

   Ex‚cution conditionnelle.

   Syntaxes : <condition> IF <InstV> ENDIF
              ou
              <condition> IF <InstV> ELSE <InstF> ENDIF

   Si <condition> empile la valeur VRAI (toute valeur diff‚rente de 0), les
   instructions repr‚sent‚es par <IntsV> seront ex‚cut‚es, sinon, les
   ‚ventuelles instructions repr‚sent‚es par <InstF> seront ex‚cut‚es.
   L'ex‚cution du programme continura ensuite aprŠs le ENDIF.

   Exemple : TOTO 3 == IF
                          " TOTO est ‚gal … 3" print
                       ENDIF
             PSEUDO IF
                       ...
                    ELSE
                       " vous devez vous certifier !" LINE0
                    ENDIF

DO LOOP | +LOOP         nDeb nFin ---

   Boucle it‚rative.

   Syntaxes : Fin D‚but DO <Instructions> LOOP
              ou
              Fin D‚but DO <Instructions> <Pas> +LOOP

   Ex‚cute <Instructions> (Fin-D‚but) fois.
   La premiŠre forme (DO ... LOOP) incr‚mente l'indice de 1.
   La seconde forme (DO ... <Pas> +LOOP) incr‚ment l'indice de <Pas>.
   L'ex‚cution se poursuit aprŠs le LOOP (ou +LOOP) quand l'indice
   atteint Fin.

   Exemple :  5 0 DO " coucou" PRINT LOOP  // Affiche 5 " coucou"
              10 0
              DO
                 " coucou" print
              2 +LOOP                      // Affiche 5 " coucou"

BEGIN AGAIN             ---

   Boucle infinie.

   Syntaxe : BEGIN <Instructions> AGAIN

   Ex‚cute <Instructions> … l'infini.

   Exemple : BEGIN
                " Veuilez vous d‚connecter" LINE0
             AGAIN

BEGIN UNTIL             ---

   Boucle conditionnelle.

   Syntaxe : BEGIN <Instructions> <Condition> UNTIL

   Ex‚cute <Instructions> jusqu'… ce que <Condition> Empile une valeur VRAI
   (toute valeur diff‚rente de 0). A ce moment,  l'ex‚cution du programme
   continue aprŠs le UNTIL.

   Exemple : BEGIN
                " Veuilez vous d‚connecter" LINE0
             0 UNTIL  // Boucle infinie
             BEGIN
                " Entrez votre choix" PRINT
                24 13 LOCATE
                INPUT
                DATA VAL 0 !=
             UNTIL

BEGIN WHILE REPEAT      ---

   Boucle conditionnelle.

   Syntaxe : BEGIN <Condition> WHILE <Instructions> REPEAT

   Tant que <Condition> empile une valeur VRAI (toute valeur diff‚rente de 0),
   <Instructions> est ex‚cut‚. Sinon, l'ex‚cution du programme continue aprŠs
   le REPEAT.

   Exemple :  BEGIN
                 TOTO TITI !=
              WHILE
                 TOTO ++
              REPEAT

CASE OF ENDOF ENDCASE   s ---

   S‚lection multiple.

   Syntaxe : <TVal> CASE <iVal> OF <Inst> ENDOF ENDCASE

   <TVal> est la valeur … tester (de n'importe quel type).
   Si une des valeurs <iVal> correspond … <TVal>, le bloc d'instructions
   <Inst> correspondant est ex‚cut‚, puis l'ex‚cution du programme continue
   aprŠs le ENDCASE.
   Si des instructions sont pr‚sentes entre le dernier ENDOF et le ENDCASE,
   elles seront ex‚cut‚es si aucune des <iVal> ne correspond.

   Exemple : TOTO
             CASE
                1 OF
                     PURGEBAL
                  ENDOF
                2 OF
                     CREERBAL
                  ENDOF
                  DROP            // On ‚limine TOTO de la pile
                  " Choix incorrect! " LINE0
             ENDCASE

   IMPORTANT :  Pr‚voir un DROP, entre le dernier ENDOF et le ENDCASE, pour
                ‚liminer la valeur … tester de la pile, en cas de non succŠs
                des divers tests.

DIVERS
------

#USE NomLib ...

   R‚f‚rencement des librairies/modules utilis‚s par l'application en cours
   de compilation.

   Syntaxe : #USE NomLib1 [NomLib2 ...]

   Permet au compilateur de r‚f‚rencer les divers appels de proc‚dures
   et accŠs aux variables externe.

   Le nom de la librairie peut comporter un ‚ventuel chemin d'accŠs, sinon
   c'est celui ‚ventuellement d‚finit par la commande PATHAPPS (voir
   SERVEUR.DOC section [System] du fichier NEOSERV.INI) qui est pris.

   Si la librairie n'existe pas au moment de son r‚f‚rencement, elle est
   automatiquement charg‚e.

   APPEL DE PROCEDURES EXTERNE
   ---------------------------
   La syntaxe d'appel d'une proc‚dure externe est la suivante :

   NomLib::NomProc

   NomLib doit ˆtre le nom d'une des librairies r‚f‚renc‚es dans la directive
   #USE, sinon le compilateur g‚n‚rera une erreur.
   
   NomProc doit ˆtre le nom d'une des proc‚dures de la librairie, sinon le
   compilateur g‚n‚rera une erreur.

   Exemple :  // Librairie LIB1.NPG
              : PROC1
                 ...
              ;
              : PROC2
                 ...
              ;

              // Application TEST.NPG
              #USE LIB1
              ...
              : PROC
                 ...
                 // Appel de proc1 de lib1
                 LIB1::PROC1
                 ...
              ;
              ...
              : MAIN
                 ...
              ;

   ACCES AUX VARIABLES EXTERNES
   ----------------------------
   La syntaxe d'accŠs … une variable externe est la suivante :

   NomLib.NomVar

   NomLib doit ˆtre le nom d'une des librairies r‚f‚renc‚es dans la directive
   #USE, sinon le compilateur g‚n‚rera une erreur.

   NomVar doit ˆtre le nom d'une des variables (locale ou publique) de la
   librairie, sinon le compilateur g‚n‚rera une erreur.

   Exemple :  // Librairie LIB1.NPG
              PUBLIC NUMBER NUM
              LOCAL CHAR TOTO
              ...
              : PROC1
                 ...
              ;
              : PROC2
                 ...
              ;

              // Application TEST.NPG
              #USE LIB1
              LOCAL NUMBER TOTO
              ...
              : PROC
                 ...
                 // Appel de proc1 de lib1
                 LIB1::PROC1
                 ...
                 // Incr‚mentation de NUM de LIB1
                 LIB1.NUM ++
              ;
              ...
              : MAIN
                 ...
                 // Affichage de TOTO de LIB1
                 LIB1.TOTO PRINT
                 // Affichage de TOTO de TEST
                 TOTO PRINT
              ;

//

   Commentaires.
   Le reste de la ligne est ignor‚.

:

   Cr‚ation d'une proc‚dure/fonction.

   Syntaxe : : <Nom> ... ;

   Cr‚‚ une nouvelle proc‚dure/fonction dans le bloc de code de l'application
   courante.
   Toute d‚finition doit se terminer par ';'.
   Si <Nom> existe d‚j…, une erreur est g‚n‚r‚e.

   Exemple : : BIENVENUE
                " Bonjour" LINE0
             ;
             : MAIN             // Programme principal.
                CLS
                BIENVENUE
                ...
             ;

   Note : il doit exister dans toute application destin‚e … ˆtre appel‚e,
          une proc‚dure de nom "MAIN", qui repr‚sente le point d'entr‚e du
          programme. C'est la proc‚dure qui est appel‚e aprŠs l'initialisation
          de la connexion (… la r‚ception d'une trame d'appel (X25) ou d'un
          appui sur SHIFT+CONNEXION/FIN (MINITEL LOCAL)).
          Si MAIN n'existe pas, l'application ne pourra ˆtre appel‚e
          directement (voir les appels de proc‚dure externes et la directive
          #USE).

          Une application peut comporter une proc‚dure de nom "ONLIB", qui
          sera appel‚e … la d‚connexion d'un utilisateur.
          Cette proc‚dure "h‚rite" des variables locales du connect‚ au moment
          de la d‚connexion.
          Si elle doit utiliser des bases de donn‚es, la proc‚dure ONLIB devra
          les ouvrir.
          A la fin de son ex‚cution, la proc‚dure ONLIB  est automatiquement
          d‚sactiv‚e.
          Une proc‚dure ONLIB s'ex‚cute jusqu'… sa d‚sactivation automatique
          (fin de la proc‚dure), o— jusqu'… l'activation d'une nouvelle
          proc‚dure ONLIB pour le connect‚ con‡ern‚.
          Les primitives d'entr‚e/sorties (INPUT, PRINT, ...) n'ont aucun effet
          dans les proc‚dures ONLIB.

   Exemple : : ONLIB
                " BAL" dbopen
                if
                   PurgeBAL
                endif
             ;

          Une application peut aussi comporter une proc‚dure de nom "GTASK",
          qui est la tƒche globale de celle-ci.
          Cette tƒche est lanc‚e automatiquement … la premiŠre connexion
          … l'application, et d‚sactiv‚e automatiquement … la derniŠre
          d‚connexion, o— … la fin de son ex‚cution (';').
          La tƒche globale possŠde son propre jeu de variables locales.
          Si elle doit utiliser des bases de donn‚es, la proc‚dure GTASK devra
          les ouvrir.

   Exemple : : GTASK
                " BAL" dbopen
                if
                   PurgeBAL
                endif
             ;

;

   Marque la fin de d‚finition d'une proc‚dure/fonction.

   Voir ':'.

PUBLIC

   D‚claration de variables publiques.

   Syntaxe : PUBLIC <Type> <NomV> [:= <Valeur>] ...

   Cr‚‚ une nouvelle variable de nom <NomV>, de type <Type>, en lui
   affectant ‚ventuellement la valeur <Valeur>.
   Les variables publiques sont accessibles par tous les connect‚s d'une
   application.

   Exemples : PUBLIC CHAR NOMMENU := " MENUGEN.PAG"  // Nom de la page de menu
              PUBLIC
              NUMBER OPT1 OPT2 OPT3          // Cr‚ation de 3 variables num‚riques.
              PUBLIC CHAR[] 8 8 DAMIER       // Cr‚ation du tableau de nom DAMIER,
                                             // de 8 lignes et 8 colonnes.

LOCAL

   D‚claration de variables locales.

   Syntaxe : LOCAL <Type> <NomV> [:= <Valeur>] ...

   Cr‚‚ une nouvelle variable de nom <NomV>, de type <Type>, en lui
   affectant ‚ventuellement la valeur <Valeur>.
   Les variables locales sont locales (!) … chaque connect‚. A chaque
   connexion, un jeu de ces variables est cr‚‚ pour le connect‚ courant.

   Exemples : LOCAL
              CHAR PSEUDO NOM PRENOM
              LOCAL NUMBER AGE
              LOCAL NUMBER[] 1 8 VECTEUR   // Cr‚ation d'un tableau de 1 ligne
                                           // et 8 colonnes

CHAR

   Cr‚ation d'une variable de type caractŠre.

   Syntaxe : CHAR <NomV> [:= <Valeur>] ...

   Cr‚‚ une nouvelle variable caractŠre de nom <NomV>, en lui affectant
   ‚ventuellement la valeur <Valeur>.

   Exemples : LOCAL
              CHAR PSEUDO NOM PRENOM

CHAR[]

   Cr‚ation de tableaux de caractŠres.

   Syntaxe : CHAR[] MaxLig MaxCol <NomT>

   Cr‚‚ un nouveau tableau de nom <NomT>, de MaxLig sur MaxCol ‚l‚ments.
   Les indices d'un tableau commencent … 0 et vont jusqu'… Nbelt.-1.

   Exemple : PUBLIC CHAR[] 8 8 DAMIER       // Cr‚ation du tableau de nom DAMIER,

NUMBER

   Cr‚ation d'une variable de type num‚rique.

   Syntaxe : NUMBER <NomV> [:= <Valeur>] ...

   Cr‚‚ une nouvelle variable caractŠre de nom <NomV>, en lui affectant
   ‚ventuellement la valeur <Valeur>.

   Exemples : LOCAL
              NUMBER OPT1 := 2 OPT2

NUMBER[]

   Cr‚ation de tableaux de nombres.

   Syntaxe : NUMBER[] MaxLig MaxCol <NomT>

   Cr‚‚ un nouveau tableau de nom <NomT>, de MaxLig sur MaxCol ‚l‚ments.
   Les indices d'un tableau commencent … 0 et vont jusqu'… Nbelt.-1.

   Exemple : LOCAL NUMBER[] 8 8 DAMIER       // Cr‚ation du tableau de nom DAMIER,

LIBCV                   n ---

   D‚connecte le cv donn‚.

   Syntaxe : ncv LIBCV

   <ncv> est compris entre 0 et le nombre de cv maximum g‚r‚s par le
   serveur - 1.
   Si le num‚ro donn‚ est invalide, rien ne se passe.

   Exemple : NBESSAI 3 >
             IF
                // Nombre d'essais d‚pass‚, on se d‚connecte
                NUMCV LIBCV
             ENDIF

@                       Sym --- Val

   Empile la valeur du symbole donn‚.

   Syntaxe : Sym @

   Exemple : 5 3 TAB @ DUP   // duplique l'‚l‚ment et non le tableau
             ...
             : TEST  // --- sym
               ...
               TOTO @        // Empile la valeur courante de TOTO.
               ...
               TOTO ++       // La pile contient l'ancienne valeur de TOTO.
             ;

SPACE                   --- s

   Empile une chaine contenant un espace.

   Syntaxe : SPACE

   Exemple : : TEST
                ... PRINT SPACE
             ;

SPACES                  n --- s

   Empile une chaine contenant n espaces.

   Syntaxe : n SPACES

   Exemple : : TEST
                ... PRINT 5 SPACES
             ;

EMPTY?                  s --- b

   Empile VRAI si le symbole donn‚ est vide.

   Syntaxe : Sym EMPTY?

   Sym doit ˆtre un symbole d'un type simple (pas de type tableau).

   Si Sym est un NUMBER, EMPTY? empile VRAI si celui-ci est ‚gal … 0.
   Si Sym est un CHAR, EMPTY? empile VRAI si la chaine est de longueur 0,
   o— si celle-ci n'est compos‚e que d'espaces.

   Exemple : : SAISIE
                " ENTREZ VOTRE NOM" LINE0
                5 5 LOCATE
                INPUT
                DUP EMPTY?
                IF
                   " SAISIE OBLIGATOIRE" LINE0
                   ...
                ELSE
                   NOM :=
                ENDIF
             ;

DISPLAY                 s ---

   Affiche le contenu du symbole donn‚ sur l'‚cran du serveur.

   Syntaxe : Sym DISPLAY

   Exemple : : MAIN
                " DEBUT" DISPLAY
                ...
             ;

EXECUTE                 s ---

   Ex‚cute la proc‚dure dont le nom est contenu dans la chaine donn‚e.

   Syntaxe : NomProc EXECUTE

   NomProc est la chaine contenant le nom de la proc‚dure … appeler.
   Si la proc‚dure n'existe pas, o— n'est pas une proc‚dure, une erreur
   d'ex‚cution est g‚n‚r‚e.
   Une fois la proc‚dure ex‚cut‚e, le retour s'effectue aprŠs l'appel.

   Exemples : LOCAL CHAR NOMPROC := " BAL::MENUGEN"
              ...
              NOMPROC EXECUTE
              ...
              " SAISIE" EXECUTE
              ...

EXECUTEAPP              s ---

   Ex‚cute l'application dont le nom est contenu dans la chaine donn‚e.

   Syntaxe : NomApp EXECUTEAPP

   NomApp est la chaine contenant le nom de l'application … appeler.
   Si l'application n'existe pas, o— n'est pas une application valide
   (ne possŠde pas de MAIN), une erreur d'ex‚cution est g‚n‚r‚e.

   L'appel de l'application provoque la d‚connexion de l'application courante,
   et le re-connexion … l'application donn‚e.

   Note : Certaines informations du connect‚ sont conserv‚e (Nø de port,
   trame de connexion initiale, d‚partement, pavi, palier, type de minitel).

   Exemples : LOCAL CHAR NOMAPP := " BENCH"
              ...
              NOMAPP EXECUTEAPP
              ...
              " TEST" EXECUTEAPP
              ...

SEARCHAPP               s --- b

   Cherche l'application dont le nom est contenu dans la chaine donn‚e, dans
   la liste des applications pr‚sentes sur le serveur.

   Syntaxe : NomApp SEARCHEAPP

   Empile VRAI si l'application existe et est valide (possŠde un MAIN), FAUX
   sinon.

   Exemple : " ENTREZ UNE APPLICATION" PRINT
             NOMAPP INPUTVAR
             NOMAPP SEARCHAPP
             IF
                NOMAPP EXECUTEAPP
             ELSE
                " APPLICATION NON VALIDE" LINE0
             ENDIF

EXECKBDCMD              s --- n

   Ex‚cute la commande clavier donn‚e.

   Syntaxe : <Cmd> EXECKBDCMD

   Empile 0 si la commande s'est correctement ex‚cut‚e, un code d'erreur
   sinon.
   La commande ex‚cut‚e est ajout‚e … l'historique du serveur.
   On r‚servera en g‚n‚ral cette fonctionnalit‚ au "sysop" du serveur.

   Exemple : LOCAL NUMBER ISSYSOP
             ...
             : GESTION
                ...
                ISSYSOP
                IF
                   " Tapez une commande" print cr
                   INPUT EXECKBDCMD
                   IF
                      " Erreur" line0
                      ...
                   ENDIF
                ENDIF
             ;

   D‚tail des codes d'erreurs renvoy‚s:
   -1  : Commande inconnue.
   21  : Commande VIEW ...: paramŠtre invalide
   20  : Commande VIEW ...: paramŠtre manquant
   222 : Commande VIEW CV ...: CV inactif
   221 : Commande VIEW CV ...: CV non valide
   220 : Commande VIEW CV ...: Nø de CV manquant
   262 : Commande VIEW VAR ...: variable inconnue
   261 : Commande VIEW VAR ...: paramŠtre manquant
   260 : Commande VIEW VAR ...: mode trace inactif
   230 : Commande VIEW APP ...: application inexistante
   33  : Commande SEND ...: CV inactif
   32  : Commande SEND ...: Nø de CV non valide
   31  : Commande SEND ...: paramŠtre manquant
   30  : Commande SEND ...: message manquant
   41  : Commande SET ...: paramŠtre invalide
   40  : Commande SET ...: paramŠtre manquant
   400 : Commande SET PALIER ...: paramŠtre manquant
   410 : Commande SET COLOR ...: paramŠtre manquant
   421 : Commande SET SYSTEM TRACEPAQUET ...: erreur d'ouverture du fichier
   422 : Commande SET SYSTEM TRACESERVEUR ...: erreur d'ouverture du fichier
   420 : Commande SET SYSTEM ...: paramŠtre manquant
   51  : Commande LOAD ...: erreur(s) de compilation
   50  : Commande LOAD ...: paramŠtre manquant
   60  : Commande UNLOAD ...: paramŠtre manquant
   73  : Commande LCX ...: CV inactif
   72  : Commande LCX ...: pas de connect‚s actifs
   71  : Commande LCX ...: paramŠtre invalide
   70  : Commande LCX ...: paramŠtre manquant
   82  : Commande DEBUG ...: CV inactif
   81  : Commande DEBUG ...: Nø de CV invalide
   80  : Commande DEBUG ...: paramŠtre manquant
   101 : Commande DEBUGSTEP ...: pas de trace invalide
   100 : Commande DEBUGSTEP ...: paramŠtre manquant
   110 : Commande CONNECT ...: paramŠtre manquant
   111 : Commande CONNECT ...: num‚ro de port non valide
   112 : Commande CONNECT ...: type du port non valide
   113 : Commande CONNECT ...: application inexistante
   114 : Commande CONNECT ...: application non valide
   115 : Commande CONNECT ...: connexion impossible

WAIT                    ---

   Met le programme en attente d'une action de l'utilisateur.

   Syntaxe : WAIT

   Le programme attend une action de l'utilisateur avant de continuer
   son ex‚cution. En g‚n‚ral, l'action attendue est l'appui sur une touche
   de fonction du minitel.

   Exemple : " Appuyez sur SUITE" PRINT
             WAIT
             ...

WAITEMPTYBUFFER         ---

   Attend que le buffer de sortie du connect‚ courant soit vide
   avant de continuer l'ex‚cution du programme.

   Syntaxe : WAITEMPTYBUFFER

   Exemple : " BIGPAGE.VTX" SENDPAGE
             WAITEMPTYBUFFER
             ...

WAITCHAR                n ---

   Attente d'un caractŠre donn‚ sur le flux du connect‚ courant.

   Syntaxe : n WAITCHAR

   n est le code ascii du caractŠre … attendre.
   l'ex‚cution du code du connect‚ courant est suspendue jusqu'…
   l'arriv‚e du caractŠre donn‚.
   Toutes les donn‚es re‡ues sont empil‚es, jusqu'au caractŠre.

   Exemple : // Attente d'un CR
             : WAITCR
                13 CHR WAITCHAR
             ;

DELAY                   n ---

   Interrompt l'ex‚cution du programme pendant le nombre de millisecondes
   donn‚.

   Syntaxe : n DELAY

   Exemple : 2000 DELAY  // Attend 2 secondes.

:=                      sd ss ---

   Affectation de variables.

   Syntaxe : Src Dst :=

   Affecte … la variable Dst la valeur de Src.

   Exemples : 3 TOTO :=
              " Choix incorrect!" MSGERR :=

SETGLOBALFKEY           ---

   Assignation de touches de fonction.
   L'assignation est globale … l'application (valable pour tous les
   connect‚s de l'application).

   Syntaxe : SETGLOBALFKEY [*|#]NomTouche NomProc [NORETURN]

   Assigne … la touche de fonction NomTouche la proc‚dure NomProc.
   La touche peut ˆtre pr‚c‚d‚e du caractŠre Etoile "*" ou DiŠse "#"
   (*NomTouche, #NomTouche, NomTouche sont 3 assignations diff‚rentes).
   AprŠs l'assignation, l'appui sur la combinaison intercept‚e provoquera
   l'appel de la proc‚dure NomProc.
   Le paramŠtre optionnel NORETURN permet de d‚terminer si il faut ou non
   reprendre l'ex‚cution de la proc‚dure interrompue.
   Si NORETURN est sp‚cifi‚, la proc‚dure interrompue est abandonn‚e.

   NomTouche peut ˆtre : FKENVOI
                         FKRETOUR
                         FKREPETITION
                         FKGUIDE
                         FKANNULATION
                         FKSOMMAIRE
                         FKCORRECTION
                         FKSUITE

   Exemple : : AIDE
                " GUIDE01.PAG" SENDPAGE
                WAIT
             ;
             ...
             : MAIN
                SETGLOBALFKEY FKGUIDE AIDE
                ...
                SETLOCALFKEY FKANNULATION DELBAL NORETURN
             ;

   NOTE : Si une assignation existe d‚j… avec la combinaison donn‚e, elle
          est remplac‚e par la nouvelle.

SELGLOBALKEYWORD        ---

   Assignation d'un mot-clef.
   L'assignation est globale … l'application (valable pour tous les
   connect‚s de l'application).

   Syntaxe : SETGLOBALKEYWORD MotClef NomProc [NORETURN]

   Assigne au mot-clef MotClef la proc‚dure NomProc.
   AprŠs l'assignation, la frappe du mot-clef provoquera l'appel de
   la proc‚dure NomProc.
   Le paramŠtre optionnel NORETURN permet de d‚terminer si il faut ou non
   reprendre l'ex‚cution de la proc‚dure interrompue.
   Si NORETURN est sp‚cifi‚, la proc‚dure interrompue est abandonn‚e.

   Exemple : : AIDE
                " GUIDE01.PAG" SENDPAGE
                WAIT
             ;
             ...
             : MAIN
                SETGLOBALKEYWORD *HELP AIDE
             ;

   NOTE : Si une assignation existe d‚j… avec le mot-clef donn‚, elle
          est remplac‚e par la nouvelle.

SETLOCALFKEY            ---

   Assignation de touches de fonction.
   L'assignation est locale au connect‚ courant.

   Syntaxe : SETLOCALFKEY [*|#]NomTouche NomProc [NORETURN]

   Assigne … la touche de fonction NomTouche la proc‚dure NomProc.
   La touche peut ˆtre pr‚c‚d‚e du caractŠre Etoile "*" ou DiŠse "#"
   (*NomTouche, #NomTouche, NomTouche sont 3 assignations diff‚rentes).
   AprŠs l'assignation, l'appui par le connect‚ courant sur la combinaison
   intercept‚e provoquera l'appel de la proc‚dure NomProc.
   Le paramŠtre optionnel NORETURN permet de d‚terminer si il faut ou non
   reprendre l'ex‚cution de la proc‚dure interrompue.
   Si NORETURN est sp‚cifi‚, la proc‚dure interrompue est abandonn‚e.

   NomTouche peut ˆtre : FKENVOI
                         FKRETOUR
                         FKREPETITION
                         FKGUIDE
                         FKANNULATION
                         FKSOMMAIRE
                         FKCORRECTION
                         FKSUITE

   Exemple : : SUPPRIMER
                ...
             ;
             ...
             : AUTORISATION
                PRIVILEGE
                IF
                   SETLOCALFKEY *FKANNULATION SUPPRIMER
                   " *ANNULATION POUR DETRUIRE" LINE0
                ENDIF
             ;

   NOTE : Si une assignation existe d‚j… avec la combinaison donn‚e, elle
          est remplac‚e par la nouvelle.

SETLOCALKEYWORD         ---

   Assignation d'un mot-clef.
   L'assignation est locale au connect‚ courant.

   Syntaxe : SETLOCALKEYWORD MotClef NomProc [NORETURN]

   Assigne au mot-clef MotClef la proc‚dure NomProc.
   AprŠs l'assignation, la frappe du mot-clef provoquera l'appel de
   la proc‚dure NomProc.
   Le paramŠtre optionnel NORETURN permet de d‚terminer si il faut ou non
   reprendre l'ex‚cution de la proc‚dure interrompue.
   Si NORETURN est sp‚cifi‚, la proc‚dure interrompue est abandonn‚e.

   Exemple : : SUPPRIMER
                ...
             ;
             ...
             : AUTORISATION
                PRIVILEGE
                IF
                   SETLOCALKEYWORD *DEL SUPPRIMER
                   " *DEL POUR DETRUIRE" LINE0
                ENDIF
             ;

   NOTE : Si une assignation existe d‚j… avec le mot-clef donn‚, elle
          est remplac‚e par la nouvelle.

EMPTYLOCALFKEYTABLE     ---

   Vide la table d'assignation des touches de fontion locale au
   connect‚ courant.

   Syntaxe : EMPTYLOCALFKEYTABLE

   La table (si elle existe), est vid‚e, les touches de fonction
   reprennent leur usage normal.

EMPTYGLOBALFKEYTABLE    ---

   Vide la table d'assignation des touches de fontion globale …
   l'application du connect‚ courant.

   Syntaxe : EMPTYGLOBALFKEYTABLE

   La table (si elle existe), est vid‚e, les touches de fonction
   reprennent leur usage normal pour toute l'application du connect‚
   courant.

EMPTYLOCALKEYWORDTABLE  ---

   Vide la table d'assignation des mots-clefs locale au
   connect‚ courant.

   Syntaxe : EMPTYLOCALKEYWORDTABLE

   La table (si elle existe), est vid‚e, la frappe des mots-clefs
   n'a plus d'effet.

EMPTYGLOBALKEYWORDTABLE ---

   Vide la table d'assignation des mots-clefs globale … l'application
   du connect‚ courant.

   Syntaxe : EMPTYLOCALKEYWORDTABLE

   La table (si elle existe), est vid‚e, la frappe des mots-clefs
   n'a plus d'effet pour toute l'application.

DELETEGLOBALFKEY        ---

   Suppression d'une assignation globale de touche de fonction.

   Syntaxe : DELETEGLOBALFKEY [*|#]NomTouche

   La touche peut ˆtre pr‚c‚d‚e du caractŠre Etoile "*" ou DiŠse "#"
   (*NomTouche, #NomTouche, NomTouche sont 3 assignations diff‚rentes).
   Voir la d‚finition de SETGLOBALFKEY pour la liste des nom de touche
   valides.
   Si la touche existe dans la table d'assignation globale, elle est
   supprim‚e. La frappe de celle-ci n'aura plus d'effet pour l'application.

   Exemple : : AIDE
                SETGLOBALFKEY FKSOMMAIRE ABANDON_AIDE
                ...
                DELETEGLOBALFKEY FKSOMMAIRE
             ;

DELETELOCALFKEY         ---

   Suppression d'une assignation locale de touche de fonction.

   Syntaxe : DELETELOCALFKEY [*|#]NomTouche

   La touche peut ˆtre pr‚c‚d‚e du caractŠre Etoile "*" ou DiŠse "#"
   (*NomTouche, #NomTouche, NomTouche sont 3 assignations diff‚rentes).
   Voir la d‚finition de SETLOCALFKEY pour la liste des nom de touche
   valides.
   Si la touche existe dans la table d'assignation locale, elle est
   supprim‚e. La frappe de celle-ci n'aura plus d'effet pour le connect‚.

   Exemple : : AIDE
                SETLOCALFKEY FKSOMMAIRE ABANDON_AIDE
                ...
                DELETELOCALFKEY FKSOMMAIRE
             ;

DELETEGLOBALKEYWORD     ---

   Suppression d'une assignation globale de mot-clef.

   Syntaxe : DELETEGLOBALKEYWORD MotClef

   Le mot-clef, si il existe, est supprim‚ de la table globale.
   La frappe de celui-ci n'aura plus d'effet pour l'application.

   Exemple : : AIDE
                SETGLOBALKEYWORD *SOM ABANDON_AIDE
                ...
                DELETEGLOBALKEYWORD *SOM
             ;

DELETELOCALKEYWORD      ---

   Suppression d'une assignation locale de mot-clef.

   Syntaxe : DELETELOCALKEYWORD MotClef

   Le mot-clef, si il existe, est supprim‚ de la table locale.
   La frappe de celui-ci n'aura plus d'effet pour le connect‚.

   Exemple : : AIDE
                SETLOCALKEYWORD *SOM ABANDON_AIDE
                ...
                DELETELOCALKEYWORD *SOM
             ;

DISABLELOCALFKEY        ---

   D‚sactive l'interception locale des touches de fonctions pour le connect‚
   courant.

   Syntaxe : DISABLELOCALFKEY

   La table d'interception est toujours pr‚sente, mais n'est plus prise en
   compte par le serveur.

   Exemple : : AIDE
                DISABLELOCALFKEY   // D‚sactivation temporaire.
                ...
                WAIT
                ENABLELOCALFKEY    // R‚activation.
             ;
             ...
             : MAIN
                SETLOCALFKEY FKGUIDE AIDE
                ...
             ;

DISABLEGLOBALFKEY       ---

   D‚sactive l'interception globale des touches de fonctions pour le connect‚
   courant.

   Syntaxe : DISABLEGLOBALFKEY

   La table d'interception est toujours pr‚sente, mais n'est plus prise en
   compte par le serveur.

   Exemple : : AIDE
                DISABLEGLOBALFKEY   // D‚sactivation temporaire.
                ...
                WAIT
                ENABLEGLOBALFKEY    // R‚activation.
             ;
             ...
             : MAIN
                SETGLOBALFKEY FKGUIDE AIDE
                ...
             ;

DISABLELOCALKEYWORD     ---

   D‚sactive l'interception locale des mots-clefs pour le connect‚
   courant.

   Syntaxe : DISABLELOCALKEYWORD

   La table d'interception est toujours pr‚sente, mais n'est plus prise en
   compte par le serveur.

   Exemple : : AIDE
                DISABLELOCALKEYWORD   // D‚sactivation temporaire.
                ...
                WAIT
                ENABLELOCALKEYWORD    // R‚activation.
             ;
             ...
             : MAIN
                SETLOCALKEYWORD *HELP AIDE
                ...
             ;

DISABLEGLOBALKEYWORD    ---

   D‚sactive l'interception globale des mots-clefs pour le connect‚
   courant.

   Syntaxe : DISABLEGLOBALKEYWORD

   La table d'interception est toujours pr‚sente, mais n'est plus prise en
   compte par le serveur.

   Exemple : : AIDE
                DISABLEGLOBALKEYWORD   // D‚sactivation temporaire.
                ...
                WAIT
                ENABLEGLOBALKEYWORD    // R‚activation.
             ;
             ...
             : MAIN
                SETGLOBALKEYWORD *HELP AIDE
                ...
             ;

ENABLELOCALFKEY         ---

   R‚active l'interception locale des touches de fonctions pour le connect‚
   courant.

   Syntaxe : ENABLELOCALFKEY

   La table d'interception est … nouveau prise en compte par le serveur.

   Exemple : : AIDE
                DISABLELOCALFKEY   // D‚sactivation temporaire.
                ...
                WAIT
                ENABLELOCALFKEY    // R‚activation.
             ;
             ...
             : MAIN
                SETLOCALFKEY FKGUIDE AIDE
                ...
             ;

ENABLEGLOBALFKEY        ---

   R‚active l'interception globale des touches de fonctions pour le connect‚
   courant.

   Syntaxe : ENABLEGLOBALFKEY

   La table d'interception est … nouveau prise en compte par le serveur.

   Exemple : : AIDE
                DISABLEGLOBALFKEY   // D‚sactivation temporaire.
                ...
                WAIT
                ENABLEGLOBALFKEY    // R‚activation.
             ;
             ...
             : MAIN
                SETGLOBALFKEY FKGUIDE AIDE
                ...
             ;

ENABLELOCALKEYWORD      ---

   R‚active l'interception locale des mots-clefs pour le connect‚
   courant.

   Syntaxe : ENABLELOCALKEYWORD

   La table d'interception est … nouveau prise en compte par le serveur.

   Exemple : : AIDE
                DISABLELOCALKEYWORD   // D‚sactivation temporaire.
                ...
                WAIT
                ENABLELOCALKEYWORD    // R‚activation.
             ;
             ...
             : MAIN
                SETLOCALKEYWORD *HELP AIDE
                ...
             ;

ENABLEGLOBALKEYWORD     ---

   R‚active l'interception globale des mots-clefs pour le connect‚
   courant.

   Syntaxe : ENABLEGLOBALKEYWORD

   La table d'interception est … nouveau prise en compte par le serveur.

   Exemple : : AIDE
                DISABLEGLOBALKEYWORD   // D‚sactivation temporaire.
                ...
                WAIT
                ENABLEGLOBALKEYWORD    // R‚activation.
             ;
             ...
             : MAIN
                SETGLOBALKEYWORD *HELP AIDE
                ...
             ;

TRANSLATEOFF            ---

   D‚sactive la conversion des accents du connect‚ courant.

   Syntaxe : TRANSLATEOFF

   Par d‚faut, les caractŠres accentu‚s en provenance d'un minitel (s‚quence de
   type Esc+Xx) sont convertis par N‚oServ, en caractŠre accentu‚s compatible
   avec le D.O.S.
   Cette conversion n'est plus effectu‚e aprŠs TRANSLATEOFF. Cela permet, entre
   autre, de manipuler les donn‚es telles qu'elles arrivent, dans le cas de
   l'impl‚mentation d'un protocole de t‚l‚chargement, par exemple.

   Exemple : : TELSEND
               TRANSLATEOFF
               ...
               TRANSLATEON
             ;

TRANSLATEON             ---

   Active la conversion des accents du connect‚ courant.

   Syntaxe : TRANSLATEON

   Par d‚faut, les caractŠres accentu‚s en provenance d'un minitel (s‚quence de
   type Esc+Xx) sont convertis par N‚oServ, en caractŠre accentu‚s compatible
   avec le D.O.S.
   Cette conversion est … nouveau active aprŠs TRANSLATEON.

   Exemple : : TELSEND
               TRANSLATEOFF
               ...
               TRANSLATEON
             ;

FILTERINGOFF            ---

   D‚sactive le filtrage des s‚quences "escapes" du connect‚ courant.

   Syntaxe : FILTERINGOFF

   Par d‚faut, les s‚quences de contr“les (appel‚e aussi "s‚quences escape", de
   type Esc+x) en provenance d'un minitel, sont filtr‚es et ‚limin‚es par
   N‚oServ.
   Ce filtrage n'est plus effectu‚ aprŠs FILTERINGOFF. Cela permet, entre
   autre, de manipuler les donn‚es telles qu'elles arrivent, dans le cas de
   l'impl‚mentation d'un protocole de t‚l‚chargement, par exemple.

   Exemple : : TELSEND
               TRANSLATEOFF
               FILTERINGOFF
               ...
               FILTERINGON
               TRANSLATEON
             ;

FILTERINGON             ---

   Active le filtrage des s‚quences "escapes" du connect‚ courant.

   Syntaxe : FILTERINGON

   Par d‚faut, les s‚quences de contr“les (appel‚e aussi "s‚quences escape", de
   type Esc+x) en provenance d'un minitel, sont filtr‚es et ‚limin‚es par
   N‚oServ.
   Ce filtrage est … nouveau actif aprŠs FILTERINGON.

   Exemple : : TELSEND
               TRANSLATEOFF
               FILTERINGOFF
               ...
               FILTERINGON
               TRANSLATEON
             ;

SETBINARYMODE           ---

   Fait passer le connect‚ courant en mode binaire.

   Syntaxe : SETBINARYMODE

   Par d‚faut, NeoServ effectue certains traitements sur chaque paquet de
   donn‚es entrants (filtrage des s‚quences escapes, conversion des
   accents, r‚cup‚ration de la touche de fonction appuy‚e, ...).
   Ces traitements ne sont plus effectu‚s aprŠs SETBINARYMODE.
   Le mode binaire permet d'impl‚menter divers protocoles (t‚l‚chargement,
   ...).

   Exemple : : TELSEND
               SETBINARYMODE
               ...
               SETNORMALMODE
             ;

   Note : Le paquet entrant est r‚cup‚rable avec DATA.

SETNORMALMODE           ---

   Fait passer le connect‚ courant en mode normal.

   Syntaxe : SETBINARYMODE

   Par d‚faut, NeoServ effectue certains traitements sur chaque paquet de
   donn‚es entrants (filtrage des s‚quences escapes, conversion des
   accents, r‚cup‚ration de la touche de fonction appuy‚e, ...).
   Ces traitements sont … nouveau effectu‚s aprŠs SETNORMALMODE.
   Le mode binaire permet d'impl‚menter divers protocoles (t‚l‚chargement,
   ...).

   Exemple : : TELSEND
               SETBINARYMODE
               ...
               SETNORMALMODE
             ;

LES OPERATEURS
--------------

&                       n1 n2 --- n3

   Effectue un ET binaire entre les deux symboles situ‚s au sommet de la pile,
   et empile le r‚sultat.

   Syntaxe : Sym1 Sym2 &

   Exemple : 3 TOTO :=
             5 TITI :=
             TOTO TITI &          // 00000011 & 00000101 = 00000001

|                       n1 n2 --- n3

   Effectue un OU binaire entre les deux symboles situ‚s au sommet de la pile,
   et empile le r‚sultat.

   Syntaxe : Sym1 Sym2 |

   Exemple : 3 TOTO :=
             5 TITI :=
             TOTO TITI |          // 00000011 & 00000101 = 00000111

^                       n1 n2 --- n3

   Effectue un OU EXCLUSIF binaire entre les deux symboles situ‚s au sommet
   de la pile, et empile le r‚sultat.

   Syntaxe : Sym1 Sym2 ^

   Exemple : 3 TOTO :=
             5 TITI :=
             TOTO TITI ^          // 00000011 & 00000101 = 00000110

&&                      b1 b2 --- b3

   Effectue un ET logique entre les deux symboles situ‚s au sommet de la pile,
   et empile le r‚sultat.

   Syntaxe : Sym1 Sym2 &&

   Exemple : TRUE TOTO :=
             FALSE TITI :=
             TOTO TITI &&         // Empile FALSE

||                      b1 b2 --- b3

   Effectue un OU logique entre les deux symboles situ‚s au sommet de la pile,
   et empile le r‚sultat.

   Syntaxe : Sym1 Sym2 ||

   Exemple : TRUE TOTO :=
             FALSE TITI :=
             TOTO TITI ||         // Empile TRUE

!                       b --- !b

   Effectue une n‚gation logique du symbole situ‚ au sommet de la pile,
   et empile le r‚sultat.

   Syntaxe : Sym !

   Exemple : TRUE TOTO :=
             TOTO !         // Empile FALSE
             !              // Empile TRUE

~                       n --- ~n

   Effectue une le compl‚ment … 1 du symbole situ‚ au sommet de la pile,
   et empile le r‚sultat.

   Syntaxe : Sym ~

   Exemple : 1 TOTO :=
             TOTO ~         // Empile -4

++                      s ---

   Incr‚mente le contenu du symbole situ‚ au sommet de la pile.

   Syntaxe : Sym ++

   Exemple : 5 TOTO :=
             ...
             TOTO ++         // TOTO = 6
             ...
             TOTO PRINT      // Affiche 6

--                      s ---

   D‚cr‚mente le contenu du symbole situ‚ au sommet de la pile.

   Syntaxe : Sym --

   Exemple : 5 TOTO :=
             ...
             TOTO --         // TOTO = 4
             ...
             TOTO PRINT      // Affiche 4

+=                      sd ss ---

   Ajoute le premier symbole au second.

   Syntaxe : Src Dst +=

   Est ‚quivalent … la s‚quence : Src Dst + Dst :=

   Exemple : 5 TOTO :=
             3 TOTO +=  // TOTO = 8

-=                      sd ss ---

   Soustrait le premier symbole au second.

   Syntaxe : Src Dst -=

   Est ‚quivalent … la s‚quence : Src Dst - Dst :=

   Exemple : 5 TOTO :=
             3 TOTO -=  // TOTO = 2

*=                      sd ss ---

   Multiple le premier symbole par la valeur du second.

   Syntaxe : Src Dst *=

   Est ‚quivalent … la s‚quence : Src Dst * Dst :=

   Exemple : 5 TOTO :=
             3 TOTO *=  // TOTO = 15

/=                      sd ss ---

   Divise le premier symbole par la valeur du second.

   Syntaxe : Src Dst /=

   Est ‚quivalent … la s‚quence : Src Dst / Dst :=

   Exemple : 10 TOTO :=
             2 TOTO /=  // TOTO = 5

%=                      sd ss ---

   Calcule le modulo de src et dst.

   Syntaxe : Src Dst %=

   Est ‚quivalent … la s‚quence : Src Dst % Dst :=

   Exemple : 10 TOTO :=
             2 TOTO %=  // TOTO = 0

&=                      sd ss ---

   Effectue un ET binaire entre src et dst.

   Syntaxe : Src Dst &=

   Est ‚quivalent … la s‚quence : Src Dst & Dst :=

   Exemple : 10 TOTO :=
             2 TOTO &=  // TOTO = 2

|=                      sd ss ---

   Effectue un OU binaire entre src et dst.

   Syntaxe : Src Dst |=

   Est ‚quivalent … la s‚quence : Src Dst | Dst :=

   Exemple : 10 TOTO :=
             2 TOTO |=  // TOTO = 10

^=                      sd ss ---

   Effectue un OU exclusif binaire entre src et dst.

   Syntaxe : Src Dst ^=

   Est ‚quivalent … la s‚quence : Src Dst ^ Dst :=

   Exemple : 10 TOTO :=
             2 TOTO ^=  // TOTO = 8

<<                      s2 s1 --- s3

   D‚cale Sym2 de Sym1 bits vers la gauche, et empile le r‚sultat.

   Syntaxe : Sym1 Sym2 <<

   Note : Sym1 ne doit pas ˆtre sup‚rieur … 31.

   Exemple : 4 TOTO :=
             2 TOTO <<  // Empile 16

>>                      s2 s1 --- s3

   D‚cale Sym2 de Sym1 bits vers la droite, et empile le r‚sultat.

   Syntaxe : Sym1 Sym2 >>

   Note : Sym1 ne doit pas ˆtre sup‚rieur … 31.

   Exemple : 4 TOTO :=
             2 TOTO >>  // Empile 1

<<=                     sd ss ---

   D‚cale Dst de Src bits vers la gauche, et met le r‚sultat dans Dst.

   Syntaxe : Src Dst <<=

   Est ‚quivalent … la s‚quence : Src Dst << Dst :=

   Note : Src ne doit pas ˆtre sup‚rieur … 31.

   Exemple : 4 TOTO :=
             2 TOTO <<=  // TOTO = 16

>>=                     sd ss ---

   D‚cale Dst de Src bits vers la droite, et met le r‚sultat dans Dst.

   Syntaxe : Src Dst >>=

   Est ‚quivalent … la s‚quence : Src Dst >> Dst :=

   Note : Src ne doit pas ˆtre sup‚rieur … 31.

   Exemple : 4 TOTO :=
             2 TOTO >>=  // TOTO = 1

LES MATHEMATIQUES
-----------------

+                       n1 n2 --- n3

   Additionne les deux symboles au sommet de la pile, et empile le
   r‚sultat.

   Syntaxe : Sym1 Sym2 +

   Exemple : 3 4 +  // Empile 7

-                       n1 n2 --- n3

   Soustrait les deux symboles au sommet de la pile, et empile le r‚sultat.

   Syntaxe : Sym1 Sym2 -

   Exemple : 8 4 -  // Empile 4

*                       n1 n2 --- n3

   Multiplie les deux symboles au sommet de la pile, et empile le r‚sultat.

   Syntaxe : Sym1 Sym2 *

   Exemple : 8 4 *  // Empile 32

/                       n1 n2 --- n3

   Divise Sym1 par Sym2, et empile le r‚sultat.

   Syntaxe : Sym1 Sym2 /

   Exemple : 8 4 /  // Empile 2

%                       n1 n2 --- n3

   Calcule le reste de la division de Sym1 par Sym2, et empile le r‚sultat.

   Syntaxe : Sym1 Sym2 %

   Exemple : 10 5 %  // Empile 0

ACOS                    n1 --- n2

   Empile l'arc cosinus du symbole donn‚.

   Syntaxe : Sym ACOS

   Exemple : 45.5 ACOS

ASIN                    n1 --- n2

   Empile l'arc sinus du symbole donn‚.

   Syntaxe : Sym ASIN

   Exemple : 45.5 ASIN

ATAN                    n1 --- n2

   Empile l'arc tangante du symbole donn‚.

   Syntaxe : Sym ATAN

   Exemple : 45.5 ATAN

ATAN2                   n1 n2 --- n3

   Empile l'arc tangante de Sym1/Sym2.

   Syntaxe : Sym1 Sym2 ATAN2

   Exemple : 35.5 45.5 ATAN2

CEIL                    n1 --- n2

   Arrondi le symbole donn‚e au chiffre imm‚diatement sup‚rieur, et empile
   le r‚sultat.

   Syntaxe : Sym CEIL

   Exemple : 45.5 CEIL  // Empile 46

COS                     n1 --- n2

   Empile le cosinus du symbole donn‚.

   Syntaxe : Sym COS

   Exemple : 45.5 COS

COSH                    n1 --- n2

   Empile le cosinus hyperbolique du symbole donn‚.

   Syntaxe : Sym COSH

   Exemple : 45.5 COSH

EXP                     n1 --- n2

   Empile e puissance Sym.

   Syntaxe : Sym EXP

   Exemple : 45 EXP

EXP-1                   n1 --- n2

   Empile e puissance Sym-1.

   Syntaxe : Sym EXP-1

   Exemple : 45 EXP-1

ABS                     n1 --- n2

   Empile la valeur absolue du symbole donn‚.

   Syntaxe : Sym ABS

   Exemple : -45.5 ABS  // Empile 45.5

NEGATE                  n1 --- -n1

   Rend le nombre empil‚ negatif, et empile le r‚sultat.

   Syntaxe : Sym NEGATE

   Exemple : 32 NEGATE  // Empile -32

FLOOR                   n1 --- n2

   Arrondi le symbole donn‚e au chiffre imm‚diatement inf‚rieur, et empile
   le r‚sultat.

   Syntaxe : Sym FLOOR

   Exemple : 45.5 FLOOR  // Empile 45

HYPOT                   n1 n2 --- n3

   Empile l'hypoth‚nuse du triange rectangle de cot‚s Sym1 et Sym2.

   Syntaxe : Sym1 Sym2 HYPOT

   Exemple : 10.5 9.5 HYPOT

LOG                     n1 --- n2

   Empile le logarithme naturel du symbole donn‚.

   Syntaxe : Sym LOG

   Exemple : 45.5 LOG

LOG1+                   n1 --- n2

   Empile le logarithme de 1+Sym.

   Syntaxe : Sym LOG1+

   Exemple : 45.5 LOG1+

LOG10                   n1 --- n2

   Empile le logarithme en base 10 du symbole donn‚.

   Syntaxe : Sym LOG10

   Exemple : 45.5 LOG10

POW                     n1 n2 --- n3

   Empile Sym1 puissance Sym2

   Syntaxe : Sym1 Sym2 POW

   Exemple : 2 32 POW

POW10                   n1 --- n2

   Empile 10 puissance Sym.

   Syntaxe : Sym POW10

   Exemple : 2 POW10

RND                     n1 --- n2

   Empile un nombre al‚atoire compris entre 0 et Sym-1.

   Syntaxe : Sym RND

   Exemple : 10 RND

RANDOMIZE               ---

   Initialise le g‚n‚rateur de nombres al‚atoires.

   Syntaxe : RANDOMIZE

   Exemple : : ALEA  // n1 --- n2
               RANDOMIZE
               RND
             ;

SIN                     n1 --- n2

   Empile le sinus du symbole donn‚.

   Syntaxe : Sym SIN

   Exemple : 45.5 SIN

SINH                    n1 --- n2

   Empile le sinus hyperbolique du symbole donn‚.

   Syntaxe : Sym SINH

   Exemple : 45.5 SINH

SQRT                    n1 --- n2

   Empile la racine carr‚e du symbole donn‚.

   Syntaxe : Sym SQRT

   Exemple : 2 SQRT

TAN                     n1 --- n2

   Empile la tangante du symbole donn‚.

   Syntaxe : Sym TAN

   Exemple : 45.5 TAN

TANH                    n1 --- n2

   Empile la tangante hyperbolique du symbole donn‚.

   Syntaxe : Sym TANH

   Exemple : 45.5 TANH

INT                     n1 --- n2

   Empile la partie entiŠre du symbole donn‚.

   Syntaxe : Sym INT

   Exemple : 45.5 INT  // Empile 45

LES CHAINES DE CARACTERES
-------------------------

STRCAT                  sd ss ---

   Concat‚nation de chaines.
   ConcatŠne la chaine Src … la chaine Dst.

   Syntaxe : Src Dst STRCAT

   Exemple : " SALUT " DEBUT :=
             " LES GARS" FIN :=
             FIN DEBUT STRCAT  // Debut = "SALUT LES GARS"

STRLEN                  str --- n

   Empile la longueur de la chaine donn‚e.

   Syntaxe : Str STRLEN

   Exemple : " COUCOU" STRLEN  // Empile 6

STRLWR                  str ---

   Converti les caractŠres de la chaine donn‚e en minuscules.

   Syntaxe : Str STRLWR

   Exemple : " SALUT" TOTO :=
             TOTO STRLWR   // Toto = "salut"

STRUPR                  str ---

   Converti les caractŠres de la chaine donn‚e en majuscules.

   Syntaxe : Str STRUPR

   Exemple : " salut" TOTO :=
             TOTO STRUPR   // Toto = "SALUT"

STRREV                  str ---

   Inverse les caractŠres de la chaine donn‚e.

   Syntaxe : Str STRREV

   Exemple : " SALUT" TOTO :=
             TOTO STRREV          // Toto = "TULAS"

AT                      s2 s1 --- n

   Recherche de sous-chaine.
   Empile la position de la sous-chaine Str2 dans la chaine Str1.
   La position commence … partir de 0.

   Syntaxe : Str1 Str2 AT

   Si Str2 est non trouv‚e dans Str1, empile -1.

   Exemple : " SALUT LES GARS" TOTO :=
             TOTO " ES" AT  // Empile 7
             TOTO " COU" AT  // Empile -1 

SUBSTR                  str pos lng --- str

   Extraction de sous-chaine.
   Extrait une sous-chaine de Str, … partir de la position Pos, sur
   une longueur Lon. La position est compt‚e … partir de 0.
   Empile la sous-chaine extraite.

   Syntaxe : Str Pos Lon SUBSTR

   Exemple : " SALUT LES GAR" TOTO :=
             TOTO 3 5 SUBSTR  // Empile "UT LE"

   Note : Si Pos est sup‚rieur … la longueur de la chaine, rien n'est
          extrait.
          Si Pos+Lon est sup‚rieur … la longueur de la chaine, Lon est
          ajust‚.

VAL                     str --- n

   Converti la chaine donn‚e en nombre, et empile le nombre obtenu.

   Syntaxe : Str VAL

   Exemple : " 3.14159" TOTO :=
             TOTO VAL  // Empile 3.14159

STR                     n --- str

   Converti le nombre donn‚ en une chaine de caractŠres, en respectant
   le format d'affichage courant (voir USING).

   Syntaxe : n STR

   Exemple : LOCAL NUMBER NUM1 := 345
                   CHAR CHIFFRE
             ...
             NUM1 STR CHIFFRE :=

RTRIM                   str --- str'

   EnlŠve les espace … droite de la chaine donn‚e.
   Empile la nouvelle chaine.

   Syntaxe : Str RTRIM

   Exemple : CHAR STR := " COUCOU    "
             ...
             STR RTRIM   // Empile "COUCOU"

LTRIM                   str --- str'

   EnlŠve les espace … gauche de la chaine donn‚e.
   Empile la nouvelle chaine.

   Syntaxe : Str LTRIM

   Exemple : CHAR STR := "     COUCOU"
             ...
             STR LTRIM   // Empile "COUCOU"

ALLTRIM                 str --- str'

   EnlŠve les espace … droite et gauche de la chaine donn‚e.
   Empile la nouvelle chaine.

   Syntaxe : Str ALLTRIM

   Exemple : CHAR STR := "     COUCOU   "
             ...
             STR ALLTRIM   // Empile"COUCOU"

ASC                     str --- n

   Converti le caractŠre donn‚ en un code ASCII.

   Syntaxe : Str ASC

   Exemple : CHAR CAR := " A"
             ...
             CAR ASC       // Empile 65

CHR                     n --- str

   Converti le nombre donn‚ en un caractŠre.

   Syntaxe : n CHR

   Exemple : 65 CHR       // Empile " A".

STRSPN                  s2 s1 --- n

   Empile VRAI si la chaine Str1 n'est compos‚e que des caractŠres
   de la chaine Str2, FAUX sinon.

   Syntaxe : Str1 Str2 STRSPN

   Exemple : " 125"
             " 0123456789" STRSPN
             IF
                " EST UN NOMBRE" PRINT
             ELSE
                " N'EST PAS UN NOMBRE" PRINT
             ENDIF

STRIN                   s2 s1 --- n

   Empile VRAI si la chaine Str1 contient un des caractŠres
   de la chaine Str2, FAUX sinon.

   Syntaxe : Str1 Str2 STRIN

   Exemple : " ENTREZ UNE LETTRE" PRINT
             INPUT
             " ABCDEFGHIJKLMNOPQRSTUVWXYZ" STRIN
             IF
                " EST UNE LETTRE" PRINT
             ELSE
                " N'EST PAS UNE LETTRE" PRINT
             ENDIF

STRTOK                  Tab delim chaine ---

   D‚coupe la chaine donn‚e en item s‚par‚s par le d‚limiteur donn‚, et
   stocke ceux-ci dans le tableau donn‚.

   Syntaxe : Chaine Delim Tab STRTOK

   Le tableau doit ˆtre du type caractŠre.
   Son ‚ventuel ancien contenu est supprim‚. Ses dimensions sont ‚ventuellement
   ajust‚es ( 1 ligne et n colonnes).

   Exemple : CHAR[] 5 5 CTAB
             CHAR CHAINE := "UN DEUX TROIS QUATRE CINQ"
             CHAR DELIM := " "
             ...
             CHAINE DELIM CTAB STRTOK
             ...
             CTAB ALEN            // Empile 1 5

ENCODE                  Src FmtDst FmtSrc --- Ch

   Encodage d'une chaine de caractŠres.

   Syntaxe : FmtSrc FmtDst Src ENCODE

   Fabrique une chaine de caractŠres en d‚placant les caractŠres de la chaine
   source Src dans la chaine destination. Les d‚placements sont d‚termin‚s par
   les formats des deux chaines, d‚finis par FmtSrc pour la chaine source, et
   par FmtDst pour la chaine destination.
   La chaine fabriqu‚e est empil‚e.

   Exemples : " 123" " 3 2 1" " ABC" ENCODE                   // Empile " C B A"
              " 123" " 1&2&3" " ABC" ENCODE                   // Empile " A&B&C"
              " 123456789A" " 789A4512" " 30-12/1990" ENCODE  // Empile " 19901230"
              " ABCDEFGH" " EF/GH/CD" " 19901230" ENCODE      // Empile "12/30/90"

ADIR                    Tab masque ---

   R‚cupŠre la liste des fichiers correspondants au masque donn‚, et stocke
   ceux-ci dans le tableau donn‚.

   Syntaxe : Masque Tab ADIR

   Le tableau doit ˆtre du type caractŠre.
   Son ‚ventuel ancien contenu est supprim‚. Ses dimensions sont ‚ventuellement
   ajust‚es ( n ligne et 4 colonnes).
   Masque est une chaine pouvant contenir les "jokers" du D.O.S.
   Les colonnes contiennent les informations suivantes:
   colonne 0 : nom du fichier (13 caractŠres maxi)
   colonne 1 : taille du fichier (sous forme de chaine de caractŠres)
   colonne 2 : date de derniŠre ‚criture, sous la forme "JJ/MM/AAA"
   colonne 3 : heure de derniŠre ‚criture, sous la forme "HH:MM:SS"
   Si aucun fichier ne correspond au masque donn‚, le tableau contiendra
   une seule ligne de 4 colonnes vides.

   Exemple : CHAR[] 5 5 CTAB
             ...
             " *.EXE" CTAB ADIR
             ...
             " \APPS\*.NPG" CTAB ADIR

STRTRAN                 Chaine OccDst OccSrc ---

   Remplace dans la chaine donn‚e, toutes les occurences de OccSrc par
   OccDst.

   Syntaxe : OccSrc OccDst Chaine STRTRAN

   Exemple : CHAR CHAINE := " COUCOU"
             ...
             " O" " HA" CHAINE STRTRAN
             CHAINE PRINT                // Affiche " CHAUCHAU"

LEFT                    Chaine Len --- NewCh

   Empile les Len caractŠres … gauche de la chaine donn‚e.

   Syntaxe : Chaine Len LEFT

   Si Len est plus grand que la longueur de la chaine, il est ajust‚.

   Exemple : LOCAL CHAR CHAINE := "BONJOUR"
             ...
             CHAINE 3 LEFT        // Empile "BON"
             ...
             CHAINE 25 LEFT       // Empile "BONJOUR"

RIGHT                   Chaine Len --- NewCh

   Empile les Len caractŠres … droite de la chaine donn‚e.

   Syntaxe : Chaine Len RIGHT

   Si Len est plus grand que la longueur de la chaine, il est ajust‚.

   Exemple : LOCAL CHAR CHAINE := "BONJOUR"
             ...
             CHAINE 4 RIGHT        // Empile "JOUR"
             ...
             CHAINE 25 RIGHT       // Empile "BONJOUR"

PADL                    Len Car Chaine --- NewCh

   ComplŠte la chaine donn‚e avec le caractŠre donn‚, jusqu'… ce qu'elle
   atteigne la longueur donn‚e. Le caractŠre est mis … gauche de la chaine.
   Empile la nouvelle chaine.

   Syntaxe : Chaine Car Len PADL

   Si la chaine originale est plus longue que Len, la nouvelle chaine
   contiendra Len caractŠre de Chaine, ‚quivalant … Chaine 0 Len SUBSTR.

   Exemples : LOCAL CHAINE := "BONJOUR"
              ...
              CHAINE "  " 10 PADL   // Empile "   BONJOUR"
              ...
              CHAINE "  " 5 PADL    // Empile "BONJO"

PADR                    Len Car Chaine --- NewCh

   ComplŠte la chaine donn‚e avec le caractŠre donn‚, jusqu'… ce qu'elle
   atteigne la longueur donn‚e. Le caractŠre est mis … droite de la chaine.
   Empile la nouvelle chaine.

   Syntaxe : Chaine Car Len PADR

   Si la chaine originale est plus longue que Len, la nouvelle chaine
   contiendra Len caractŠre de Chaine, ‚quivalant … Chaine 0 Len SUBSTR.

   Exemples : LOCAL CHAINE := "BONJOUR"
              ...
              CHAINE "  " 10 PADR   // Empile "BONJOUR   "
              ...
              CHAINE "  " 5 PADR    // Empile "BONJO"

PADC                    Len Car Chaine --- NewCh

   Centre la chaine donn‚e avec le caractŠre donn‚, jusqu'… ce qu'elle
   atteigne la longueur donn‚e. Le caractŠre est mis de part et d'autre
   de la chaine.
   Empile la nouvelle chaine.

   Syntaxe : Chaine Car Len PADC

   Si la chaine originale est plus longue que Len, la nouvelle chaine
   contiendra Len caractŠre de Chaine, ‚quivalant … Chaine 0 Len SUBSTR.

   Exemples : LOCAL CHAINE := "BONJOUR"
              ...
              CHAINE "  " 10 PADC   // Empile " BONJOUR  "
              ...
              CHAINE "  " 5 PADC    // Empile "BONJO"

STRINS                  Len Pos Dst Src --- Str

   Copie les <Len> caractŠres de la chaine <Src> dans la chaine <Dst>, …
   partir de la position <Pos>.

   Syntaxe : Src Dst Pos Len STRINS

   <Pos> est compt‚ … partir de 0.
   La nouvelle chaine est empil‚e.
   <Pos> et <Len> sont ajust‚s le cas ‚ch‚ant, conform‚ment aux longueurs
   des chaines (si <Pos> est sup‚rieur … la longueur de la chaine, il est mis
   … la longueur de la chaine destination, si <Len> est sup‚rieur … la longueur
   de la chaine, il est mis … la longueur de la chaine source).

   Exemples : LOCAL CHAINE1 := "BONJOUR"
                    CHAINE2 := " OU MAUVAIS "
              ...
              CHAINE2 CHAINE1 3 5 STRINS  // Empile "BON OU MJOUR"

STRDEL                  Len Pos Src --- Str

   Supprime les <Len> caractŠres de la chaine <Src>, … partir de la
   position <Pos>.

   Syntaxe : Src Pos Len STRDEL

   La nouvelle chaine est empil‚e.
   <Pos> est compt‚ … partir de 0.
   si <Pos> est hors limite, rien n'est supprim‚ et la chaine source est
   empil‚e telle quel.
   si <Len> est sup‚rieur … la longueur de la chaine, il est ajust‚.

   Exemples : LOCAL CHAINE1 := " OU MAUVAIS"
              ...
              CHAINE1 3 5 STRDEL  // Empile " OUAIS "

STRSET                  Car Len Pos Src --- Str

   Remplace les <Len> caractŠres de la chaine <Src> par le caractŠre <Car>,
   … partir de la position <Pos>.

   Syntaxe : Src Pos Len Car STRSET

   La nouvelle chaine est empil‚e.
   <Pos> est compt‚ … partir de 0.
   si <Pos> est hors limite, rien n'est remplac‚ et la chaine source est
   empil‚e telle quel.
   si <Len> est sup‚rieur … la longueur de la chaine, il est ajust‚.

   Exemples : LOCAL CHAINE1 := " OU MAUVAIS"
              ...
              CHAINE1 3 5 " ." STRSET  // Empile " OU.....AIS"

LES VARIABLES ET CONSTANTES
---------------------------

TRUE                    --- b

   Empile la valeur VRAI.

   Syntaxe : TRUE

   Exemple : PSEUDO IF TRUE ELSE FALSE ENDIF

FALSE                   --- b

   Empile la valeur FAUSSE.

   Syntaxe : FALSE

   Exemple : PSEUDO IF TRUE ELSE FALSE ENDIF

FKENVOI                 --- c

   Empile le code de la touche ENVOI.

   Syntaxe : FKENVOI

   Exemple : " appuyez sur ENVOI" print
             BEGIN
                wait
                FKEY
                FKENVOI ==
             UNTIL

FKRETOUR                --- c

   Empile le code de la touche RETOUR.

   Syntaxe : FKRETOUR

   Exemple : " appuyez sur RETOUR" print
             BEGIN
                wait
                FKEY
                FKRETOUR ==
             UNTIL

FKREPETITION            --- c

   Empile le code de la touche REPETITION.

   Syntaxe : FKREPETITION

   Exemple : " appuyez sur REPETITION" print
             BEGIN
                wait
                FKEY
                FKREPETITION ==
             UNTIL

FKGUIDE                 --- c

   Empile le code de la touche GUIDE.

   Syntaxe : FKGUIDE

   Exemple : " appuyez sur GUIDE" print
             wait
             FKEY
             FKGUIDE == IF AIDE THEN

FKANNULATION            --- c

   Empile le code de la touche ENVOI.

   Syntaxe : FKANNULATION

   Exemple : " appuyez sur ANNULATION" print
             BEGIN
                wait
                FKEY
                FKANNULATION ==
             UNTIL

FKSOMMAIRE              --- c

   Empile le code de la touche ENVOI.

   Syntaxe : FKSOMMAIRE

   Exemple : " appuyez sur SOMMAIRE" print
             BEGIN
                wait
                FKEY
                FKSOMMAIRE ==
             UNTIL

FKCORRECTION            --- c

   Empile le code de la touche CORRECTION.

   Syntaxe : FKCORRECTION

   Exemple : " appuyez sur CORRECTION" print
             BEGIN
                wait
                FKEY
                FKCORRECTION ==
             UNTIL

FKSUITE                 --- c

   Empile le code de la touche SUITE.

   Syntaxe : FKSUITE

   Exemple : " appuyez sur SUITE" print
             BEGIN
                wait
                FKEY
                FKSUITE ==
             UNTIL

BLACK                   --- n

   Empile le code de la couleur NOIRE.

   Syntaxe : BLACK

   Exemple : BLACK SETCOLOR

RED                     --- n

   Empile le code de la couleur ROUGE.

   Syntaxe : RED

   Exemple : RED SETCOLOR

GREEN                   --- n

   Empile le code de la couleur VERTE.

   Syntaxe : GREEN

   Exemple : GREEN SETCOLOR

YELLOW                  --- n

   Empile le code de la couleur JAUNE.

   Syntaxe : YELLOW

   Exemple : YELLOW SETCOLOR

BLUE                    --- n

   Empile le code de la couleur BLEUE.

   Syntaxe : BLUE

   Exemple : BLUE SETCOLOR

MAGENTA                 --- n

   Empile le code de la couleur MAGENTA.

   Syntaxe : MAGENTA

   Exemple : MAGENTA SETCOLOR

CYAN                    --- n

   Empile le code de la couleur CYAN.

   Syntaxe : CYAN

   Exemple : CYAN SETCOLOR

WHITE                   --- n

   Empile le code de la couleur BLANCHE.

   Syntaxe : WHITE

   Exemple : WHITE SETCOLOR

FSIMPLE                 --- n

   Empile le code de la simple taille.

   Syntaxe : FSIMPLE

   Exemple : FSIMPLE SETFONT

FDHEIGHT                --- n

   Empile le code de la double hauteur.

   Syntaxe : FDHEIGHT

   Exemple : FDHEIGHT SETFONT

FDWEIGHT                --- n

   Empile le code de la double largeur.

   Syntaxe : FDWEIGHT

   Exemple : FDWEIGHT SETFONT

FDSIZE                  --- n

   Empile le code de la double taille.

   Syntaxe : FDSIZE

   Exemple : FDSIZE SETFONT

TMODEVDT                --- n

   Empile le code du mode de fonctionnement Vid‚oTex.

   Syntaxe : TMODEVDT

   Exemple : GETTMODE TMODEVDT ==
             IF
                ...
             ENDIF

TMODEMIXTE              --- n

   Empile le code du mode de fonctionnement Mixte.

   Syntaxe : TMODEMIXTE

   Exemple : GETTMODE TMODEMIXTE ==
             IF
                ...
             ENDIF

   Rappel : Le mode mixte est le mode 80 colonnes des minitels, dans lequel
            les touches de fonctions (SUITE, RETOUR, ...) sont encores actives.

TMODETELEINFO           --- n

   Empile le code du mode de fonctionnement T‚l‚Informatique.

   Syntaxe : TMODETELEINFO

   Exemple : GETTMODE TMODETELEINFO ==
             IF
                ...
             ENDIF

   Rappel : Le Mode T‚l‚Informatique est le mode 80 colonnes, compatible avec
            Les terminaux de types ASCII (VTxxx).

GETTMODE                --- n

   Empile le mode du terminal du connect‚ courant.

   Syntaxe : GETTMODE

   Exemple : GETTMODE TMODETELEINFO ==
             IF
                ...
             ENDIF

FKEY                    --- c

   Empile le code (sous forme de caractŠre) de la touche de fonction
   renvoy‚e par le minit‚liste courant.

   Syntaxe : FKEY

   Exemple : " Appuyez sur SUITE pour continuer" print
             BEGIN
               WAIT   // Attend une action de l'utilisateur
               FKEY
               FKSUITE ==
             UNTIL

DATA                    --- s

   Empile les donn‚es re‡ues par le connect‚ courant.

   Syntaxe : DATA

   Exemple : " MENU.VTX" SENDPAGE
             BEGIN
                " Entrez votre choix" PRINT
                24 13 LOCATE
                INPUT
                DATA VAL 0 !=
             UNTIL

TIME                    --- s

   Empile l'heure courante du systŠme, sous forme de chaine de caractŠres
   au format "HH:MM:SS"

   Syntaxe : TIME

   Exemple : " IL EST " print TIME PRINT

TIMER                   --- n

   Empile l'heure courante du systŠme, en centiŠmes de secondes.

   Syntaxe : TIMER

   Exemple : : DIFFTIME
                TIMER
                ...
                TIMER -
             ;

DATE                    --- s

   Empile la date courante du systŠme, sous forme de chaine de caractŠres
   au format "JJ/MM/AAAA"

   Syntaxe : DATE

   Exemple : " Nous sommes le " print DATE print

CNXDATA                 --- s

   Empile la trame d'appel du connect‚ courant, sous forme de chaine
   de caractŠres.

   Syntaxe : CNXDATA

   Exemple : " Trame de CNX = " print CNXDATA print

   Note : Les connect‚s LOCAUX n'ont pas de trame de connexion.

DEPT                    --- s

   Empile le d‚partement d'appel (sous forme de chaine de caractŠre)
   du connect‚ courant.

   Syntaxe : DEPT

   Exemple : DEPT DPT :=

PAVI                    --- s

   Empile le Nø de  PAVI sous forme de chaine de caractŠres, du
   connect‚ courant.

   Syntaxe : PAVI

   Exemple : " PAVI : " print PAVI print

PALIER                  --- s

   Empile le palier ("82"=3614, ...) sous forme de chaine de caractŠre
   du connect‚ courant.

   Syntaxe : PALIER

   Exemple : " Palier : " print PALIER print

NCOMP                   --- s

   Empile le num‚ro compl‚mentaire du connect‚ courant, sous forme de chaine
   de caractŠre.

   Syntaxe : NCOMP

   Exemple : " Nø Comp : " print NCOMP print

APP                     --- s

   Empile le nom de l'application appel‚e par le connect‚ courant.

   Syntaxe : APP

   Exemple : " Bienvenue sur " print APP print

CNXDATE                 --- s

   Empile la date de connexion du connect‚ courant, sous forme de chaine
   de caractŠres au format "JJ/MM/AAAA".

   Syntaxe : CNXDATE

   Exemple : " Arriv‚ le " print CNXDATE print

CNXTIME                 --- s

   Empile l'heure de connexion du connect‚ courant, sous forme de chaine
   de caractŠres au format "HH:MM:SS".

   Syntaxe : CNXTIME

   Exemple : " Arriv‚ … " print CNXTIME PRINT

MTYPE                   --- n

   Empile le type de minitel du connect‚ courant, sous forme de code
   num‚rique, en utilisant la correspondance suivante :

   62h : Minitel M1.
   63h : Minitel M1.
   72h : Minitel M1.
   73h : Minitel M1 couleur.
   64h : Minitel M10.
   66h : Minitel M10.
   75h : Minitel M1b.
   77h : Minitel M10b.
   76h : Minitel M2.
   7Ah : Minitel M12.
   79h : Minitel M5 (portable).
   80h : Minitel Rapide/Photo.

   Syntaxe : MTYPE

   Exemple : MTYPE 76h !=
             IF
                " Il vous faut un minitel 2" LINE0
             ENDIF

NUMCV                   --- n

   Empile le num‚ro de cv du connect‚ courant.

   Syntaxe : NUMCV

   Exemple : : INFO
                " Vous ˆtes sur la voie " print
                NUMCV print
                ...
             ;

SRVLAUNCHDATE           --- s

   Empile la date de lancement du serveur, sous forme de chaine
   de caractŠres au format "JJ/MM/AAAA".

   Syntaxe : SRVLAUNCHDATE

   Exemple : " Serveur lanc‚ le " print SRVLAUNCHDATE print

SRVLAUNCHTIME           --- s

   Empile l'heure de lancement du serveur, sous forme de chaine
   de caractŠres au format "HH:MM:SS".

   Syntaxe : SRVLAUNCHTIME

   Exemple : " Serveur lanc‚ … " print SRVLAUNCHTIME PRINT

SRVMEMAVAIL             --- n

   Empile la m‚moire disponible sur le serveur, en octets.

   Syntaxe : SRVMEMAVAIL

   Exemple : " Il reste " print SRVMEMAVAIL print "  octets"

SRVCHARGE               --- n

   Empile la charge actuelle du serveur, en pourcentage.
   La charge est un ratio calcul‚ entre le nombre de connect‚s total courant
   et le nombre de connect‚s maximum du serveur.

   Syntaxe : SRVCHARGE

   Exemple : " Charge actuelle : " print SRVCHARGE print " %"

SRVCHARGEMAX            --- n

   Empile la charge maximum, pour la journ‚e courante, du serveur,
   en pourcentage.
   La charge est un ratio calcul‚ entre le nombre de connect‚s total courant
   et le nombre de connect‚s maximum du serveur.

   Syntaxe : SRVCHARGEMAX

   Exemple : " Charge maxi : " print SRVCHARGEMAX print " %"

SRVNBCNX                --- n

   Empile le nombre total de connect‚s actuels sur le serveur.

   Syntaxe : SRVNBCNX

   Exemple : " Il y a " print SRVNBCNX "  connect‚s"

SRVMAXCNX               --- n

   Empile le nombre total maximum de connect‚s, pour la journ‚e courante,
   sur le serveur.

   Syntaxe : SRVMAXCNX

   Exemple : " Il y a eu " print SRVMAXCNX "  connect‚s maximum"

SRVSTOPTIME             --- s

   Empile l'heure d'arret du serveur, sous forme de chaine
   de caractŠres au format "HH:MM:SS".

   Syntaxe : SRVSTOPTIME

   Exemple : " Arret du serveur … " print SRVSTOPTIME PRINT

   Note : les secondes sont toujours … z‚ro.

LES BASES DE DONNEES
--------------------

REMARQUE RELATIVES AUX BASES DE DONNEES:
----------------------------------------
Le chemin utilis‚ pour acc‚der aux bases de donn‚es et fichiers annexes
est (dans l'ordre) :
   - Le chemin d‚fini par la directive #PATHDBF, s'il existe
   sinon,
   - Le chemin d‚fini par la directive #PATH, s'il existe
   sinon, le chemin courant est pris.

DBOPEN                  s --- b

   Ouverture d'une base de donn‚es et des fichiers (index, m‚mo) associ‚s.

   Syntaxe : NomBase DBOPEN

   Ouvre la base NomBase, ainsi que l'‚ventuel index de production (NomBase.CDX)
   associ‚, si celui-ci existe. Le fichier m‚mo (NomBase.FPT) ‚ventuel est aussi
   ouvert.
   Si un index est ouvert, la premiŠre clef est s‚lectionn‚e.

   La base ouverte devient la base courante.Le pointeur d'enregistrement est plac‚
   au d‚but de celle-ci.

   Renvoi VRAI si tout c'est bien pass‚, FAUX sinon.

   Exemple : " BAL" DBOPEN  // BAL.DBF est ouvert
                            // ainsi que BAL.CDX, et BAL.FPT si ils existent.
                            // La 1Šre clef de BAL.CDX est s‚lectionn‚e.
             IF
                ...
             ELSE
                " Boites Aux Lettres indisponibles" LINE0
             ENDIF

DBCLOSE                 s ---

   Ferme une base de donn‚es, et tous ses fichiers associ‚s.

   Syntaxe : NomBase DBCLOSE

   Exemple : " BAL" DBCLOSE

   IMPORTANT : Si NomBase est la base courante, il faudra en s‚lectionner une
               nouvelle (voir DBSELECT).

DBCLOSEALL              ---

   Ferme toutes les bases de donn‚es, et tous les fichiers associ‚s.

   Syntaxe : DBCLOSEALL

   Exemple : DBCLOSEALL

DBAPPENDBLANK           ---

   Ajoute un enregistrement vide … la base de donn‚es courante, et en fait
   l'enregistrement courant.

   Syntaxe : DBAPPENDBLANK

   Exemple : DBAPPENDBLANK

DBBOF                   --- b

   Renvoie VRAI si on est au d‚but de la base de donn‚es courante.

   Syntaxe : DBBOF

   Exemple : BEGIN
                DBBOF !
             WHILE
                ...
                -1 DBSKIP  // On remonte d'un enreg.
             REPEAT

DBBOTTOM                ---

   Se place … la fin de la base de donn‚es courante.

   Syntaxe : DBBOTTOM

   Exemple : " BAL" DBOPEN
             IF
                DBBOTTOM
             ENDIF

DBSELECT                s ---

   S‚lectionne une base de donn‚es parmis celles ouvertes, et en fait la
   base de donn‚es courante.

   Syntaxe : NomAlias DBSELECT

   NomAlias est l'alias de la base … s‚lectionner (le nom de la base
   de donn‚es).

   Exemple : " ..\DBF\BAL" DBOPEN
             " ..\DBF\MESSAGES" DBOPEN  // DerniŠre ouverte, base courante.
             " BAL" DBSELECT            // "BAL" devient la base courante.

DBSELECTED              --- s

   Empile le nom (alias) de la base de donn‚es courante.

   Syntaxe : DBSELECTED

   Exemple : : INTRO
                DBSELECTED
                " MODULES\QREP\QREP" DBOPEN
                IF
                   ...
                   " QREP" DBCLOSE
                ENDIF
                DBSELECT  // On res‚lectionne l'ancienne base.
             ;

DBSETALIAS              Alias NomBase ---

   Change l'alias d'une base de donn‚es.

   Syntaxe : NomBase Alias DBSETALIAS

   Par d‚faut, l'alias d'une base de donn‚e est le nom du fichier.

   Exemple : " BAL" DBOPEN
             IF
                " BAL" " MESBAL" DBSETALIAS
                ...
                " MESBAL" DBSELECT
                ...
                " MESBAL" DBCLOSE
             ENDIF

DBDELETE                ---

   Marque l'enregistrement courant de la base de donn‚es courante comme effac‚.

   Syntaxe : DBDELETE

   Exemple : " Confirmez-vous la destruction (O/N) ?" PRINT
             WAIT
             DATA STRUPR " O" ==
             IF
                DBDELETE
             ENDIF

DBDELETED               --- b

   Renvoie VRAI si l'enregistrement courant de la base de donn‚es courante
   est marqu‚ comme effac‚.

   Syntaxe : DBDELETED

   Exemple : DBDELETED
             IF
                DBRECALL
             ENDIF

DBEOF                   --- b

   Renvoie VRAI si on est … la fin de la base de donn‚es courante.

   Syntaxe : DBEOF

   Exemple : BEGIN
                DBEOF !
             WHILE
                ...
                1 DBSKIP  // On descend d'un enreg.
             REPEAT

DBCOMMIT                ---

   Met … jour (physiquement, sur le disque) la base de donn‚es courante,
   ainsi que les fichiers associ‚s (index et m‚mo).

   Syntaxe : DBCOMMIT

   Exemple : DBAPPENDBLANK
             ...
             DBCOMMIT

DBCOMMITALL             ---

   Met … jour (physiquement, sur le disque) toutes les bases de donn‚es
   du connect‚ courant, ainsi que les fichiers associ‚s (index et m‚mo).

   Syntaxe : DBCOMMITALL

   Exemple : DBAPPENDBLANK
             ...
             DBCOMMITALL

DBGO                    n ---

   Se place sur l'enregistrement donn‚ de la base courante.

   Syntaxe : Num DBGO

   Exemple : " BAL" DBOPEN
             IF
                5 DBGO
             ENDIF

DBLOCK                  ---

   Verouille l'enregistrement courant de la base de donn‚es courante.

   Syntaxe : DBLOCK

   Exemple : DBAPPENDBLANK
             ...
             DBLOCK
             ...
             DBUNLOCK

DBLOCKED                --- b

   Renvoie VRAI si l'enregistrement courant de la base de donn‚es courante
   est verouill‚.

   Syntaxe : DBLOCKED

   Exemple : 5 DBGO
             DBLOCKED IF DBUNLOCK ENDIF
             ...

DBFLOCK                 ---

   Verouille la base de donn‚es courante, ainsi que les fichiers index et
   m‚mo associ‚s.

   Syntaxe : DBFLOCK

   Exemple : : PURGEBAL
                " BAL" DBOPEN
                DBFLOCK
                ...
                DBUNLOCK
             ;

DBFLOCKED               --- b

   Renvoie VRAI si la base courante est verouill‚e.

   Syntaxe : DBFLOCKED

   Exemple : DBFLOCKED
             IF
                " Base indisponible" LINE0
             ENDIF

DBINDEX                 --- s

   Empile le nom de l'index courant, pour la base de donn‚es courante du
   connect‚.

   Syntaxe : DBINDEX

   Exemple : " BAL" DBOPEN
             IF
                " INDEX COURANT =" PRINT
                DBINDEX PRINT
             ENDIF

DBKEY                   --- s

   Empile l'expression DBASE de la clef d'index courante, pour la base
   de donn‚es courante du connect‚.

   Syntaxe : DBKEY

   L'expression est empil‚e sour forme de chaine de caractŠres.

   Exemple : " BAL" DBOPEN
             IF
                " CLEF COURANTE =" PRINT
                DBKEY PRINT
             ENDIF

DBRECALL                ---

   EnlŠve, si elle existe, la marque d'effacement de l'enregistrement
   courant de la base de donn‚es courante.

   Syntaxe : DBRECALL

   Exemple : 3 DBGO
             DBDELETED IF DBRECALL ENDIF

DBRECCOUNT              --- n

   Renvoie le nombre d'enregistrements de la base courante.

   Syntaxe : DBRECCOUNT

   Exemple : " BAL" DBOPEN
             " Il y a " PRINT
             DBRECCOUNT PRINT
             " inscrits" PRINT

DBRECNO                 --- n

   Renvoie le num‚ro de l'enregistrement courant de la base de donn‚es courante.

   Syntaxe : DBRECNO

   Exemple : " BAL" DBOPEN
             PSEUDO DBSEEK
             IF
                " Vous ˆtes le nø " PRINT
                DBRECNO PRINT CR
             ENDIF

DBSEEK                  s --- b

   Recherche d'une clef dans la base, en utilisant l'index courant.
   Renvoi VRAI si la clef est trouv‚e, FAUX sinon.
   Si la clef est trouv‚e, l'enregistrement correspondant devient
   l'enregistrement courant.

   Syntaxe : Clef DBSEEK

   Exemple : " Entrez votre nom " PRINT
             INPUT
             " BAL" DBSELECT
             DBSEEK
             IF
                ...
             ELSE
                " Vous n'ˆtes pas certifi‚" LINE0
             ENDIF

   Note : La clef ‚tant donn‚e sous forme d'une chaine de caractŠres,
          si l'index est de type DATE, la clef devra se pr‚senter sous
          la forme "AAAAMMJJ" (exemple : "19942004"),
          si l'index est de type NUMERIQUE, la clef devra se pr‚senter sous
          la forme "XX.XX" (exemples: "365.25", "33", "789.456").

DBSKIP                  n ---

   D‚place le pointeur d'enregistrement de la base de donn‚es courante,
   de Nb enregistrements.

   Syntaxe : Nb DBSKIP

   Exemple : " BAL" DBOPEN
             IF
                DBTOP
                BEGIN
                   DBEOF !
                WHILE
                   ...
                   1 DBSKIP
                REPEAT
             ENDIF

   Note : Nb peut ˆtre n‚gatif.

DBSETINDEX              s ---

   S‚lectionne un index parmis ceux pr‚sents dans le fichier de production
   (NomBase.CDX) de la base courante.
   Si l'index donn‚e n'existe pas ou est invalide, une erreur d'ex‚cution est
   g‚n‚r‚e.
   Pour s‚lectionner l'ordre "naturel" (nø d'enregistrement), empilez un
   index vide.

   Syntaxe : NomIndex DBSETINDEX

   Exemple : " BAL" DBOPEN  // en supposant que "AGE" soit un des index
             " AGE" DBSETINDEX
             "  " DBSETINDEX // s‚lection de l'ordre naturel

   Rappel : il peut y avoir jusqu'… 47 index dans un fichier de production
            (NomBase.CDX).

DBTOP                   ---

   Se place au d‚but de la base courante.

   Syntaxe : DBTOP

   Exemple : " BAL" DBOPEN
             IF
                DBTOP
                ...
             ENDIF

DBUNLOCK                ---

   D‚verouille tous les enregistrements verouill‚s de la base courante.

   Syntaxe : DBUNLOCK

   Exemple : DBAPPENDBLANK
             ...
             DBLOCK
             ...
             DBUNLOCK

DBUNLOCKALL             ---

   D‚verouille toutes les bases du connect‚ courant.

   Syntaxe : DBUNLOCKALL

   Exemple : " BAL" DBSELECT
              DBAPPENDBLANK
             ...
             DBLOCK
             ...
             " MESSAGES" DBSELECT
              DBAPPENDBLANK
             ...
             DBLOCK
             ...
             DBUNLOCKALL

DBREPLACE               ch val ---

   Stocke la valeur donn‚e dans le champ donn‚ de la base courante.

   Syntaxe : Valeur NomChamp DBREPLACE

   Exemple : " Entrez votre nom " PRINT
             INPUT
             " BAL" DBSELECT
             DBAPPENDBLANK
             " NOM" DBREPLACE

   Note : Pour les champs de type caractŠre, la valeur … stocker doit ˆtre
          une chaine (!).
          Pour les champs de type date, la valeur … stocker peut ˆtre :
             - de type chaine, auquel cas elle doit avoir le format
               "AAAAMMJJ".
               Exemple : " 19943006" " DATEJOUR" DBREPLACE
             - de type num‚rique, auquel cas elle doit repr‚senter une date
               en jour julien.
               Exemple : 2345635 " DATEJOUR" DBREPLACE
          Pour les champs de type logique, la valeur … stocker peut ˆtre :
             - de type caractŠre (chaine de longueur 1), auquel cas elle 
               doit contenir un des caractŠres suivants :
               "Y","y","N","n","T","t","F","f"
             - de type num‚rique, auquel cas elle doit contenir soit 0 (FAUX),
               soit 1 (VRAI)
               Exemple : TRUE " MARIE" DBREPLACE
                         " F" " CELIBAT" DBREPLACE
          Pour les champs de type m‚mo, la valeur … stocker doit ˆtre
          une chaine (de longueur quelconque).
          Pour les champs num‚riques, la valeur … stocker doit ˆtre un
          nombre (!)

DBFIELD                 ch --- s

   Empile le contenu du champ donn‚ de la base de donn‚es courante.

   Syntaxe : NomChamp DBFIELD

   Exemple : " BAL" DBOPEN
             PSEUDO DBSEEK
             IF
                " DATDERACC" DBFIELD
                " Dernier accŠs le " PRINT PRINT CR
             THEN

   Note : Pour les champs de type caractŠre, une chaine est empil‚e.
          Pour les champs de type date, une chaine au format "AAAAMMJJ" est
          empil‚e.
          Pour les champs de type logique, TRUE ou FALSE est empil‚, en
          fonction de la valeur du champ.
          Pour les champs de type m‚mo, une chaine est empil‚e.
          Pour les champs de type num‚rique, un nombre est empil‚.

DBFIELDTYPE             ch --- s

   Empile le type du champ donn‚ de la base de donn‚es courante, sous forme
   de chaine de caractŠre.

   Syntaxe : NomChamp DBFIELDTYPE

   Le type empil‚ peut ˆtre un des suivants :
   - "C" : Champ de type caractŠre
   - "D" : Champ de type date
   - "L" : Champ de type logique
   - "M" : Champ de type m‚mo
   - "N" : Champ de type num‚rique

   Exemple : " BAL" DBOPEN
             IF
                " PSEUDO" DBFIELDTYPE " C" !=
                IF
                   " STRUCTURE DES BAL MODIFIEE" LINE0
                ENDIF
             ENDIF

DBFIELDLEN              ch --- n

   Empile la longueur du champ donn‚ de la base de donn‚es courante.

   Syntaxe : NomChamp DBFIELDLEN

   Exemple : " BAL" DBOPEN
             IF
                " PSEUDO" DBFIELDLEN
                ...
             ENDIF

DBFIELDCOUNT            --- n

   Empile le nombre de champs de la base de donn‚es courante.

   Syntaxe : DBFIELDCOUNT

   Exemple : " BAL" DBOPEN
             IF
                DBFIELDCOUNT 5 <
                IF
                   " STRUCTURE DES BALS MODIFIEES" LINE0
                ENDIF
             ENDIF

DBFIELDLENDEC           ch --- n

   Empile le nombre de d‚cimales du champ donn‚ de la base de donn‚es courante.

   Syntaxe : NomChamp DBFIELDLENDEC

   Exemple : " BAL" DBOPEN
             IF
                " AGE" DBFIELDLENDEC
                ...
             ENDIF

DBNUMFIELD->NAME        n --- s

   Empile la nom du champ de la base de donn‚es courante, correspondant au
   num‚ro donn‚.

   Syntaxe : Num DBNUMFIELD->NAME

   Num doit ˆtre compris entre 1 et DBFIELDCOUNT.

   Exemple : " BAL" DBOPEN
             IF
                DBFIELDCOUNT 0
                DO
                   I 1 + DBNUMFIELD->NAME PRINT CR
                LOOP
             ENDIF

TRAITEMENT DES ERREURS D'EXECUTION
----------------------------------

DBERROR                 --- n

   Empile le code d'erreur relatif aux manipulations des bases
   de donn‚es (fonction DBxx).

   Syntaxe : DBERROR

   Empile le code d'erreur de la derniŠre fonction de manipulation
   de base de donn‚es utilis‚e. 0 signifie qu'aucune erreur n'est
   survenue.

   Exemple : " BAL" DBCLOSE
             DBERROR
             IF
                // Traitement de l'erreur
             THEN

ERROR?                  --- b

   Empile VRAI si une erruer d'ex‚cution est survenue.

   Syntaxe : ERROR?

   En fontion du comportement choisi (voir #LIBONERROR), le programme
   peut ˆtre ammen‚ … tester une condition d'erreur (si #LIBONERROR est
   … OFF). ERROR? permet de le faire.

   Exemple : : TEST
                ...
                ERROR?
                IF
                   // Traitement de l'erreur.
                ELSE
                   ...
                ENDIF
             ;

ERRORCODE               --- n

   Empile le code de la derniŠre erreur d'ex‚cution survenue.

   Syntaxe : ERRORCODE

   Permet un traitement fin des erreurs d'ex‚cution.

   ERRORCODE peut empiler une des valeurs suivante:

       0 : Pile de donn‚es vide
       1 : Pile de retour vide
       2 : Pile de donn‚es pleine
       3 : Pile de retour pleine
       4 : Type incompatible
       5 : Indice de tableau hors limite
       6 : Donn‚e non initialis‚e
       7 : Impossible d'ouvrir le fichier
       8 : Base d‚j… ouverte
       9 : Impossible d'ouvrir la base
      10 : Impossible de fermer la base
      11 : Impossible de fermer les bases
      12 : Pas de base courante
      13 : Impossible d'ajouter un enregistrement vide
      14 : La base n'est pas ouverte
      15 : Nom de champ incorrect
      16 : Date incorrecte
      17 : L'op‚rande destination ne peut ˆtre un lit‚ral
      18 : Division par z‚ro
      19 : Format d'affichage non valide

   Exemple : : TEST
                ...
                ERROR?
                IF
                   // Traitement de l'erreur.
                   ERRORCODE
                   CASE
                      0 OF
                           ...
                        ENDOF
                      ...
                   ENDCASE
                ELSE
                   ...
                ENDIF
             ;

    Note : En ce qui concerne es erreurs relatives aux bases
           de donn‚es (8 … 16), DBERROR permet de r‚cup‚rer le
           code d'erreur.

LES DIRECTIVES DE COMPILATION
-----------------------------

Les directives de compilation permettent de modifier les variables systŠmes
d'une application.
Elles ne doivent pas se trouver dans une d‚finition de proc‚dure.
Elles peuvent se situer n'importe ou dans le source.

#STACKSIZE

   Param‚trage de la taille des piles.

   Syntaxe : #STACKSIZE Nb

   Permet de limiter la taille des piles utilis‚es par les connect‚s de
   l'application en cours de compilation … Nb Elements.
   Quand la pile donn‚es, ou la pile de retour (qui est utilis‚e pour
   stocker en interne les adresses de retour des appels de proc‚dures)
   atteignent la valeur donn‚e, une erreur d'ex‚cution "Pile ... pleine" est
   g‚n‚r‚e.
   Cela permet, entre autre, de limiter l'utilisation des resources m‚moires
   dans certaines applications, ou de pr‚venir les risques de boucles
   infinies.

   Exemple : #STACKSIZE 3    // Seuls 3 symboles (ou appels) sont empilables.
             ...

             : PROC1
                ...
             ;
             : PROC2
                ...
                PROC1        // G‚nŠre une erreur "Pile de retour pleine".
             ;
             : PROC3
                ...
                PROC2
             ;
             : PROC4
                ...
               PROC3
             ;
             ...
             : MAIN
                1 2 3 4      // G‚nŠre une erreur "Pile de donn‚es pleine".
                ...
                PROC4
             ;

#NAME

   Changement du nom de l'application en cours de compilation.

   Syntaxe : #NAME = NomApp

   Permet de renommer l'application courante.
   Si NomApp est le nom d'une application existante, une erreur de compilation
   est g‚n‚r‚e.
   Seuls les 10 premiers caractŠres de NomApp sont pris.

   Exemple : #NAME = BAL

   Rappel : le nom par d‚faut d'une application est celui du fichier
            charg‚ par la commande LOAD.

#NUMCOMP

   D‚finition du num‚ro compl‚mentaire de l'application en cours de
   compilation.

   Syntaxe : #NUMCOMP = XX

   Permet de d‚finir le num‚ro compl‚mentaire (aussi appel‚ sous-adresse)
   de l'application courante.
   Seuls les num‚ros compris entre 1 et 99 sont autoris‚s.
   Toute autre valeur provoque une erreur de compilation.

   Exemple : #NUMCOMP = 55

#PATH

   D‚finition du r‚pertoire principal de l'application.

   Syntaxe : #PATH = Chemin

   Permet de d‚finir le r‚pertoire principal de l'application.

   Exemple : // Application TOTO.NPG
             ...
             #PATH = L:\APP\TOTO
             ...

   Note : Si aucun chemin n'est sp‚cifi‚ par une directive #PATH, le chemin
          courant est pris.

#PATHDBF

   D‚finition du r‚pertoire des bases de donn‚es et des index associ‚s
   de l'application.

   Syntaxe : #PATHDBF = Chemin

   Permet de d‚finir le r‚pertoire des bases de donn‚es et des fichiers index
   associ‚s. Le r‚pertoire donn‚ sera utilis‚ par les fonctions de manipulation
   de bases de donn‚es (DBOPEN, DBSELECT, DBSETINDEX, ...).

   Exemple : // Application TOTO.NPG
             ...
             #PATHDBF = L:\APP\TOTO\BASES
             ...

   Note : Si aucun chemin n'est sp‚cifi‚ par une directive #PATHDBF, le chemin
          ‚ventuellement d‚fini par la directive #PATH est pris, sinon c'est le
          chemin courant qui est pris.

#PATHVTX


   D‚finition du r‚pertoire des pages vid‚otex de l'application.

   Syntaxe : #PATHVTX = Chemin

   Permet de d‚finir le r‚pertoire des pages vid‚otex.
   Le r‚pertoire donn‚ sera utilis‚ par les fonctions de manipulation
   des pages vid‚otex (SENDPAGE, ...).

   Exemple : // Application TOTO.NPG
             ...
             #PATHVTX = L:\APP\TOTO\PAGES
             ...

   Note : Si aucun chemin n'est sp‚cifi‚ par une directive #PATHVTX, le chemin
          ‚ventuellement d‚fini par la directive #PATH est pris, sinon c'est le
          chemin courant qui est pris.

#LIBONERROR

   Permet de param‚trer le comportement de l'application courante en cas
   d'erreur d'ex‚cution.

   Syntaxe : #LIBONERROR = ON | OFF

   Avec ON, toute erreur d'ex‚cution aura pour cons‚quence la
   d‚connexion imm‚diate du connect‚ responsable de l'erreur.
   Avec OFF, le code de l'application continuera a s'ex‚cuter,
   il faudra alors prendre en consid‚ration le fait qu'une erreur
   s'est produite.

   Rappel : Par d‚faut, LIBONERROR est … ON.

#CONFCNX

   Permet de param‚trer la confirmation ou non des appels entrants sur le
   ou les flux X25 du serveur.

   Syntaxe : #CONFCNX = ON | OFF

   Avec ON, les appels entrants sont confirm‚s par le serveur.
   Avec OFF, les appels entrants ne sont pas confirm‚s par le serveur.

   Rappel : Par d‚faut, CONFCNX est … ON.

#WARNING

   Permet de param‚trer l'affichage de messages d'avertissements … la
   compilation.

   Syntaxe : #WARNING = ON | OFF

   Avec ON, N‚oServ affiche des informations suppl‚mentaires … la compilation
   d'une application (proc‚dure et variable non utilis‚es, ...).

   Rappel : Par d‚faut, WARNING est … OFF.

#ECHO

   Permet de param‚trer l'affichage des lignes du programme en cours de
   compilation.

   Syntaxe : #ECHO = ON | OFF

   Avec ON, N‚oServ affiche chaque ligne du source courant en cours de
   compilation. La ligne est affich‚e avant sa compilation.

   Rappel : Par d‚faut, ECHO est … OFF.

#DBAUTOCOMMIT

   Permet d'activer le raffraichissement (commit) automatique des bases
   de donn‚es de l'application courante.

   Syntaxe : #DBAUTOCOMMIT = n

   n est la p‚riode de raffraichissement des bases, en minutes.
   Les base sont raffraichi pour chaque connect‚ de l'application, ainsi
   que pour les ‚ventuelles tƒches de fond et ONLIB.

   Exemple : #DBAUTOCOMMIT = 10  // Raffraichissement toutes les 10mn.

   Rappel : Par d‚faut, il n'y a pas de raffraichissement automatique des
            bases de donn‚es des applications.

#ANTICIPATION

   Permet de param‚trer l'anticipation de l'application courante.

   Syntaxe : #ANTICIPATION = ON | OFF

   Avec ON, … la r‚ception d'un paquet, le buffer de sortie du cv
   con‡ern‚ est vid‚. Les prochaines informations … envoyer seront
   donc trait‚es plus rapidement.

   Rappel : Par d‚faut, ANTICIPATION est … OFF.

MANIPULATION DES TABLEAUX
-------------------------

ALEN                    Tab --- MaxLig MaxCol

   Empile les dimensions maximum d'un tableau.

   Syntaxe : Tab ALEN

   Empile les dimensions (nombre de lignes et nombre de colonnes) du tableau
   donn‚.

   Exemple : LOCAL NUMBER[] 8 8 DAMIER
             ...
             DAMIER ALEN   // Empile 8 8

AFILL                   Val Tab ---

   Remplissage d'un tableau avec une valeur.

   Syntaxe : Val Tab AFILL

   Remplis le tableau Tab avec la valeur Val.
   Val doit ˆtre du mˆme type que le tableau.

   Exemple : LOCAL NUMBER[] 8 8 DAMIER
             ...
             : RAZ
                0 DAMIER AFILL
             ;

ASEARCH                 Val Tab --- Lig Col Flag

   Recherche d'une valeur dans un tableau.

   Syntaxe : Val Tab ASEARCH

   Recherche la valeur donn‚e dans le tableau donn‚.
   Empile TRUE si la valeur est trouv‚e, ainsi que sa position dans le
   tableau.
   Empile FALSE si la valeur n'est pas trouv‚e. Dans ce cas, la position
   empil‚e est invalide.

   Exemple : LOCAL NUMBER[] 8 8 DAMIER
             ...
             : CHERCHE1
                1 DAMIER ASEARCH
                IF
                   " TROUVE EN " PRINT PRINT PRINT
                ELSE
                   DROP DROP
                ENDIF
             ;

AINS                    Tab ---

   Ajoute une ligne … la fin du tableau donn‚.

   Syntaxe : Tab AINS

   Une ligne (vide) est ajout‚e … la fin du tableau.
   Le nombre de lignes est ajust‚.

   Exemple : CHAR[] 8 8 ctab
             ...
             CTAB ALEN        // Empile 8 8
             ...
             CTAB AINS
             ...
             CTAB ALEN        // Empile 9 8

ADEL                    Tab ---

   Supprime la derniŠre ligne du tableau donn‚.

   Syntaxe : Tab ADEL

   La derniŠre ligne du tableau est supprim‚e.
   Le nombre de lignes est ajust‚.

   Exemple : CHAR[] 8 8 ctab
             ...
             CTAB ALEN        // Empile 8 8
             ...
             CTAB ADEL
             ...
             CTAB ALEN        // Empile 7 8

ACOPY                   TabDst TabSrc ---

   Copie d'un tableau dans un autre.

   Syntaxe : TabSrc TabDst ACOPY

   Le contenu du tableau TabSrc est copi‚ dans TabDst.
   Les tableaux doivent ˆtre du mˆme type.

   Les tableaux peuvent avoir des tailles diff‚rentes, auquel cas
   c'est la taille du plus petit qui est prise en compte. Les ‚ventuels
   ‚l‚ments restants du tableaux destination ne sont pas modifi‚s.

   Exemple : CHAR[] 8 8 TAB1
             CHAR[] 5 5 TAB2
             ...
             TAB2 TAB1 ACOPY   // Ne copie que les 5x5 ‚l‚ments de TAB2
                               // dans TAB1

ACLONE                  TabDst TabSrc ---

   Rend le tableau TabDst identique (en taille et en contenu) au
   tableau TabSrc.

   Syntaxe : TabSrc TabDst ACLONE

   Les tableaux doivent ˆtre du mˆme type.
   Le pr‚c‚dent contenu de TabDst est supprim‚, puis TabSrc est
   copi‚ int‚gralement dans TabDst. Les dimensions de TabDst sont
   ‚ventuellement ajust‚es.

   Exemple : CHAR[] 8 8 TAB1
             CHAR[] 5 5 TAB2
             ...
             TAB1 ALEN           // Empile 8 8
             ...
             TAB2 TAB1 ACCLONE
             ...
             TAB1 ALEN           // Empile 5 5

MANIPULATION DES TACHES
-----------------------

SETLOCALTASK            ---

   Activation d'une tƒche locale au connect‚ courant.

   Syntaxe : SETLOCALTASK NomProc

   NomProc est le nom de la proc‚dure qui doit s'ex‚cuter en tƒche de fond.

   Exemple : : BACKGROUND
                BEGIN
                   TIMER 10 % 0 ==
                   IF
                      10 1 LOCATE TIME PRINT
                   ENDIF
                AGAIN
             ;
             ...
             : MAIN
                ...
                SETLOCALTASK BACKGROUND
                ...
             ;

   NOTE : Il ne peut y avoir qu'une seule tƒche locale par connect‚.
          Si une tƒche est d‚j… active, elle est d‚sactiv‚e avant la mise en
          place de la nouvelle tƒche.

          Une tƒche locale ‚tant "li‚e" … un connect‚, elle partage les
          donn‚es de celui-ci (variables locales, buffers des flux entrant
          et sortant, ...), … l'exception de la pile de donn‚e (la tƒche de
          fond possŠde sa propre pile), ainsi que les bases de donn‚es
          (la tƒche de fond possŠde ses propres bases de donn‚es).

          Toute modification d'une information partag‚e est propag‚e au
          connect‚ "li‚" … la tƒche (accŠs … une nouvelle variable locale,
          ...).

          Une erreur d'ex‚cution provoque la d‚sactivation de la tƒche de
          fond.

          La d‚connexion du cv principal provoque la d‚sactivation de sa
          tƒche de fond.

DELETELOCALTASK         ---

   D‚sactive la tƒche locale du connect‚ courant.

   Syntaxe : DELETELOCALTASK

   La tƒche de fond du connect‚ courant est d‚sactiv‚e.

   Exemple : : BACKGROUND
                BEGIN
                   TIMER 10 % 0 ==
                   IF
                      10 1 LOCATE TIME PRINT
                   ENDIF
                AGAIN
             ;
             ...
             : MAIN
                ...
                SETLOCALTASK BACKGROUND
                ...
                DELETELOCALTASK
                ...
             ;

   NOTE : Une tƒche de fond peut s'auto-d‚sactiver.

LOCALTASKACTIVE?        --- b

   Empile VRAI si la tƒche locale du connect‚ courant est active, FAUX
   sinon.

   Syntaxe : LOCALTASKACTIVE?

   Exemple : : ATTENDFINTACHE
                BEGIN
                   LOCALTASKACTIVE? !
                UNTIL
             ;

MANIPULATION DES DATES
----------------------

DTOS                    d --- s

   Converti une date de la forme "JJ/MM/AAAA" vers la forme "AAAAMMJJ"
   La date convertie est empil‚e.

   Syntaxe : d DTOS

   Exemple : DATE DTOS

STOD                    s --- d

   Converti une date de la forme "AAAAMMJJ" vers la forme "JJ/MM/AAAA"
   La date convertie est empil‚e.

   Syntaxe : s STOD

   Exemple : LOCAL CHAR SDAT
             ...
             DATE DTOS SDAT :=
             ...
             SDAT STOD PRINT
             ...

DTOJ                    s --- n

   Converti une date de la forme "AAAAMMJJ" en jours julien.
   Le nombre obtenu est empil‚.

   Syntaxe : s DTOJ

   si un nombre inf‚rieur … z‚ro est empil‚, cela signifie que la date
   donn‚e est invalide.

   Exemple : : TESTDATE  // d --- b
                DTOS DTOJ 0 <
             ;
             ...
             " entrez la date de rŠglement" print
             DATVAR INPUTVAR
             DATVAR TESTDATE
             IF
                " date invalide" line0
             ELSE
                ...
             ENDIF

JTOD                    n --- s

   Converti une date en jours julien en une date de la forme "AAAAMMJJ".
   La date est empil‚e.

   Syntaxe : n JTOD

   Exemple : : DATEFACTURE  // d1 --- d2
                DTOS DTOJ
                30 + JTOD STOD
             ;
             ...
             " rŠglement … 30 jours au plus tard le " print
             DATE DATEFACTURE PRINT

DAY                     d --- n

   Empile un nombre repr‚sentant le jours du mois (1 … 31) de la date donn‚e.
   La date est empil‚e sour la forme "AAAAMMJJ".

   Syntaxe : d DAY

   Exemple : DATE DTOS DAY

DOW                     d --- n

   Empile un nombre repr‚sentant le jour de la semaine (1 … 7)
   de la date donn‚e.
   La date est empil‚e sour la forme "AAAAMMJJ".
   1 = Dimanche, 2 = Lundi, etc...

   Syntaxe : d DOW

   Exemple : DATE DTOS DOW

MONTH                   d --- n

   Empile un nombre repr‚sentant le mois (1 … 12) de la date donn‚e.
   La date est empil‚e sour la forme "AAAAMMJJ".

   Syntaxe : d MONTH

   Exemple : DATE DTOS MONTH

YEAR                    d --- n

   Empile un nombre repr‚sentant l'ann‚e de la date donn‚e.
   La date est empil‚e sour la forme "AAAAMMJJ".

   Syntaxe : d YEAR

   Exemple : DATE DTOS YEAR

CDOW                    d --- s

   Empile le nom du jour de la date donn‚e, sous forme de chaine de
   caractŠres.
   La date est empil‚e sour la forme "AAAAMMJJ".

   Syntaxe : d CDOW

   Exemple : DATE DTOS CDOW

CMONTH                  d --- s

   Empile le nom du mois de la date donn‚e, sous forme de chaine de
   caractŠres.
   La date est empil‚e sour la forme "AAAAMMJJ".

   Syntaxe : d CMONTH

   Exemple : DATE DTOS CMONTH

MANIPULATION DES FICHIERS
-------------------------

FOPEN                   s --- b

   Ouverture d'un fichier.

   Syntaxe : <NomFichier> FOPEN

   Ouvre le fichier donn‚, en lecture seule.

   Renvoi VRAI si tout c'est bien pass‚, FAUX sinon.

   Exemple : : LIRE
                " INFOS.TXT" FOPEN
                IF
                   ...
                ELSE
                   " IMPOSSIBLE D'OUVRIR LE FICHIER" LINE0
                ENDIF
             ;

   Note : Un connect‚ ne peut ouvrir qu'un seul fichier … la fois.
          Si un fichier est d‚j… ouvert pour le connect‚ courant,
          il est referm‚.

FCLOSE                  ---

   Fermeture d'un fichier.

   Syntaxe : FCLOSE

   Le fichier du connect‚ courant est ferm‚.

   Si aucun fichier n'est ouvert, rien ne se passe.

   Exemple : : LIRE
                " INFOS.TXT" FOPEN
                IF
                   ...
                   FCLOSE
                ELSE
                   " IMPOSSIBLE D'OUVRIR LE FICHIER" LINE0
                ENDIF
             ;

FEOF                    --- b

   Envoi VRAI si on est … la fin du fichier du connect‚ courant,
   FAUX sinon.

   Syntaxe : FEOF

   Si aucun fichier n'est ouvert, VRAI est empil‚.

   Exemple : : LIRE
                " INFOS.TXT" FOPEN
                IF
                   BEGIN
                      FEOF !
                   WHILE
                      ...
                   REPEAT
                   FCLOSE
                ELSE
                   " IMPOSSIBLE D'OUVRIR LE FICHIER" LINE0
                ENDIF
             ;

FREADLN                 --- s

   Lecture d'une ligne de texte du fichier du connect‚ courant.

   Syntaxe : FREADLN

   Si aucun fichier n'est ouvert, une erreur d'ex‚cution est g‚n‚r‚e.
   La ligne lue est empil‚e, sans le CRLF.

   Exemple : : LIRE
                " INFOS.TXT" FOPEN
                IF
                   BEGIN
                      FEOF !
                   WHILE
                      FREADLN
                      PRINT
                   REPEAT
                   FCLOSE
                ELSE
                   " IMPOSSIBLE D'OUVRIR LE FICHIER" LINE0
                ENDIF
             ;

   Note : La longueur d'une ligne de texte ne peut d‚passer 512 caractŠres.

FREAD                   n --- s nlus

   Lecture de <n> octets du fichier du connect‚ courant.

   Syntaxe : n FREAD

   Si aucun fichier n'est ouvert, une erreur d'ex‚cution est g‚n‚r‚e.
   Le nombre d'octets effectivements lus est empil‚, ainsi que le buffer.

   Exemple : : LIRE
                " INFOS.TXT" FOPEN
                IF
                   BEGIN
                      FEOF !
                   WHILE
                      // Lecture de 39 caractŠre … la fois
                      39 FREAD
                      // Affichage
                      // Si le nombre d'octets lus est > … 0.
                      IF
                         PRINT
                      ENDIF
                   REPEAT
                   FCLOSE
                ELSE
                   " IMPOSSIBLE D'OUVRIR LE FICHIER" LINE0
                ENDIF
             ;

FSIZE                   --- n

   Empile la taille (en octets) du fichier du connect‚ courant.

   Syntaxe : FSIZE

   Si aucun fichier n'est ouvert, 0 est empil‚.

   Exemple : " INFOS.TXT" FOPEN
             IF
                FSIZE
                ...
                FCLOSE
             ENDIF

CALCULS DE CRC ET CONVERSIONS
-----------------------------

CRC16                   l b --- crc16

   Calcule le CRC 16 bits du buffer <b> de longueur <l>.

   Syntaxe : Buff Lon CRC16

   Exemple : // Calcul du crc 16 bits d'un fichier
             : CRC16FILE   // s --- crc16
                0 SWAP
                FOPEN
                IF
                   BEGIN
                      FEOF !
                   WHILE
                      // Lecture par bloc de 128 octets
                      128 FREAD
                      CRC16 +
                   REPEAT
                   FCLOSE
                ENDIF
             ;

CRC32                   l b --- crc32

   Calcule le CRC 32 bits du buffer <b> de longueur <l>.

   Syntaxe : Buff Lon CRC32

   Exemple : // Calcul du crc 32 bits d'un fichier
             : CRC32FILE   // s --- crc32
                0 SWAP
                FOPEN
                IF
                   BEGIN
                      FEOF !
                   WHILE
                      // Lecture par bloc de 128 octets
                      128 FREAD
                      CRC32 +
                   REPEAT
                   FCLOSE
                ENDIF
             ;

B8->7                   l1 b1 --- b2 l2

   Converti le contenu du buffer <b1> de longueur <l1> donn‚, de 8 bits
   vers 7 bits.

   Syntaxe : Buff Len B8->7

   Un buffer contenant le r‚sultat, ainsi que sa longueur, est empil‚.

   Exemple : LOCAL CHAR TEST := "CHAINE A CONVERTIR (€‚ƒ„…†‡Y‰Š)"
             ...
             TEST DUP STRLEN B8->7
             ...

B7->8                   l1 b1 --- b2 l2

   Converti le contenu du buffer <b1> de longueur <l1> donn‚, de 7 bits
   vers 8 bits.

   Syntaxe : Buff Len B7->8

   Un buffer contenant le r‚sultat, ainsi que sa longueur, est empil‚.

   Exemple : LOCAL CHAR TEST := "CHAINE A CONVERTIR (€‚ƒ„…†‡Y‰Š)"
             ...
             TEST DUP STRLEN B8->7
             ...
             B7->8
             ...

XXENCODE                l1 b1 --- b2 l2

   XXEncodage du contenu du buffer <b1> de longueur <l1>.

   Syntaxe : Buff Len XXENCODE

   l'XXEncodage est issu du monde unix, et permet de coder sous une forme
   "imprimable" (caractŠres ascii 7 bits) un buffer.

   Un buffer contenant le r‚sultat, ainsi que sa longueur, est empil‚.

   Exemple : LOCAL CHAR TEST := "CHAINE A CONVERTIR (€‚ƒ„…†‡Y‰Š)"
             ...
             TEST DUP STRLEN XXENCODE
             ...
             XXDECODE
             ...

XXDECODE                l1 b1 --- b2 l2

   XXD‚codage du contenu du buffer <b1> de longueur <l1>.

   Syntaxe : Buff Len XXDECODE

   l'XXEncodage est issu du monde unix, et permet de coder sous une forme
   "imprimable" (caractŠres ascii 7 bits) un buffer.

   Un buffer contenant le r‚sultat, ainsi que sa longueur, est empil‚.

   Exemple : LOCAL CHAR TEST := "CHAINE A CONVERTIR (€‚ƒ„…†‡Y‰Š)"
             ...
             TEST DUP STRLEN XXENCODE
             ...
             XXDECODE
             ...

   Note: Pour que le r‚sultat soit significatif, il faut que le buffer
         … convertir soit XXEncod‚.

UUENCODE                l1 b1 --- b2 l2

   UUEncodage du contenu du buffer <b1> de longueur <l1>.

   Syntaxe : Buff Len UUENCODE

   l'UUEncodage est issu du monde unix, et permet de coder sous une forme
   "imprimable" (caractŠres ascii 7 bits) un buffer.

   Un buffer contenant le r‚sultat, ainsi que sa longueur, est empil‚.

   Exemple : LOCAL CHAR TEST := "CHAINE A CONVERTIR (€‚ƒ„…†‡Y‰Š)"
             ...
             TEST DUP STRLEN UUENCODE
             ...
             UUDECODE
             ...

UUDECODE                l1 b1 --- b2 l2

   UUD‚codage du contenu du buffer <b1> de longueur <l1>.

   Syntaxe : Buff Len UUDECODE

   l'UUEncodage est issu du monde unix, et permet de coder sous une forme
   "imprimable" (caractŠres ascii 7 bits) un buffer.

   Un buffer contenant le r‚sultat, ainsi que sa longueur, est empil‚.

   Exemple : LOCAL CHAR TEST := "CHAINE A CONVERTIR (€‚ƒ„…†‡Y‰Š)"
             ...
             TEST DUP STRLEN UUENCODE
             ...
             UUDECODE
             ...

   Note: Pour que le r‚sultat soit significatif, il faut que le buffer
         … convertir soit UUEncod‚.

EMISSION / RECEPTION DE PAQUETS
-------------------------------

Les primitives suivantes servent … manipuler des donn‚es brutes, tant en envoi
qu'en r‚ception, de fa‡on … impl‚menter facilement diverses protocoles de
t‚l‚chargement, entre autre.

FLUSHOUTBUFFER          ---

   Force le vidage du buffer de sortie du connect‚ courant.

   Syntaxe : FLUSHOUTBUFFER

   Les donn‚es en partance sont perdues.

   Exemple : : TELSEND
                FLUSHOUTBUFFER
                ...
             ;

EMITBUFFER              s ---

   Emission du buffer donn‚ pour le connect‚ courant.

   Syntaxe : Buffer EMITBUFFER

   Le buffer n'est soumis … aucun processus de conversion quelconque, il
   est envoy‚ tel quel.

   Exemple : : TELSEND
                FLUSHOUTBUFFER
                ...
                // BuffOut contient les donn‚es … envoyer
                BuffOut EMITBUFFER
                ...
             ;

