                          MANUEL DE REFERENCE DE PGForth
                          ------------------------------


 UM/MOD
Divise un entier double non sign‚ par un entier simple non sign‚.
 Syntaxe : ud u UM/MOD
Divise l'entier double non sign‚ "ud" par l'entier simple non sign‚ "u".
Empile le reste et le quotient (entiers simples non sign‚s).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE UM/MOD  ( ud u --- reste quotient )
  BX POP
  DX POP
  AX POP
  BX DX CMP
  >>=
  IF
    -1 # AX MOV  ( Division par z‚ro )
    AX DX MOV
    2PUSH
  THEN
  BX DIV
  2PUSH
END-CODE

 UM*
Multiplication de deux nombres non sign‚s.
@SYNTAXE = Syntaxe : u1 u2 UM*
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE UM*  ( u1 u2 --- d )
  AX POP
  BX POP
  BX MUL
  DX AX XCHG
  2PUSH
END-CODE

 U*D
Multiplication de deux nombres non sign‚s.
Identique … UM*.
@SYNTAXE = Syntaxe : u1 u2 U*D
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE U*D  ( u1 u2 --- d )
  ' UM* #) JMP
END-CODE

 *D
Multiplication de deux nombres sign‚s.
@SYNTAXE = Syntaxe : n1 n2 *D
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : *D  ( n1 n2 --- d )
  2DUP XOR >>R
  ABS SWAP UM*
  R>>  ?DNEGATE
;

 M/MOD
Divise un entier double sign‚ par un entier simple
sign‚.
@SYNTAXE = Syntaxe : d n M/MOD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : M/MOD  ( d n --- reste quotient )
  ?DUP
  IF
    DUP >>R 2DUP XOR
    >>R >>R DABS R@ ABS
    UM/MOD SWAP R>> ?NEGATE
    SWAP R>> 0<<
    IF
      NEGATE OVER
      IF
        1- R@ ROT - SWAP
      THEN
    THEN
    R>> DROP
  THEN
;

 */MOD
Multiplie deux entiers simples, et divise le r‚sultat
(sur 32 bits) par un troisiŠme.
@SYNTAXE = Syntaxe : n1 n2 n3 */MOD  \ (n1 * n2) / n3
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : */MOD  ( n1 n2 n3 --- reste quotient )
  >>R *D R>> M/MOD
;

 */
Multiplie deux entiers simples, et divise le r‚sultat
(sur 32 bits) par un troisiŠme.
@SYNTAXE = Syntaxe : n1 n2 n3 */  \ R‚sultat : (n1 * n2) / n3
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE */  ( n1 n2 n3 --- n4 )
  CX POP
  BX POP
  AX POP
  BX MUL
  CX DIV
  1PUSH
END-CODE

 /MOD
Division avec reste de deux nombres sign‚s.
@SYNTAXE = Syntaxe : n1 n2 /MOD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE /MOD  ( n1 n2 --- reste quotient )
  CX POP
  AX POP
  DX DX XOR
  CX DIV
  2PUSH
END-CODE

 MOD
Reste de la division de deux nombres sign‚s.
@SYNTAXE = Syntaxe : n1 n2 MOD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE MOD  ( n1 n2 --- reste )
  CX POP
  AX POP
  DX DX XOR
  CX DIV
  DX AX MOV
  1PUSH
END-CODE

 /
Division de deux nombres entiers.
@SYNTAXE = Syntaxe : n1 n2 /
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE /  ( n1 n2 --- quotient )
  CX POP
  AX POP
  DX DX XOR
  CX DIV
  1PUSH
END-CODE

 *
Multiplication de deux nombres entiers.
@SYNTAXE = Syntaxe : n1 n2 *
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE *  ( n1 n2 --- n3 )
  CX POP
  AX POP
  CX MUL
  1PUSH
END-CODE

 MU/MOD
Division d'un entier double non sign‚ par un entier
simple non sign‚.
Le quotient empil‚ est un double.
@SYNTAXE = Syntaxe : ud u MU/MOD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : MU/MOD  ( ud1 u --- reste quotient_d )
  >>R 0 R@ UM/MOD
  R>> SWAP >>R UM/MOD R>>
;

 DMAX
Renvoi le maximum de deux entiers doubles.
@SYNTAXE = Syntaxe : d1 d2 DMAX
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DMAX  ( d1 d2 --- d3 )
  4DUP D<<
  IF
    2SWAP
  THEN
  2DROP
;

 DMIN
Renvoi le minimum de deux entiers doubles.
@SYNTAXE = Syntaxe : d1 d2 DMIN
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DMIN  ( d1 d2 --- d3 )
  4DUP D>>
  IF
    2SWAP
  THEN
  2DROP
;

 D-
Soustraction de deux entiers doubles.
@SYNTAXE = Syntaxe : d1 d2 D-
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE D-  ( d1 d2 --- d3 )
  BX POP
  CX POP
  AX POP
  DX POP
  CX DX SUB
  BX AX SBB
  2PUSH
END-CODE

 D2/
Division d'un entier double par deux.
@SYNTAXE = Syntaxe : d D2/
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE D2/  ( d --- d/2 )
  AX POP
  DX POP
  AX SAR
  DX RCR
  2PUSH
END-CODE

 D2*
Multiplication d'un entier double par deux.
@SYNTAXE = Syntaxe : d D2*
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE D2*  ( d --- d*2 )
  AX POP
  DX POP
  DX SHL
  AX RCL
  2PUSH
END-CODE

 DNEGATE
N‚gation d'un entier double.
@SYNTAXE = Syntaxe : d DNEGATE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = LABEL DNEGATE  ( d --- d' )
  BX POP
  CX POP
  AX AX SUB
  AX DX MOV
  CX DX SUB
  BX AX SBB
2PUSH

 DABS
Valeur absolue d'un entier double.
@SYNTAXE = Syntaxe : d DABS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE DABS  ( d --- |d| )
  DX POP
  DX PUSH
  DX DX OR
  DNEGATE JS
  NEXT
END-CODE

 ?DNEGATE
N‚gation conditionnelle d'un entier double.
@SYNTAXE = Syntaxe : d flag ?DENEGATE
L'entier double d est ni‚ si le flag est VRAI.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?DNEGATE  ( d flag --- d' )
  0<<
  IF
    DNEGATE
  THEN
;

 D+
Addition de deux entiers doubles.
@SYNTAXE = Syntaxe : d1 d2 D+
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE D+  ( d1 d2 --- d3 )
  AX POP
  DX POP
  BX POP
  CX POP
  CX DX ADD
  BX AX ADC
  2PUSH
END-CODE

 MAX
Renvoi le maximum de deux entiers simples.
@SYNTAXE = Syntaxe : n1 n2 MAX
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE MAX  ( n1 n2 --- n3 )
  BX POP
  AX POP
  AX BX CMP
  >>
  IF
    BX AX MOV
  THEN
  1PUSH
END-CODE

 MIN
Renvoi le minimum de deux entiers simples.
@SYNTAXE = Syntaxe : n1 n2 MIN
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE MIN  ( n1 n2 --- n3 )
  AX POP
  BX POP
  BX AX CMP
  >>
  IF
    BX AX MOV
  THEN
  1PUSH
END-CODE

 2-
EnlŠve deux au nombre situ‚ au sommet de la pile de
donn‚es.
@SYNTAXE = Syntaxe : n 2-
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 2-  ( n --- n-2 )
  AX POP
  AX DEC
  AX DEC
  1PUSH
END-CODE

 1-
EnlŠve un au nombre situ‚ au sommet de la pile de
donn‚es.
@SYNTAXE = Syntaxe : n 1-
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 1-  ( n --- n-1 )
  AX POP
  AX DEC
  1PUSH
END-CODE

 2+
Ajoute deux au nombre situ‚ au sommet de la pile de
donn‚es.
@SYNTAXE = Syntaxe : n 2+
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 2+  ( n --- n+2 )
  AX POP
  AX INC
  AX INC
  1PUSH
END-CODE

 1+
Ajoute un au nombre situ‚ au sommet de la pile de
donn‚es.
@SYNTAXE = Syntaxe : n 1+
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 1+  ( n --- n+1 )
  AX POP
  AX INC
  1PUSH
END-CODE

 8*
Multiplie par huit le nombre situ‚ au sommet de la
pile de donn‚es.
@SYNTAXE = Syntaxe : n 8*
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 8*  ( n --- n*8 )
  AX POP
  AX SHL
  AX SHL
  AX SHL
  1PUSH
END-CODE

 U2/
Divise par deux le nombre non sign‚ situ‚ au sommet
de la pile de donn‚es.
@SYNTAXE = Syntaxe : u U2/
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE U2/  ( u --- u/2 )
  AX POP
  AX SHR
  1PUSH
END-CODE

 2/
Divise par deux le nombre situ‚ au sommet de la pile
de donn‚es.
@SYNTAXE = Syntaxe : n 2/
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 2/  ( n --- n/2 )
  AX POP
  AX SAR
  1PUSH
END-CODE

 2*
Multiplie par deux le nombre situ‚ au sommet de la
pile de donn‚es.
@SYNTAXE = Syntaxe : n 2*
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 2*  ( n --- n*2 )
  AX POP
  AX SHL
  1PUSH
END-CODE

 3
Empile le nombre trois.
@SYNTAXE = Syntaxe : 3
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 3  ( --- 3 )
  3 # AX MOV
  1PUSH
END-CODE
Le fait de consid‚rer un nombre comme une d‚finition
FORTH permet
d'optimiser le code, en compilation, ainsi que l'‚x‚cution.

 2
Empile le nombre deux.
@SYNTAXE = Syntaxe : 2
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 2  ( --- 2 )
  2 # AX MOV
  1PUSH
END-CODE
Le fait de consid‚rer un nombre comme une d‚finition
FORTH permet
d'optimiser le code, en compilation, ainsi que l'‚x‚cution.

 1
Empile le nombre un.
@SYNTAXE = Syntaxe : 1
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 1  ( --- 1 )
  1 # AX MOV
  1PUSH
END-CODE
Le fait de consid‚rer un nombre comme une d‚finition
FORTH permet
d'optimiser le code, en compilation, ainsi que l'‚x‚cution.

 0
Empile le nombre z‚ro.
@SYNTAXE = Syntaxe : 0
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 0  ( --- 0 )
  0 # AX MOV
  1PUSH
END-CODE
Le fait de consid‚rer un nombre comme une d‚finition
FORTH permet
d'optimiser le code, en compilation, ainsi que l'‚x‚cution.

 NEGATE
N‚gation d'un entier simple.
@SYNTAXE = Syntaxe : n NEGATE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = LABEL NEGAT
  AX POP
  AX NEG
  1PUSH

CODE NEGATE  ( n --- n' )
  NEGAT #) JMP
END-CODE

 ABS
Valeur absolue d'un entier simple.
@SYNTAXE = Syntaxe : n ABS
@DEF_FORTH = D‚finition en FORTH
@PROGRAMME = CODE ABS  ( n --- |n| )
  AX POP
  AX AX OR
  0<<
  IF
    AX NEG
  THEN
  1PUSH
END-CODE

 ?NEGATE
N‚gation d'un entier simple, si le flag pr‚sent au
sommet de la pile de donn‚es est VRAI.
@SYNTAXE = Syntaxe n flag ?NEGATE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE ?NEGATE  ( n flag --- n' )
  AX POP
  AX AX OR
  NEGAT JS
  NEXT
END-CODE

 -
Soustraction de deux entiers simples.
@SYNTAXE = Syntaxe : n1 n2 -
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE -  ( n1 n2 --- n3 )
  BX POP
  AX POP
  BX AX SUB
  1PUSH
END-CODE

 +
Addition de deux entiers simples.
@SYNTAXE = Syntaxe : n1 n2 +
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE +  ( n1 n2 --- n3 )
  BX POP
  AX POP
  BX AX ADD
  1PUSH
END-CODE

 ASCII0
Saisit une chaine, correspondant … un nom de fichier,
et
la transfŠre … l'adresse renvoy‚e [adr] sous la forme
standard en la faisant suivre d'un z‚ro, terminateur
des noms de fichier pour le systŠme d'exploitation.
Une chaine ASCII0 ainsi cr‚‚e peut ˆtre compos‚e
des noms d'unit‚ et de r‚pertoires et se termine
par le nom du fichier.
[adr] est l'adresse renvoy‚e par 'WORD.
@SYNTAXE = Syntaxe : ASCII0 chaine
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ASCII0  ( chaine --- adr )
  BL WORD
  COUNT OVER +
  0 SWAP C!
;

 ."
Affichage d'une chaine.
@SYNTAXE = Syntaxe : ." chaine"
Affiche la <<chaine>> termin‚e par un guillemet.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ."  ( chaine --- )
  STATE @
  IF
    COMPILE (.")
    ,"
  ELSE
    ASCII " WORD
    COUNT TYPE
  THEN
;
IMMEDIATE

 >>TYPE
Affichage d'une chaine.
Equivalent … TYPE.
@SYNTAXE = Syntaxe : adresse long >>TYPE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : >>TYPE  ( adresse long --- )
  TUCK $PAD SWAP CMOVE
  $PAD SWAP TYPE
;

 .(
Affichage de commentaires.
Affiche le commentaire situ‚ entre parenthŠses.
@SYNTAXE = Syntaxe : .( ... commentaires ... )
La parenthŠse fermente est OBLIGATOIRE et doit Štre
pla‡‚e sur la mˆme ligne.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : .(  ( --- )
  ASCII ) PARSE TYPE
;

 WORD
Isole du flux d'entr‚e un mot d‚limit‚ par un ou
plusieurs caractŠres.
@SYNTAXE = Syntaxe : s‚parateur WORD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : WORD  ( s‚parateur --- adresse )
  PARSE-WORD 'WORD PLACE
  'WORD DUP COUNT +
  BL SWAP C!
;

 'WORD
Renvoi l'adresse de la zone de donn‚es utilis‚e par
WORD.
@SYNTAXE = Syntaxe : 'WORD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : 'WORD  ( --- adr )
  HERE 256 +
;

 PARSE
Isole un mot d‚limit‚ par un caractŠre, dans le flux
d'entr‚e.
@SYNTAXE = Syntaxe : s‚parateur PARSE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : PARSE  ( s‚parateur --- adresse long )
  >>R SOURCE >>IN @ /STRING
  OVER SWAP R>> SCAN >>R
  OVER - DUP R>> 0<<>> -
  >>IN +!
;
Empile l'adresse du mot, ainsi que sa longueur.

 PARSE-WORD
Primitive.
Isole un mot d‚limit‚ par un s‚parateur, dans le flux d'entr‚e.
Utilis‚e par WORD.
@SYNTAXE = Syntaxe : s‚parateur PARSE-WORD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : PARSE-WORD  ( s‚parateur --- adresse long )
  >>R SOURCE TUCK
  >>IN @ /STRING
  R@ SKIP OVER SWAP
  R>> SCAN >>R OVER -
  ROT R>> DUP 0<<>> + -
  >>IN !
;
Empile l'adresse du mot, ainsi que sa longueur.

 /STRING
Troncature … droite d'une chaine de caractŠres.
@SYNTAXE = Syntaxe : adresse long pos /STRING
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE /STRING  ( adresse long pos --- adresse'
long' )
  BX POP
  AX POP
  DX POP
  AX BX CMP
  >>
  IF
    AX BX MOV
  THEN
  BX DX ADD
  BX AX SUB
  2PUSH
END-CODE

 SCAN
Recherche de la premiŠre occurence dans une chaine.
@SYNTAXE = Syntaxe : adr_chaine longueur car SCAN
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = ASSEMBLER
LABEL DONE
  CX PUSH
  NEXT
CODE SCAN  ( adr_chaine longueur car --- adr long )
  AX POP
  CX POP
  DONE JCXZ
  DI POP
  CODE-REF #) CALL
  DX ES MOV
  CX BX MOV
  REP BYTE SCAS
  0=
  IF
    CX INC
    DI DEC
  THEN
  DI PUSH
  CX PUSH
  NEXT
END-CODE
Informations renvoy‚es :
adr  est l'adresse du caractŠre recherch‚
long est la longueur de la chaine restante, ou 0 si le
caractŠre n'a pas ‚t‚ trouv‚.

 SKIP
Recherche de la sous-chaine restante.
@SYNTAXE = Syntaxe : adr_chaine longueur car SKIP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE SKIP  ( adr_chaine longueur car --- adr long
)
  AX POP
  CX POP
  DONE JCXZ
  DI POP
  CODE-REF #) CALL
  DX ES MOV
  REPZ BYTE SCAS
  0<<>>
  IF
    CX INC
    DI DEC
  THEN
  DI PUSH
  CX PUSH
  NEXT
END-CODE
Empile l'adresse de la sous-chaine restante aprŠs le
caractŠre car.

 (SOURCE)
Primitive.
Vectoris‚e par SOURCE.
Renvoi l'adresse et la longueur du flux d'entr‚e.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (SOURCE)  ( --- adr long )
  BUFFER COUNT
;

 SOURCE
Vecteur.
Renvoi l'adresse du flux d'entr‚e.
@SYNTAXE = Syntaxe : SOURCE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER SOURCE

 QUERY
Saisie au clavier d'une chaine, et stockage de celle-
ci dans le tampon TIB.
@SYNTAXE = Syntaxe : QUERY
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : QUERY  ( --- )
  'TIB @ C/L EXPECT
  SPAN @ #TIB C!
  >>IN OFF
;

 EXPECT
Attend l'entr‚e d'une chaine de longueur d‚termin‚e.
@SYNTAXE = Syntaxe : adr_chaine longueur EXPECT
La fin de la chaine est d‚termin‚e, soit par
l'atteinte de la longueur,
soit par appui sur la touche <<Entr‚e>>.
Stocke la chaine saisie … adr_chaine.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : EXPECT  ( adr_chaine longueur --- )
  DUP SPAN !
  SWAP 0
  BEGIN
    2 PICK
    OVER -
  WHILE
    KEY DUP
    BL <<          ( Est-ce un caractŠre de contr“le ? )
    IF
      2* C-C @ +  ( Oui, ‚x‚cution du vecteur correspondant )
      PERFORM
    ELSE
      DUP 127 =
      IF
        DROP DEL-IN
      ELSE
        CHAR
      THEN
    THEN
  REPEAT
  2DROP DROP
;

 CHAR
Vecteur.
Place un caractŠre dans un tampon.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER CHAR

 (CHAR)
Primitive.
Vectoris‚e par CHAR.
Place un caractŠre dans un tampon.
@SYNTAXE = Syntaxe : adresse long car (CHAR)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (CHAR)  ( adresse long car --- adresse long+1 )
  3DUP EMIT +
  C! 1+
;

 CR-IN
Vecteur.
Correspond … l'action de la touche <<Entr‚e>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CR-IN  ( adresse long --- adresse long' )
  SPAN ! OVER BL EMIT
;

 P-IN
Vecteur.
Correspond … l'action du switch d'impression (CTRL+P).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : P-IN
  PRINTING @ NOT
  PRINTING !
;

 RES-IN
Vecteur.
R‚initialisation du systŠme FORTH.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : RES-IN
  FORTH TRUE
  ABORT" Initialisation"
;

 BACK-UP
Vecteur.
Correspond … l'action de CTRL+U et CTRL+X.
Annulation de la saisie dans un tampon.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BACK-UP  ( adresse long --- adresse 0 )
  DUP BACKSPACES DUP
  SPACES BACKSPACES 0
;

 DEL-IN
Vecteur.
Correspond … l'action de CTRL+H.
Annulation du dernier caractŠre saisi.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DEL-IN  ( adresse long --- adresse long' )
  DUP
  IF
    1- BS EMIT
    SPACE BS
  ELSE
    BELL
  THEN
  EMIT
;

 BS-IN
Vecteur.
Correspond … l'action de la touche <<- (Backspace).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BS-IN
  DROP DUP
  IF
    1- BS
  ELSE
    BELL
  THEN
  EMIT
;

 BEEP
Emet un bip.
@SYNTAXE = Syntaxe : BEEP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BEEP  ( --- )
  BELL EMIT
;

 BACKSPACES
Emet un ou plusieurs espaces arriŠres.
@SYNTAXE = Syntaxe : n BACKSPACES
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BACKSPACES  ( n --- )
  BS REPLICATE
;

 SPACES
Emet un ou plusieurs espaces.
@SYNTAXE = Syntaxe : n SPACES
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SPACES  ( n --- )
  BL REPLICATE
;

 SPACE
Emet un espace.
@SYNTAXE = Syntaxe : SPACE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SPACE  ( --- )
  BL EMIT
;

 REPLICATE
R‚p‚tition de caractŠres.
@SYNTAXE = Syntaxe : n car REPLICATE
Emet n caractŠres car.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : REPLICATE  ( n car --- )
  SWAP 0 MAX 0
  DO
    DUP EMIT
  LOOP
  DROP
;

 TYPE
Affichage d'une chaine de caractŠres.
@SYNTAXE = Syntaxe : adr_chaine long TYPE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : TYPE  ( adr_chaine long --- )
  0
  DO
    COUNT EMIT
  LOOP
  DROP
;

 CR
Vecteur.
Emet un retour chariot.
@SYNTAXE = Syntaxe : CR
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER CR

 (CR)
Emet un retour chariot.
Vectoris‚ par CR.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (CR)  ( --- )
  13 EMIT 10 EMIT
  #OUT OFF #LINE @ 1+
  24 MAX #LINE !
;

 HOME
Positionne le curseur en haut et … gauche.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : HOME  ( --- )
  27 (CONS) ASCII [ (CONS)
  ASCII f (CONS)
;
HOME n‚c‚ssite l'installation du driver ANSI.SYS.

 DARK
Efface l'‚cran, et positionne le curseur en haut et …
gauche.
@SYNTAXE = Syntaxe : DARK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DARK  ( --- )
  27 (CONS) ASCII [ (CONS)
  ASCII 2 (CONS) ASCII J (CONS)
  #OUT OFF #LINE OFF
;
DARK n‚c‚ssite l'installation du driver ANSI.SYS.

 INVERS
Passage en vid‚o inverse.
@SYNTAXE = Syntaxe : INVERS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : INVERS  ( --- )
  7 (ATTRIB)
;
INVERS n‚c‚ssite l'installation du driver ANSI.SYS.

 BLINK
Passage en mode clignotant.
@SYNTAXE = Syntaxe : BLINK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BLINK  ( --- )
  5 (ATTRIB)
;
BLINK n‚c‚ssite l'installation du driver ANSI.SYS.

 UNDERL
Passage en mode soulign‚.
@SYNTAXE = Syntaxe : UNDERL
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : UNDERL  ( --- )
  4 (ATTRIB)
;
UNDERL n‚c‚ssite l'installation du driver ANSI.SYS.

 BOLD
Passage en mode surimppression ( gras ).
@SYNTAXE = Syntaxe : BOLD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BOLD  ( --- )
  1 (ATTRIB)
;
BOLD n‚c‚ssite l'installation du driver ANSI.SYS.

 ATTOFF
Inibition des attributs d'affichage.
@SYNTAXE = Syntaxe : ATTOFF
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ATTOFF  ( --- )
  0 (ATTRIB)
;

 (ATTRIB)
Changement d'attributs.
@SYNTAXE = Syntaxe : n (ATTRIB)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (ATTRIB)  ( n --- )
  ATTRIBUTS @
  IF
    27 (CONS) ASCII [ (CONS)
    ASCII 0 + (CONS)
    ASCII m (CONS)
  ELSE
    DROP
  THEN
;
(ATTRIB) n‚c‚ssite l'installation du driver ANSI.SYS.

 EMIT
Vecteur.
Emission d'un caractŠre.
@SYNTAXE = Syntaxe : car EMIT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER EMIT

 (EMIT)
Primitive.
Emission d'un caractŠre.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (EMIT)  ( car --- )
  PRINTING @
  IF
    DUP (PRINT)
    #OUT 1-!
  THEN
  (CONSOLE)
;

 (PRINT)
Primitive.
Emission d'un caractŠre vers le p‚riph‚rique d'impression.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (PRINT)  ( car --- )
  (PRN) #OUT 1+!
;

 (CONSOLE)
Primitive.
Emission d'un caractŠre vers le p‚riph‚rique de sortie
standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (CONSOLE)  ( car --- )
  (CONS) #OUT 1+!
;

 (CONS)
Primitive.
Emission d'un caractŠre vers le p‚riph‚rique de sortie
standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (CONS)  ( car --- )
  6 (OUT)
;

 KEY?
Vecteur.
Renvoi VRAI si une touche a ‚t‚ actionn‚e.
@SYNTAXE = Syntaxe : KEY?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER KEY?

 KEY
Vecteur.
Renvoi le code de la touche actionn‚e.
@SYNTAXE = Syntaxe : KEY
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER KEY

 (KEY)
Primitive.
Vectoris‚e par KEY.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (KEY)  ( --- car )
  BEGIN
    (KEY?)
  UNTIL
  7 (IN)
;

 (KEY?)
Primitive.
Vectoris‚e par KEY?.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (KEY?)  ( --- flag )
  11 (IN) 0<<>>
;

 .ID
Affiche le nom du mot dont le NFA est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : nfa .ID
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : .ID  ( nfa --- )
  DUP 1+ DUP C@ ROT
  C@ 31 AND 0
  ?DO
    DUP 127 AND EMIT
    128 AND
    IF
      ASCII _ 128 OR
    ELSE
      1+ DUP C@
    THEN
  LOOP
  2DROP SPACE
;

 H.
Affiche le nombre pr‚sent sur la pile en
repr‚sentation h‚xad‚cimale,
sans modifier la base de sortie courante.
@SYNTAXE = Syntaxe : n H.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : H.  ( n --- )
  OBASE DUP @ >>R HEX
  . R>> OBASE !
;

 B.
Affiche le nombre pr‚sent sur la pile en
repr‚sentation binaire,
sans modifier la base de sortie courante.
@SYNTAXE = Syntaxe : n B.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : B.  ( n --- )
  OBASE DUP @ >>R BINARY
  . R>> OBASE !
;

 O.
Affiche le nombre pr‚sent sur la pile en
repr‚sentation octale,
sans modifier la base de sortie courante.
@SYNTAXE = Syntaxe : n O.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : O.  ( n --- )
  OBASE DUP @ >>R OCTAL
  . R>> OBASE !
;

 ?
Affichage du contenu d'une variable.
@SYNTAXE = Syntaxe : nom_variable ?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?  ( adr --- )
  @ .
;

 D.R
Affichage d'un double cadr‚ … droite.
@SYNTAXE = Syntaxe : d n D.R
Affiche le double d cadr‚ … droite sur n chiffres,
compl‚t‚s ‚ventuellement avec des espaces.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D.R  ( d n --- )
  >>R (D.) R>>
  OVER - SPACES TYPE
;

 D.
Affichage d'un double.
@SYNTAXE = Syntaxe : d D.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D.  ( d --- )
  (D.) TYPE SPACE
;

 (D.)
Primitive.
Affichage d'un double.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (D.)  ( d --- )
  TUCK DABS
  <<# #S ROT SIGN #>>
;

 UD.R
Affichage d'un double non sign‚ cadr‚ … droite.
@SYNTAXE = Syntaxe : ud n UD.R
Affiche le double non sign‚ ud cadr‚ … droite sur n
chiffres,
compl‚t‚s ‚ventuellement avec des espaces.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : UD.R  ( ud n --- )
  >>R (UD.) R>>
  OVER - SPACES TYPE
;

 UD.
Affichage d'un double non sign‚.
@SYNTAXE = Syntaxe : ud UD.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : UD.  ( ud --- )
  (UD.) TYPE SPACE
;

 (UD.)
Primitive.
Affichage d'un double non sign‚.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (UD.)  ( ud --- )
  <<# #S #>>
;

 .R
Affichage d'un entier cadr‚ … droite.
@SYNTAXE = Syntaxe : int n .R
Affiche l'entier int cadr‚ … droite sur n chiffres,
compl‚t‚s ‚ventuellement avec des espaces.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : .R  ( int n --- )
  >>R (.) R>>
  OVER - SPACES TYPE
;

 .
Affichage d'un entier.
@SYNTAXE = Syntaxe : n .
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : .  ( n --- )
  (.) TYPE SPACE
;

 (.)
Primitive.
Affichage d'un entier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (.)  ( n --- )
  DUP ABS 0
  <<# #S ROT SIGN #>>
;

 U.R
Affichage d'un entier non sign‚ cadr‚ … droite.
@SYNTAXE = Syntaxe : u n U.R
Affiche l'entier non sign‚ u, cadr‚ … droite sur n
chiffres,
compl‚t‚s ‚ventuellement avec des espaces.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : U.R  ( u n --- )
  >>R (U.) R>>
  OVER - SPACES TYPE
;

 U.
Affichage d'un entier non sign‚.
@SYNTAXE = Syntaxe : u U.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : U.  ( u --- )
  (U.) TYPE SPACE
;

 (U.)
Primitive.
Affichage d'un entier non sign‚.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (U.)  ( u --- )
  0 <<# #S #>>
;

 #S
Primitive.
formattage des n chiffres non nuls d'un nombre en texte, pour
affichage.
La conversion s'effectue en fonction de la base de sortie
courante.
Ce mot n'est utilisable qu'entre <<# et #>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : #S  ( d --- 0 0 )
  BEGIN
    # 2DUP OR 0=
  UNTIL
;

 #
Primitive.
Conversion d'un nombre en caractŠre ASCII.
La conversion s'effectue en fonction de la base de sortie
courante.
Ce mot n'est utilisable qu'entre <<# et #>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : #  ( n1 --- n2 )
  OBASE @ MU/MOD
  ROT 9 OVER <<
  IF
    7 +
  THEN
  ASCII 0 + HOLD
;

 SIGN
Insertion ‚ventuelle du signe du nombre en cours de
formattage, si le nombre est n‚gatif.
Ce mot ne s'utilise qu'entre <<# et #>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SIGN  ( n --- )
  0<<
  IF
    ASCII - HOLD
  THEN
;

 <<#
Initialisation du formattage d'un nombre, pour
affichage.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : <<#  ( --- )
  PAD HLD !
;

 #>>
Fin du formattage d'un nombre, pour affichage.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : #>>  ( d --- adr n )
  2DROP HLD @
  PAD OVER -
;
Renvoi l'adresse de la chaine, ainsi que sa longueur,
prˆt pour TYPE.

 HOLD
Insertion d'un caractŠre pendant un formatage.
Ce mot ne s'utilise qu'entre <<# et #>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : HOLD  ( car --- )
  HLD 1-! HLD @ C!
;

 NUMBER
Vecteur.
Conversion d'une chaine en un nombre double.
@SYNTAXE = Syntaxe : adresse NUMBER
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER NUMBER

 (NUMBER)
Primitive.
Vectoris‚ par NUMBER.
Conversion d'une chaine en un nombre double.
@SYNTAXE = Syntaxe : adresse (NUMBER)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (NUMBER)  ( adresse --- d )
  NUMBER?
  NOT ?MISSING
;

 NUMBER?
Conversion d'une chaine en un nombre double.
@SYNTAXE = Syntaxe : adresse NUMBER?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : NUMBER?  ( adresse --- d flag )
  FALSE OVER COUNT
  BOUNDS
  DO
    I C@ IBASE @
    DIGIT NIP
    IF
      DROP TRUE
      LEAVE
    THEN
  LOOP
  IF
    (NUMBER?)
  ELSE
    DROP 0 0
    FALSE
  THEN
;
Si le flag empil‚ est VRAI, le nombre double qui suit
est valide.

 BOUNDS
Renvoi l'adresse de d‚but et de fin d'une chaine.
@SYNTAXE = Syntaxe : adresse long BOUNDS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE BOUNDS  ( adresse long --- adresse1 adresse2
)
  BX POP
  AX POP
  AX DX MOV
  BX DX ADD
  2PUSH
END-CODE

 (NUMBER?)
Primitive.
Utilis‚e par NUMBER?
Conversion d'une chaine en un nombre double.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (NUMBER?)  ( adresse --- d flag )
  0 0 ROT DUP 1+ C@
  ASCII - = DUP
  >>R - -1 DPL !
  BEGIN
    CONVERT DUP C@
    ASCII , ASCII /
    BETWEEN
  WHILE
    0 DPL !
  REPEAT
  -ROT R>>
  IF
    DNEGATE
  THEN
  ROT C@ BL =
;

 CONVERT
Conversion d'une chaine en un nombre.
@SYNTAXE = Syntaxe : ud1 adresse CONVERT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CONVERT  ( ud1 adresse --- ud2 adresse2 )
  BEGIN
    1+ DUP >>R C@
    IBASE @ DIGIT
  WHILE
    SWAP IBASE @ UM*
    DROP ROT IBASE @
    UM* D+ DOUBLE?
    IF
      DPL 1+!
    THEN
    R>>
  REPEAT
  DROP R>>
;

 DOUBLE?
Renvoi un flag VRAI si la derniŠre conversion d'une
chaine en un nombre double a aboutie.
@SYNTAXE = Syntaxe : DOUBLE?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DOUBLE?  ( --- flag )
  DPL @ 1+ 0<<>>
;

 DIGIT
Conversion d'un caractŠre en un nombre.
@SYNTAXE = Syntaxe : car base DIGIT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = ASSEMBLER
LABEL FAIL
  AX AX SUB
  1PUSH
CODE DIGIT  ( car base --- n flag )
  DX POP
  AX POP
  AX PUSH
  ASCII 0 # AL SUB
  FAIL JB
  9 # AL CMP
  >>
  IF
    17 # AL CMP
    FAIL JB
    7 # AL SUB
  THEN
  DL AL CMP
  FAIL JAE
  AL DL MOV
  AX POP
  TRUE # AX MOV
  2PUSH
END-CODE

 UPPER
Conversion d'une chaine en majuscules.
@SYNTAXE = Syntaxe : adr_chaine longueur UPPER
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = LABEL >>UPPER
  ASCII a # AL CMP
  0>>=
  IF
    ASCII z 1+ # AL CMP
    0<<
    IF
      32 # AL SUB
    THEN
  THEN
  RET
CODE UPPER  ( adr_chaine longueur --- )
  CX POP
  BX POP
  BEGIN
    CX CX OR
    0<<>>
  WHILE
    0 [BX] AL MOV
    >>UPPER #) CALL
    AL 0 [BX] MOV
    BX INC
    CX DEC
  REPEAT
  NEXT
END-CODE

 UPC
Conversion d'un caractŠre en majuscule.
@SYNTAXE = Syntaxe : car UPC
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE UPC  ( car --- car' )
  AX POP
  >>UPPER #) CALL
  1PUSH
END-CODE

 -TRAILING
Suppression des espaces en fin de chaine.
@SYNTAXE = Syntaxe : adresse long -TRAILING
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : -TRAILING  ( adresse long --- adresse long2 )
  DUP 0
  DO
    2DUP + 1- C@
    BL <<>> ?LEAVE
    1-
  LOOP
;

 ?CHAR
Conversion conditionnelle d'un caractŠre en
majuscule.
@SYNTAXE = Syntaxe : car ?CHAR
Si la variable CAPS est ON, le caractŠre est converti
en majuscule.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?CHAR  ( car --- car' )
  CAPS @
  IF
    UPC
  THEN
;

 LENGTH
Renvoi la longueur d'une chaine.
Celle-ci peut d‚passer 255 caractŠres.
@SYNTAXE = Syntaxe : adr_chaine LENGTH
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE LENGTH  ( adr_chaine --- adr_chaine+2
longueur )
  BX POP
  0 [BX] AX MOV
  BX INC
  BX INC
  BX PUSH
  1PUSH
END-CODE

 COUNT
Renvoi la longueur d'une chaine.
Celle-ci ne peut d‚passer 255 caractŠres.
@SYNTAXE = Syntaxe : adr_chaine COUNT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE COUNT  ( adr_chaine --- adr_chaine+1 longueur
)
  BX POP
  0 [BX] AL MOV
  AH AH XOR
  BX INC
  BX PUSH
  1PUSH
END-CODE

 S>>D
Conversion d'un entier simple en entier double.
@SYNTAXE = Syntaxe : n S>>D
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE S>>D  ( n --- d )
  AX POP
  CWD
  DX AX XCHG
  2PUSH
END-CODE

 HEX
Passage d'une base en h‚xad‚cimal.
@SYNTAXE = Syntaxe : adr_base HEX
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : HEX  ( adr_base --- )
  16 SWAP !
;

 DECIMAL
Passage d'une base en d‚cimal.
@SYNTAXE = Syntaxe : adr_base DECIMAL
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DECIMAL  ( adr_base --- )
  10 SWAP !
;

 OCTAL
Passage d'une base en octal.
@SYNTAXE = Syntaxe : adr_base OCTAL
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : OCTAL  ( adr_base --- )
  8 SWAP !
;

 BINARY
Passage d'une base en binaire.
@SYNTAXE = Syntaxe : adr_base BINARY
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BINARY  ( adr_base --- )
  2 SWAP !
;

 HERALD
Affiche la banniŠre du systŠme.
Au d‚part, vectoris‚ par BOOT.
@SYNTAXE = Syntaxe : HERALD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : HERALD  ( --- )
  ATTRIBUTS @ ATTRIBUTS ON
  ATTOFF DARK
  BOLD
  ." +-------------------------------------+" CR
  ." |        PGFORTH  Version 1.00        |" CR
  ." |-------------------------------------|" CR
  ." |       Auteur :  P.Guillaumaud       |" CR
  ." +-------------------------------------+" CR
  CR
  ATTOFF
  ATTRIBUTS !
;

 AT
Positionnement du curseur … l'‚cran.
@SYNTAXE = Syntaxe : colonne ligne AT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE AT  ( colonne ligne --- )
  AX POP
  DX POP
  AL DH MOV
  BH BH XOR
  2 # AH MOV
  16 INT
  NEXT
END-CODE

 (.")
Primitive.
Partie ‚x‚cution du mot .".
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (.")
  R>> COUNT 2DUP +
  EVEN >>R TYPE
;

 D.2
Affichage d'un nombre cadr‚ sur 2 caractŠres.
Utilis‚ par le mot DUMP.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D.2
  BOUNDS
  ?DO
    SEGMENT>> @ I LC@ 0
    <<# # # #>> TYPE SPACE
  LOOP
;

 (INCLUDE)
Primitive.
  ‚x‚cution d'une s‚quence de mots FORTH, provenants
  d'un fichier de texte, dont le handler est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : handle (INCLUDE)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (INCLUDE)  ( handle --- )
  HANDLE @ >>R  >>IN @ >>R  ( Sauvegarde du contexte actuel )
  HANDLE !
  BEGIN
    GETLINE
    >>IN OFF RUN            ( Interpr‚tation de la ligne lue )
    EOF? @
  UNTIL                     ( jusqu'… la fin du fichier )
  CLOSE
  R>> >>IN ! R>> HANDLE !   ( restitution du contexte )
;

 INCLUDE
Le mot INCLUDE sert … ‚x‚cuter une s‚quence de mots
Forth enregistr‚es dans un fichier de texte.
Le texte est interpr‚t‚ comme s'il ‚tait entr‚ au clavier.
Le fichier texte peut lui-mˆme contenir le mot INCLUDE, cette
imbrication pouvant s'‚tendre dans la limite de la pile de
retour.
@SYNTAXE = Syntaxe : INCLUDE [u:][chemin] Nom_fichier.ext
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : INCLUDE  ( adr_fichier --- )
  READ OPEN
  (INCLUDE)
;
IMMEDIATE

 (GETLINE)
Primitive.
Saisie une ligne de texte, termin‚ par CR, dans le fichier
num‚ro [handle] et la stocke … l'adresse [adresse].
A cette adresse se trouve une chaine standard, c'est … dire, 1
octet pour la
longueur de la chaine suivi de la chaine elle-mˆme. Si la
longueur de la chaine saisie d‚passe 255 octets, le fichier
n'est plus du texte, il est alors fini.
[eof] est vrai pour indiquer une fin de fichier.
Les caractŠres de contr“le (codes ASCII inf‚rieurs … 32) sont
remplac‚s par des espaces.
@SYNTAXE = Syntaxe : adresse handle (GETLINE)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (GETLINE)  ( adresse handle --- eof )
  BX POP
  DX POP
  DX DI MOV
  0 # 0 [DI] MOV     ( On initialise la longueur … 0 )
  BEGIN
    0 [DI] AL MOV
    255 # AL CMP     ( A-t'on lu 255 caractŠres ? )
    0=
    IF
      -1 # AX MOV
      1PUSH
    THEN
    DX INC
    1 # CX MOV
    63 # AH MOV
    33 INT
    U<<
    IF
      -1 # AX MOV
      1PUSH
    THEN
    CX AX CMP        ( Est-on … la fin du fichier ? )
    0<<>>
    IF
      -1 # AX MOV
      1PUSH
    THEN
    DI CX MOV
    DX DI MOV
    0 [DI] AL MOV
    AH AH SUB
    10 # AX CMP      ( Est-ce la fin de la ligne ? )
    0<<>>
  WHILE
    32 # AX CMP      ( Le caractŠre lu est-il un caractŠre de
contr“le ? )
    0<<
    IF
      32 # AL MOV    ( Oui, on le remplace par un espace )
      AL 0 [DI] MOV
    THEN
    CX DI MOV
    0 [DI] INC
  REPEAT
  AX AX XOR
  1PUSH
END-CODE

 GETLINE
Pour lire une ligne de texte dans le fichier courant.
La ligne est stock‚e dans le BUFFER courant. Le compteur de
ligne est incr‚ment‚ (avec LINE#).
Si la variable ECHO est ON la ligne est affich‚e … l'‚cran.
@SYNTAXE = Syntaxe : GETLINE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : GETLINE  ( --- )
  BUFFER HANDLE @
  (GETLINE) EOF? !
  ECHO @
  IF
    .LINE
  THEN
  LINE# 1+!
;

 .LINE
Affiche la ligne de texte qui vient d'ˆtre lue dans
le fichier courant (avec GETLINE).
@SYNTAXE = Syntaxe : .LINE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : .LINE  ( --- )
  BUFFER COUNT CR TYPE
;

 GET
Pour lire un caractŠre dans le fichier courant.
Le caractŠre est stock‚ dans le premier octet du BUFFER
courant.
@SYNTAXE = Syntaxe : GET
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : GET  ( --- )
  HANDLE @ 0=                 ( le handle 0 est le clavier )
  IF
    (KEY)
  ELSE
    BUFFER 1 HANDLE @ (GET)   ( lecture d'un caractŠre )
    0<<>>
    IF
      DROP EOF 13
    ELSE
      1 =
      IF
        BUFFER C@
      ELSE
        EOF 13
      THEN
    THEN
  THEN
;

 OPEN
Ouverture d'un fichier.
Le num‚ro (handle) du fichier est renvoy‚ sur la pile.
@SYNTAXE = Syntaxe : mode OPEN [u:][chemin] Nom_fichier.ext
'mode' est le mode d'accŠs du fichier … ouvrir.
On peut utiliser les trois constantes pr‚d‚finies suivantes :
READ       : Ouverture du fichier en lecture seulement
WRITE      : Ouverture du fichier en ‚criture seulement
READ-WRITE : Ouverture du fichier en lecture et/ou ‚criture
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : OPEN ( mode adr_fichier --- handle )
  ?OPEN ASCII0
  SWAP (OPEN) ?DOSERR
  HANDLE @ >>R          ( sauvegarde du handle courant )
  HANDLE ! BUFFER OFF
  'WORD PATHNAME!       ( sauvegarde du nom du fichier )
  LINE# OFF
  HANDLE @ R>> HANDLE !
;

 ?OPEN
Avant une ouverture de fichier, ?OPEN contr“le le
nombre de fichiers ouverts.
Si le nombre est trop important, l'interprŠteur ABORT avec
le message " Trop de fichiers ouverts ".
@SYNTAXE = Syntaxe : ?OPEN
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?OPEN  ( --- )
  #FILES 1- FILES
  = ABORT" Trop de fichiers ouverts"
;

 PATHNAME
Renvoi l'adresse du nom du fichier courant.
@SYNTAXE = Syntaxe : PATHNAME
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : PATHNAME  ( --- adr )
  BUFFER LBUF +
;

 PATHNAME!
Stocke une chaine de caractŠre dans le PATHNAME
courant.
L'ancien PATHNAME est d'abord mis … BLANK.
@SYNTAXE = Syntaxe : adr_chaine PATHNAME!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : PATHNAME!  ( adr_chaine --- )
  PATHNAME DUP C/PATH ERASE
  OVER C@ 1+ C/PATH MIN CMOVE
;

 ALLCLOSE
Ferme tous les fichiers ouverts, sauf les 5 fichiers
standards ouverts par le systŠme DOS.
@SYNTAXE = Syntaxe : ALLCLOSE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ALLCLOSE  ( --- )
  FILES 1+ 5
  DO
    I (CLOSE)
  LOOP
;

 CLOSE
Ferme le fichier courant, dont le handler est contenu
dans la variable HANDLE.
@SYNTAXE = Syntaxe : CLOSE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CLOSE  ( --- )
  HANDLE @ (CLOSE)
  EOF? OFF
;

 DEL
Efface un ou plusieurs fichier.
@SYNTAXE = Syntaxe : DEL [u:][chemin] Nom_fichier.ext
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DEL ( adr_fichier --- )
  ASCII0
  65 DOS ?DOSERR
;

 CHDIR
Changement de r‚pertoire courant.
@SYNTAXE = Syntaxe : CHDIR [u:] chemin
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CHDIR  ( adr_chemin --- )
  ASCII0
  59 DOS ?DOSERR
;

 RMDIR
Suppression d'un r‚pertoire vide.
@SYNTAXE = Syntaxe : RMDIR [u:] chemin
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : RMDIR  ( adr_chemin --- )
  ASCII0
  58 DOS ?DOSERR
;

 MKDIR
Cr‚ation d'un r‚pertoire.
@SYNTAXE = Syntaxe : MKDIR [u:] chemin
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : MKDIR  ( adr_chemin --- )
  ASCII0
  57 DOS ?DOSERR
;

 DRIVE?
Renvoi le num‚ro de l'unit‚ courante.
Le code renvoy‚ est ‚gal … 0 pour le lecteur A:,
1 pour le lecteur B:, 2 pour le lecteur C:, etc...
@SYNTAXE = Syntaxe : DRIVE?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE DRIVE?  ( --- nødrv )
  25 # AH MOV
  33 INT
  AH AH SUB
  1PUSH
END-CODE

 GET-DTA
Renvoi l'adresse de la zone DTA, utilis‚e pour les
accŠs disque.
@SYNTAXE = Syntaxe : GET-DTA
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE GET-DTA  ( --- adr )
  47 # AH MOV
  33 INT
  BX PUSH
  NEXT
END-CODE

 SET-DTA
Fixe l'adresse de la zone DTA, utilisable pour les
accŠs disque.
@SYNTAXE = Syntaxe : adresse_dta SET-DTA
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE SET-DTA  ( adr --- )
  DX POP
  26 # AH MOV
  33 INT
  NEXT
END-CODE

 LINE#
Renvoi le num‚ro de la ligne lue dans le fichier
courant.
@SYNTAXE = Syntaxe : LINE#
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : LINE#  ( --- n )
  PATHNAME C/PATH +
;

 BUFFER
Renvoi la zone de 256 octets o— sont stock‚es les
donn‚es re‡ue ou … envoyer vers le fichier courant.
@SYNTAXE = Syntaxe : BUFFER
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BUFFER  ( --- adr )
  LBUF C/PATH + 2+
  HANDLE @ * BUFFERS +
;

 EOF
Provoque artificiellement la fin du fichier courant.
Permet, entre autre, de commenter abondament un source.
@SYNTAXE = Syntaxe : EOF
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : EOF  ( --- )
  EOF? ON
;

 A:
initialise A comme le lecteur courant.
@SYNTAXE = Syntaxe : A:
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : A:  ( --- )
  1 SELECT
;

 B:
initialise B comme le lecteur courant.
@SYNTAXE = Syntaxe : B:
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : B:  ( --- )
  2 SELECT
;

 C:
initialise C comme le lecteur courant.
@SYNTAXE = Syntaxe : C:
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : C:  ( --- )
  3 SELECT
;

 D:
initialise D comme le lecteur courant.
@SYNTAXE = Syntaxe : D:
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D:  ( --- )
  4 SELECT
;

 E:
initialise E comme le lecteur courant.
@SYNTAXE = Syntaxe : E:
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : E:  ( --- )
  5 SELECT
;

 SELECT
S‚lection d'une unit‚ de disque.
@SYNTAXE = Syntaxe : nødrv SELECT
nødrv = 0 pour le lecteur A, 1 pour le lecteur B,
etc...
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SELECT  ( nødrv --- )
  1- 14 DOS ?DOSERR
;

 ?DOSERR
Si le nombre pr‚sent sur la pile est sup‚rieur …
z‚ro,
c'est un num‚ro d'erreur de fonction DOS et l'interprŠteur
ABORT avec le message correspondant.
@SYNTAXE = Syntaxe : flag ?DOSERR
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?DOSERR  ( flag --- )
  ?DUP
  IF
    'WORD COUNT 2DUP UPPER
    BOLD TYPE SPACE
    1- 35 MIN 50 * ERRMSG +
    COUNT TYPE ATTOFF ABORT
  THEN
;

 DOS
Appel simple d'une fonction de l'interruption 21h.
Le num‚ro de fonction est charg‚ dans le registre AH et
l'argument est
charg‚ dans le registre DX avant l'appel de l'interruption.
Le code de retour de l'interruption est un num‚ro d'erreur.
DOS est utilis‚ pour les entr‚es/sorties vers les fichiers.
@SYNTAXE = Syntaxe : argument nøfonction DOS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE DOS  ( arg fon --- flag )
  AX POP
  AL AH MOV
  DX POP
  33 INT
  U>>=
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … z‚ro, pas d'erreur )
  THEN
  1PUSH
END-CODE

 (SEEK)
AccŠs direct dans un fichier par modification du
pointeur.
@SYNTAXE = Syntaxe : d‚pl_d handle mode (SEEK)
d‚pl_d est le d‚placement du pointeur (entier
double).
handle est le num‚ro du fichier.
mode   d‚termine le type de d‚placement:
  0 : d‚placement … partir du d‚but de fichier.
  1 : d‚placement … partir de la position courante.
  2 : d‚placement … partir de la fin de fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (SEEK)  ( d‚pl_d handle mode --- pos_d code )
  AX POP
  BX POP
  CX POP
  DX POP
  66 # AH MOV
  33 INT
  AX PUSH
  DX PUSH
  U>>=
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … z‚ro, pas d'erreur )
  THEN
  1PUSH
END-CODE
Informations renvoy‚es :
pos_d est la nouvelle position du pointeur (entier double).
code  est le code d'erreur :
  0 : pas d'erreur.
  6 : num‚ro de fichier invalide.

 (FREE)
Renvoi des informations concernant l'espace
disponible sur un disque.
@SYNTAXE = Syntaxe : nødrv (FREE)
nødrv est le num‚ro d'unit‚; 0=unit‚ courante, 1=A:,
etc...
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (FREE)  ( nødrv --- clu sec/clu oct/sec )
  DX POP
  54 # AH MOV
  33 INT
  U<<
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … un, alors erreur )
    1PUSH
  THEN
  BX PUSH
  AX PUSH
  CX PUSH
  NEXT
END-CODE
Informations renvoy‚es :
clu     est le nombre de clusters libres.
sec/clu est le nombre de secteurs par cluster.
oct/sec est le nombre d'octets par secteur.

 (SEARCH0)
Recherche dans un r‚pertoire le premier fichier
correspondant … un nom g‚n‚rique et … un attribut.
Le nom g‚n‚rique peut contenir des sp‚cifications
d'unit‚ et de r‚pertoire et les traditionels jokers
de recherche "*" et "?".
@SYNTAXE = Syntaxe : adr attribut (SEARCH0)
adr      est l'adresse de la chaine ASCII0 du nom
g‚n‚rique.
attribut est l'atribut de recherche :
  XXXXXXXX      - Nombre binaire (6 bits significatifs)
    ::::::
    :::::+->>  0 - Fichier ne pouvant ˆtre que lu donc
    :::::         non modifiable et non effa‡able.
    :::::
    ::::+-->>  1 - Fichier invisible avec la commande DIR.
    ::::
    :::+--->>  2 - Fichier systeme, invisible avec la commande
DIR.
    :::
    ::+---->>  3 - Fichier contenant le nom du volume dans
    ::            ses onze premier octets.
    ::
    :+----->>  4 - Entr‚e d'un r‚pertoire.
    :
    +------>>  5 - Fichier modifi‚ et ferm‚ (archivage).
L'attributs 0 d‚signe un fichier normal.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (SEARCH0)  ( adr attribut --- flag )
  CX POP
  DX POP
  78 # AH MOV
  33 INT
  -1 # AX MOV
  U<<
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … un, fichier trouv‚ )
  THEN
  1PUSH
END-CODE
flag est vrai si un fichier … ‚t‚ trouv‚.

 (SEARCH)
Poursuite de la recherche commenc‚e par (SEARCH0).
@SYNTAXE = Syntaxe : (SEARCH)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (SEARCH)  ( --- flag )
  79 # AH MOV
  33 INT
  -1 # AX MOV
  U<<
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … un, fichier trouv‚ )
  THEN
  1PUSH
END-CODE

 (REN)
Primitive de changement de nom et/ou de d‚placement
d'un fichier.
@SYNTAXE = Syntaxe : adr_src adr_dest (REN)
adr_src  est l'adresse de la chaine ASCII0 du fichier
source.
adr_dest est l'adresse de la chaine ASCII0 du fichier
destination.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (REN)  ( adr_src adr_dest --- code )
  DI POP
  DX POP
  DS AX MOV
  AX ES MOV
  86 # AH MOV
  33 INT
  U>>=
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … z‚ro, pas d'erreur )
  THEN
  1PUSH
END-CODE
code est le code d'erreur renvoy‚ :
  0 : pas d'erreur.
  3 : chemin introuvable.
  5 : accŠs refus‚.
 17 : pas la mˆme unit‚.

 (OPEN)
Primitive d'ouverture d'un fichier.
Utilis‚e, entre autre, par OPEN.
@SYNTAXE = Syntaxe : adr_fic mode (OPEN)
adr_fic est l'adresse de la chaine ASCII0 du nom du
fichier.
mode    est le mode d'accŠs du fichier … ouvrir.
On peut utiliser les trois constantes pr‚d‚finies suivantes :
READ       : Ouverture du fichier en lecture seulement
WRITE      : Ouverture du fichier en ‚criture seulement
READ-WRITE : Ouverture du fichier en lecture et/ou ‚criture
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (OPEN)  ( adr_fic mode --- handle flag )
  AX POP
  DX POP
  61 # AH MOV
  33 INT
  AX PUSH
  U>>=
  IF
    0 # AX MOV              ( Si le 'Carry flag' est … z‚ro,
pas d'erreur )
    ' #FILES >>BODY # BX MOV
    1 # 0 [BX] ADD          ( Un fichier ouvert de plus )
  THEN
  1PUSH
END-CODE
Informations renvoy‚es :
handle est le num‚ro du fichier ouvert ou un code d'erreur si
flag est diff‚rent de z‚ro :
  2 : fichier introuvable.
  4 : trop de fichiers ouverts.
  5 : accŠs refus‚.
 12 : mode d'accŠs invalide.

 (MAKE)
Primitive de cr‚ation d'un fichier.
Si le fichier est d‚j… existant, il est ‚cras‚.
@SYNTAXE = Syntaxe : adr_fic attribut (MAKE)
adr_fic est l'adresse de la chaine ASCII0 du nom du
fichier.
attribut est l'atribut du fichier cr‚‚ :
  XXXXXXXX      - Nombre binaire (6 bits significatifs)
    ::::::
    :::::+->>  0 - Fichier ne pouvant ˆtre que lu donc
    :::::          non modifiable et non effa‡able.
    :::::
    ::::+-->>  1 - Fichier invisible avec la commande DIR.
    ::::
    :::+--->>  2 - Fichier systeme, invisible avec la commande
DIR.
    :::
    ::+---->>  3 - Fichier contenant le nom du volume dans
    ::            ses onze premier octets.
    ::
    :+----->>  4 - Entr‚e d'un r‚pertoire.
    :
    +------>>  5 - Fichier modifi‚ et ferm‚ (archivage).
L'attributs 0 d‚signe un fichier normal.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (MAKE)  ( adr_fic attribut --- hdl flag )
  CX POP
  DX POP
  60 # AH MOV
  33 INT
  AX PUSH
  U>>=
  IF
    0 # AX MOV              ( Si le 'Carry flag' est … z‚ro,
pas d'erreur )
    ' #FILES >>BODY # BX MOV
    1 # 0 [BX] ADD          ( Un fichier ouvert de plus )
  THEN
  1PUSH
END-CODE
Informations renvoy‚es :
hdl est le num‚ro du fichier cr‚‚ ou un code d'erreur
si flag est diff‚rent de z‚ro :
  4 : trop de fichiers ouverts.
  5 : accŠs refus‚.
 12 : mode d'accŠs invalide.

 (CLOSE)
Primitive de fermeture d'un fichier.
@SYNTAXE = Syntaxe : handle (CLOSE)
handle est le num‚ro du fichier … fermer.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (CLOSE)
  BX POP
  62 # AH MOV
  33 INT
  ' #FILES >>BODY # BX MOV
  0 [BX] AX MOV
  5 # AX CMP
  >>
  IF
    1 # 0 [BX] SUB    ( Un fichier ouvert de moins )
  THEN
  NEXT
END-CODE

 (PUT)
Primitive d'‚criture d'une chaine dans un fichier.
@SYNTAXE = Syntaxe : seg_buf off_buf long handle (PUT)
seg_buf est l'adresse de segment de la chaine.
off_buf est l'adresse d'offset de la chaine.
long    est la longueur de la chaine.
handle  est le num‚ro du fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (PUT)  ( seg_buf off_buf long handle ---
lon/err flag )
  DS AX MOV
  AX ES MOV
  BX POP
  CX POP
  DX POP
  DS POP
  64 # AH MOV
  33 INT
  AX PUSH
  ES BX MOV
  BX DS MOV
  U>>=
  IF
    0 # AX MOV ( Si le 'Carry flag' est … z‚ro, pas d'erreur )
  THEN
  1PUSH
END-CODE
Informations renvoy‚es :
lon/err est le nombre d'octets ‚crits ou un code d'erreur
si flag est diff‚rent de z‚ro :
  5 : accŠs refus‚.
  6 : num‚ro de fichier invalide.

 (GET)
Primitive de lecture d'une chaine dans un fichier.
@SYNTAXE = Syntaxe : seg_buf off_buf long handle (GET)
seg_buf est l'adresse de segment de la chaine.
off_buf est l'adresse d'offset de la chaine.
long    est la longueur de la chaine.
handle  est le num‚ro du fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (GET)  ( seg_buf off_buf long handle ---
lon/err flag )
  DS AX MOV
  AX ES MOV
  BX POP
  CX POP
  DX POP
  DS POP
  63 # AH MOV
  33 INT
  AX PUSH
  ES BX MOV
  BX DS MOV
  U>>=
  IF
    0 # AX MOV ( Si le 'Carry flag' est … z‚ro, pas d'erreur )
  THEN
  1PUSH
END-CODE
Informations renvoy‚es :
lon/err est le nombre d'octets ‚crits ou un code d'erreur
si flag est diff‚rent de z‚ro :
  5 : accŠs refus‚.
  6 : num‚ro de fichier invalide.

 STARTUP
Inclusion automatique d'un ‚ventuel fichier STARTUP.
Si un fichier dont le nom est stock‚ dans la variable STARTUP-
FILE existe dans le r‚pertoire courant,
il est inclu automatiquement au d‚marrage de PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : STARTUP
  STARTUP-FILE DROP
  READ (OPEN) 0=    ( Le fichier STARTUP existe-t'il ? )
  IF
    (INCLUDE)       ( Oui, inclusion de celui-ci )
  ELSE
    DROP
  THEN
;

 IFNDEF
Directive.
Permet l'‚x‚cution conditionnelle d'une s‚quence de mots FORTH,
pendant l'inclusion d'un fichier.
@SYNTAXE = Syntaxe : IFNDEF nom_mot commandes...
Si le mot <<nom_mot>> n'existe pas dans le
dictionnaire, les <<commandes>> seront ‚x‚cut‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : IFNDEF  ( nom_mot commandes --- )
  DEFINED NIP
  IF
    [COMPILE] \
  THEN
;
IMMEDIATE

 IFDEF
Directive.
Permet l'‚x‚cution conditionnelle d'une s‚quence de mots FORTH,
pendant l'inclusion d'un fichier.
@SYNTAXE = Syntaxe : IFDEF nom_mot commandes...
Si le mot <<nom_mot>> existe dans le dictionnaire,
les <<commandes>> seront ‚x‚cut‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : IFDEF  ( nom_mot commandes --- )
  DEFINED NIP 0=
  IF
    [COMPILE] \
  THEN
;
IMMEDIATE

 'BUFFER
Empile l'adresse du buffer du fichier dont le handler
est sur la pile de donn‚es.
@SYNTAXE = Syntaxe : handle 'BUFFER
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : 'BUFFER  ( handle --- adr )
  LBUF C/PATH + 2+ * BUFFERS +
;

 HDR!
Primitive.
G‚n‚ration d'un entˆte de fichier ‚x‚cutable.
Utilis‚e par le mot SAVE-SYSTEM.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
: HDR!
  4D EXEHDR C!               ( Obligatoire pour fichier exe )
  5A EXEHDR 1+ C!            ( Obligatoire pour fichier exe )
  HERE 0FF AND EXEHDR 2+ !   ( Calcul de la taille du fichier )
  HERE 200 / 2+ EXEHDR 4 + !
  01    EXEHDR 6 + C!        ( Nombre d'entr‚es relogeables )
  20    EXEHDR 8 + C!        ( Taille de l'entˆte en
paragraphes )
  0001  EXEHDR 0A + !        ( Nombre de paragraphes minimum
requis par le fichier )
  3000  EXEHDR 0C + !        ( Nombre de paragraphes maximum
requis par le fichier )
  ENTRY EXEHDR 14 + !        ( Adresse du point d'entr‚e
initial )
  22    EXEHDR 18 + C!       ( Adresse de la table de
relocation )
  1     EXEHDR 1C + C!
  20FB  EXEHDR 1E + !
  6A72  EXEHDR 20 + !
  CODE-REF 1+ EXEHDR 22 + !  ( adresse de la r‚f‚rence
relogeable )
;
IBASE DECIMAL

 SAVE-SYSTEM
Sauvegarde du systŠme PGForth, sous forme d'un
fichier ‚x‚cutable.
@SYNTAXE = Syntaxe : SAVE-SYSTEM fichier_dest.ext
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SAVE-SYSTEM ( <<fichier_dest.ext>> )
  EXEHDR 512 ERASE
  HDR!
  ?OPEN ASCII0 0 (MAKE) ?DOSERR >>R
  DSEGMENT EXEHDR 512 R@ (PUT) ?DOSERR DROP
  R>>
  DSEGMENT
  CODE-REF 1+ DUP @ >>R OFF
  HANDLE DUP @ >>R OFF
  OVER 0 SWAP HERE SWAP (PUT) ?DOSERR DROP
  R>> HANDLE !
  R>> CODE-REF 1+ !
  (CLOSE)
;

 COMP
Comparaison de chaines de caractŠres, avec
diff‚renciation
entre majuscules et minuscules.
@SYNTAXE = Syntaxe : adr_chaine1 adr_chaine2 longueur COMP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = LABEL NOMORE
  DX SI MOV
  CX PUSH
  NEXT

CODE COMP  ( adr_chaine1 adr_chaine2 longueur --- flag )
  SI DX MOV
  CX POP
  DI POP
  SI POP
  NOMORE JCXZ
  DS AX MOV
  AX ES MOV
  REPZ BYTE CMPS
  NOMORE JE

LABEL MISMATCH
  0<<
  IF
    -1 # CX MOV
  ELSE
    1 # CX MOV
  THEN
  NOMORE #) JMP
END-CODE
Signification du flag renvoy‚ :
0  : chaine1 = chaine2
1  : chaine1 << chaine2
-1 : chaine1 >> chaine2

 CAPS-COMP
Comparaison de chaines de caractŠres, aprŠs
conversion de
celles-ci en majuscules.
@SYNTAXE = Syntaxe : adr_chaine1 adr_chaine2 longueur CAPS-COMP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE CAPS-COMP  ( adr_chaine1 adr_chaine2 longueur
--- flag )
  SI DX MOV
  CX POP
  DI POP
  SI POP
  BEGIN
    NOMORE JCXZ
    0 [SI] AL MOV
    >>UPPER #) CALL
    SI INC
    AL AH MOV
    0 [DI] AL MOV
    >>UPPER #) CALL
    DI INC
    AL AH CMP
    MISMATCH JNE
    CX DEC
  AGAIN
END-CODE
Signification du flag renvoy‚ :
0  : chaine1 = chaine2
1  : chaine1 << chaine2
-1 : chaine1 >> chaine2

 COMPARE
Comparaison de chaines.
@SYNTAXE = Syntaxe : adr_chaine1 adr_chaine2 long COMPARE
Compare la chaine stock‚e … adr_chaine1 avec la
chaine stock‚e
… adr_chaine2, sur la longueur long.
Si la variable CAPS est … ON, les chaines sont converties
en majuscules.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : COMPARE  ( adr_chaine1 adr_chaine2 long --- flag
)
  CAPS @
  IF
    CAPS-COMP
  ELSE
    COMP
  THEN
;
Signification du flag renvoy‚ :
0  : chaine1 = chaine2
1  : chaine1 << chaine2
-1 : chaine1 >> chaine2

 DU<<
Comparaison de deux nombres double non sign‚s.
@SYNTAXE = Syntaxe : ud1 ud2 DU<<
Empile un flag VRAI si ud1 est inf‚rieur … ud2.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DU<<  ( ud1 ud2 --- flag )
  ROT SWAP 2DUP U<<
  IF
    2DROP 2DROP
    TRUE
  ELSE
    <<>>
    IF
      2DROP FALSE
    ELSE
      U<<
    THEN
  THEN
;

 D<<
Comparaison de deux entiers doubles.
@SYNTAXE = Syntaxe : d1 d2 D<<
Renvoi un flag VRAI si d1 est inf‚rieur … d2.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D<<  ( d1 d2 --- flag )
  2 PICK OVER =
  IF
    DU<<
  ELSE
    NIP ROT DROP
    <<
  THEN
;

 D>>
Comparaison de deux entiers doubles.
@SYNTAXE = Syntaxe : d1 d2 D>>
Renvoi un flag VRAI si d1 est sup‚rieur … d2.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D>>  ( d1 d2 --- flag )
  2SWAP D<<
;

 D=
Comparaison de deux entiers doubles.
@SYNTAXE = Syntaxe : d1 d2 D=
Renvoi un flag VRAI si d1 et d2 sont ‚gaux.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D=  ( d1 d2 --- flag )
  D- D0=
;

 D0=
Comparaison d'un entier double.
@SYNTAXE = Syntaxe : d D0=
Renvoi un flag VRAI si d est ‚gal … z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D0=  ( d --- flag )
  OR 0=
;

 D0<<>>
Comparaison d'un entier double.
@SYNTAXE = Syntaxe : d D0<<>>
Renvoi un flag VRAI si d est diff‚rent de z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D0<<>>  ( d --- flag )
  D0= NOT
;

 D0>>
Comparaison d'un entier double.
@SYNTAXE = Syntaxe : d D0>>
Renvoi un flag VRAI si d est sup‚rieur … z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D0>>  ( d --- flag )
  OR 0>>
;

 D0<<
Comparaison d'un entier double.
@SYNTAXE = Syntaxe : d D0<<
Renvoi un flag VRAI si d est inf‚rieur … z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D0<<  ( d --- flag )
  OR 0<<
;

 D0>>=
Comparaison d'un entier double.
@SYNTAXE = Syntaxe : d D0>>=
Renvoi un flag VRAI si d est sup‚rieur ou ‚gal …
z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D0>>=  ( d --- flag )
  D0<< NOT
;

 D0<<=
Comparaison d'un entier double.
@SYNTAXE = Syntaxe : d D0<<=
Renvoi un flag VRAI si d est inf‚rieur ou ‚gal …
z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D0<<=  ( d --- flag )
  D0>> NOT
;

 D<<=
Comparaison de deux entiers doubles.
@SYNTAXE = Syntaxe : d1 d2 D<<=
Renvoi un flag VRAI si d1 est inf‚rieur ou ‚gal … d2.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D<<=  ( d1 d2 --- flag )
  D>> NOT
;

 D>>=
Comparaison de deux entiers doubles.
@SYNTAXE = Syntaxe : d1 d2 D>>=
Renvoi un flag VRAI si d1 est sup‚rieur ou ‚gal … d2.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D>>=  ( d1 d2 --- flag )
  D<< NOT
;

 D<<>>
Comparaison de deux entiers doubles.
@SYNTAXE = Syntaxe : d1 d2 D<<>>
Renvoi un flag VRAI si d1 et d2 sont diff‚rents.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D<<>>  ( d1 d2 --- flag )
  D= NOT
;

 BETWEEN
Teste d'inclusion entre deux bornes.
@SYNTAXE = Syntaxe : n1 n2 n3 BETWEEN
Empile un flag VRAI si n1 est compris entre n2
(inclus) et n3 (inclus).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BETWEEN  ( n1 n2 n3 --- flag )
  >>R OVER >>
  SWAP R>> >>
  OR NOT
;

 WITHIN
Teste d'inclusion entre deux bornes.
@SYNTAXE = Syntaxe : n1 n2 n3 WITHIN
Empile un flag VRAI si n1 est compris entre n2
(inclus) et n3 (exclus).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : WITHIN
  1- BETWEEN
;

 >>
Comparaison de deux entiers simples.
@SYNTAXE = Syntaxe : n1 n2 >>
Empile un flag VRAI si n1 est sup‚rieur … n2.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = LABEL YES
  -1 # AX MOV
  1PUSH

LABEL NO
  AX AX XOR
  1PUSH

CODE >>  ( n1 n2 --- flag )
  AX POP
  BX POP
  AX BX CMP
  YES JG
  NO #) JMP
END-CODE

 <<
Comparaison de deux entiers simples.
@SYNTAXE = Syntaxe : n1 n2 <<
Empile un flag VRAI si n1 est inf‚rieur … n2.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE <<  ( n1 n2 --- flag )
  AX POP
  BX POP
  AX BX CMP
  YES JL
  NO #) JMP
END-CODE

 U>>
Comparaison de deux entiers sign‚s.
@SYNTAXE = Syntaxe : u1 u2 U>>
Empile un flag VRAI si u1 est sup‚rieur … u2.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE U>>  ( u1 u2 --- flag)
  AX POP
  BX POP
  AX BX CMP
  NO JB
  YES #) JMP
END-CODE

 U<<
Comparaison de deux entiers sign‚s.
@SYNTAXE = Syntaxe : u1 u2 U<<
Empile un flag VRAI si u1 est inf‚rieur … u2.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE U<<  ( u1 u2 --- flag )
  AX POP
  BX POP
  AX BX CMP
  YES JB
  NO #) JMP
END-CODE

 <<>>
Comparaison de deux entiers simples.
@SYNTAXE = Syntaxe : n1 n2 <<>>
Empile un flag VRAI si n1 est diff‚rent de n2.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE <<>>  ( n1 n2 --- flag )
  AX POP
  BX POP
  AX BX CMP
  NO JE
  YES #) JMP
END-CODE

 0<<>>
Comparaison d'un entier simple.
@SYNTAXE = Syntaxe : n 0<<>>
Empile un flag VRAI si n est diff‚rent de z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 0<<>>  ( n --- flag )
  AX POP
  AX AX OR
  YES JNE
  NO #) JMP
END-CODE

 0>>
Comparaison d'un entier simple.
@SYNTAXE = Syntaxe : n 0>>
Empile un flag VRAI si n est sup‚rieur … z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = LABEL YES ( Red‚finition des deux labels pour
‚viter )
  -1 # AX MOV  ( les branchements hors limites )
  1PUSH

LABEL NO
  AX AX XOR
  1PUSH

CODE 0>>  ( n --- flag )
  AX POP
  AX AX OR
  YES JG
  NO #) JMP
END-CODE

 0<<
Comparaison d'un entier simple.
@SYNTAXE = Syntaxe : n 0<<
Empile un flag VRAI si n est inf‚rieur … z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 0<<  ( n --- flag )
  AX POP
  AX AX OR
  YES JS
  NO #) JMP
END-CODE

 0=
Comparaison d'un entier simple.
@SYNTAXE = Syntaxe : n 0=
Empile un flag VRAI si n est ‚gal … z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 0=  ( n --- flag )
  AX POP
  AX AX OR
  YES JE
  NO #) JMP
END-CODE

 =
Comparaison de deux entiers simples.
@SYNTAXE = Syntaxe : n1 n2 =
Empile un flag VRAI si n1 et n2 sont ‚gaux.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE =  ( n1 n2 --- )
  AX POP
  BX POP
  AX BX CMP
  YES JE
  NO #) JMP
END-CODE

 >>=
Comparaison de deux nombres simples.
@SYNTAXE = Syntaxe : n1 n2 >>=
Empile un flag VRAI si n2 est sup‚rieur ou ‚gal … n1.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : >>=  ( n1 n2 --- flag )
  << NOT
;

 <<=
Comparaison de deux nombres simples.
@SYNTAXE = Syntaxe : n1 n2 <<=
Empile un flag VRAI si n2 est inf‚rieur ou ‚gal … n1.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : <<=  ( n1 n2 --- flag )
  >> NOT
;

 U>>=
Comparaison de deux nombres simples non sign‚s.
@SYNTAXE = Syntaxe : un1 un2 U>>=
Empile un flag VRAI si un2 est sup‚rieur ou ‚gal …
un1.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : U>>=  ( un1 un2 --- flag )
  U<< NOT
;

 U<<=
Comparaison de deux nombres simples non sign‚s.
@SYNTAXE = Syntaxe : un1 un2 U<<=
Empile un flag VRAI si un2 est inf‚rieur ou ‚gal …
un1.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : U<<=  ( un1 un2 --- flag )
  U>> NOT
;

 0>>=
Comparaison d'un nombre simple.
@SYNTAXE = Syntaxe : n 0>>=
Empile un flag VRAI si n est sup‚rieur ou ‚gal …
z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : 0>>=  ( n --- flag )
  0<< NOT
;

 0<<=
Comparaison d'un nombre simple.
@SYNTAXE = Syntaxe : n 0<<=
Empile un flag VRAI si n est inf‚rieur ou ‚gal …
z‚ro.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : 0<<=  ( n --- flag )
  0>> NOT
;

 STOP?
Test du clavier.
@SYNTAXE = Syntaxe : STOP?
Empile un flag VRAI si la touche appuy‚e est le
retour
chariot (code ASCII 13).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : STOP? ( --- f )
  FALSE KEY?
  IF
    DROP KEY DROP KEY 13 =
  THEN
;

 NOT
Effectue un NON logique bit … bit sur le nombre situ‚
au sommet de la pile de donn‚es.
@SYNTAXE = Syntaxe : n NOT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE NOT  ( n --- n )
  AX POP
  AX NOT
  1PUSH
END-CODE

 XOR
Effectue un OU EXCLUSIF bit … bit entre les deux
premiers nombres de la pile de donn‚es.
@SYNTAXE = Syntaxe : n1 n2 XOR
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE XOR  ( n1 n2 --- n3 )
  AX POP
  DX POP
  DX AX XOR
  1PUSH
END-CODE

 OR
Effectue un OU LOGIQUE bit … bit entre les deux
premiers nombres de la pile de donn‚es.
@SYNTAXE = Syntaxe : n1 n2 OR
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE OR  ( n1 n2 --- n3 )
  AX POP
  DX POP
  DX AX OR
  1PUSH
END-CODE

 AND
Effectue un ET LOGIQUE bit … bit entre les deux
premiers nombres de la pile de donn‚es.
@SYNTAXE = Syntaxe : n1 n2 AND
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE AND  ( n1 n2 --- n3 )
  AX POP
  DX POP
  DX AX AND
  1PUSH
END-CODE

 TRUE
Empile un flag VRAI.
@SYNTAXE = Syntaxe : TRUE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE TRUE  ( --- flag )
  -1 # AX MOV
  1PUSH
END-CODE

 FALSE
Empile un flag FAUX.
@SYNTAXE = Syntaxe : FALSE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE FALSE  ( --- flag )
  0 # AX MOV
  1PUSH
END-CODE

 IF ... [ELSE] ... THEN
emploi 1 :                emploi 2 :
IF                         IF
  commandes ...              commandes1 ...
THEN                       ELSE
                             commandes2 ...
                           THEN
Dans l'emploi 1, Les <<commandes>> sont ‚x‚cut‚es si
la condition est v‚rifi‚e (flag VRAI).
Dans l'emploi 2, les <<commandes1>> sont ‚x‚cut‚es si la
condition est v‚rifi‚e (flag VRAI),
les <<commandes2>> sont ‚x‚cut‚es si la condition n'aboutie pas
(flag FAUX).
@SYNTAXE = Syntaxe : condition IF commandes ... THEN
          condition IF commandes1 ... ELSE commandes2 THEN
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : IF  ( flag --- )
  COMPILE ?BRANCH
  ?>>MARK
;
IMMEDIATE

: THEN  ( --- )
  ?>>RESOLVE
;
IMMEDIATE

: ELSE  ( --- )
  COMPILE BRANCH
  ?>>MARK
  2SWAP ?>>RESOLVE
;
IMMEDIATE

 BEGIN ... AGAIN
Boucle infinie.
@SYNTAXE = Syntaxe : BEGIN commandes ... AGAIN
Les <<commandes>> se r‚pŠtent ‚ternellement.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BEGIN  ( --- )
  ?<<MARK
;
IMMEDIATE

: AGAIN  ( --- )
  COMPILE BRANCH
  ?<<RESOLVE
;
IMMEDIATE

 BEGIN ... ... UNTIL
Boucle … au moins un passage.
@SYNTAXE = Syntaxe : BEGIN commandes ... condition UNTIL
Les <<commandes>> sont ‚x‚cut‚es au moins une fois et
r‚p‚t‚es
jusqu'… ce que la <<condition>> n'aboutisse plus (flag FAUX).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : UNTIL  ( flag --- )
  COMPILE ?BRANCH
  ?<<RESOLVE
;
IMMEDIATE

 BEGIN .... WHILE ... REPEAT
Boucle conditionnelle.
@SYNTAXE = Syntaxe : BEGIN ... condition WHILE commandes ...
REPEAT
Les <<commandes>>, qui peuvent ne jamais s'‚x‚cuter,
sont r‚p‚t‚es
tant que la <<condition>> est v‚rifi‚e (flag VRAI).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : WHILE  ( flag --- )
  IF
;
IMMEDIATE

: REPEAT  ( --- )
  2SWAP AGAIN THEN
;
IMMEDIATE

 DO ... LOOP
Boucle It‚rative.
@SYNTAXE = Syntaxe : ind_fin ind_d‚but DO commandes ... LOOP
Les <<commandes>> sont r‚p‚t‚e (ind_fin - ind_deb)
fois.
L'indice de boucle est incr‚ment‚ … chaque tour par LOOP.
La boucle s'arrˆte quand l'indice qui vient d'ˆtre incr‚ment‚
est ‚gal … ind_fin.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DO  ( ind_fin ind_d‚but --- )
  COMPILE (DO)
  ?>>MARK
;
IMMEDIATE

: LOOP  ( --- )
  COMPILE (LOOP)
  2DUP 2+
  ?<<RESOLVE
  ?>>RESOLVE
;
IMMEDIATE

 DO ... +LOOP ( n --- )
Boucle It‚rative.
@SYNTAXE = Syntaxe : ind_fin ind_d‚but DO commandes ... n +LOOP
Les <<commandes>> sont r‚p‚t‚e (ind_fin - ind_deb)
fois.
Chaque tour, +LOOP ajoute n … l'indice de boucle.
n peut ˆtre n‚gatif auquel cas (ind_fin - ind_d‚but) doit ˆtre
n‚gatif.
La boucle s'arrˆte quand l'indice qui vient d'ˆtre modifi‚ est
sup‚rieur ou ‚gal … ind_fin.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : +LOOP  ( n --- )
  COMPILE (+LOOP)
  2DUP 2+
  ?<<RESOLVE
  ?>>RESOLVE
;
IMMEDIATE

 ?DO ... LOOP | +LOOP
Boucle It‚rative conditionnelle.
@SYNTAXE = Syntaxe : ind_fin ind_d‚but ?DO commandes ... LOOP
          ind_fin ind_d‚but ?DO commandes ... +LOOP
La boucle est ‚x‚cut‚e si ind_fin est diff‚rent de
ind_deb.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?DO  ( ind_fin ind_d‚but --- )
  COMPILE (?DO)
  ?>>MARK
;

 I
R‚cup‚ration de l'indice courant de la boucle de
niveau le plus interne.
@SYNTAXE = Syntaxe : DO ... I ... LOOP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE I  ( --- n )
  0 [RP] AX MOV
  2 [RP] AX ADD
  1PUSH
END-CODE

 J
R‚cup‚ration de l'indice de la boucle de niveau le
plus externe quand deux boucles sont imbriqu‚es.
@SYNTAXE = Syntaxe : DO ... DO ... J ... LOOP ... LOOP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE J  ( --- n )
  6 [RP] AX MOV
  8 [RP] AX ADD
  1PUSH
END-CODE

 K
R‚cup‚ration de l'indice de boucle de niveau le plus
externe quand trois boucles sont imbriqu‚es.
@SYNTAXE = Syntaxe : DO ... DO ... DO ... K ... LOOP ... LOOP
... LOOP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE K  ( --- n )
  12 [RP] AX MOV
  14 [RP] AX ADD
  1PUSH
END-CODE

 (LEAVE)
Primitive.
Utilis‚e par LEAVE.
Sortie inconditionnelle d'une boucle.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (LEAVE)
  4 # RP ADD
  0 [RP] IP MOV
  RP INC
  RP INC
  NEXT
END-CODE

 LEAVE
Termine la boucle (jusqu'… LOOP) et continu
l'‚x‚cution aprŠs LOOP.
@SYNTAXE = Syntaxe :  DO ... LEAVE ... LOOP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : LEAVE  ( --- )
  COMPILE (LEAVE)
;
IMMEDIATE

 (?LEAVE)
Primitive.
Utilis‚e par ?LEAVE.
Sortie conditionnelle d'une boucle.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (?LEAVE)
  AX POP
  AX AX OR
  ' (LEAVE) #) JNE
  NEXT
END-CODE

 ?LEAVE ( flag --- )
Sortie de boucle conditionnelle.
@SYNTAXE = Syntaxe : DO ... condition ?LEAVE ... LOOP
Termine la boucle et sort si la <<condition>> est
v‚rifi‚e (flag VRAI).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?LEAVE  ( flag --- )
  COMPILE (?LEAVE)
;
IMMEDIATE

 CASE  OF ... ENDOF ... ENDCASE
Branchements multiples.
@SYNTAXE = Syntaxe : condition CASE ... cas OF  commandes ...
ENDOF  ... ENDCASE
En fonction de la condition, un (ou aucun) des cas
est ‚x‚cut‚.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CASE  ( --- )
  CSP @ !CSP
;
IMMEDIATE

: OF  ( n1 n2 --- n )
  COMPILE OVER
  COMPILE =
  COMPILE ?BRANCH
  >>MARK
  COMPILE DROP
;
IMMEDIATE

: ENDOF  ( --- )
  COMPILE BRANCH
  >>MARK
  SWAP >>RESOLVE
;
IMMEDIATE

: ENDCASE  ( n --- )
  COMPILE DROP
  BEGIN
    SP@ CSP @ <<>>
  WHILE
    >>RESOLVE
  REPEAT
  CSP !
;
IMMEDIATE

 ?CSP
Effectue un contr“le de la profondeur de la pile de
donn‚es, en fin de compilation.
@SYNTAXE = Syntaxe : ?CSP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?CSP  ( --- )
  SP@ CSP @
  <<>> ABORT" Structures mal imbriqu‚es"
;

 !CSP
Sauvegarde de la profondeur actuelle de la pile de
donn‚es,
afin d'effectuer un contr“le en fin de compilation.
@SYNTAXE = Syntaxe : !CSP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : !CSP  ( --- )
  SP@ CSP !
;

 2ROT
Rotation des trois nombres double, situ‚s au sommet
de la pile de donn‚es.
@SYNTAXE = Syntaxe : d1 d2 d3 2ROT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : 2ROT  ( d1 d2 d3 --- d3 d2 d1 )
  5 ROLL 5 ROLL
;

 4DUP
Duplication des quatre nombres situ‚s au sommet de la
pile de donn‚es.
@SYNTAXE = Syntaxe : n1 n2 n3 n4 4DUP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : 4DUP  ( n1 n2 n3 n4 --- n1 n2 n3 n4 n1 n2 n3 n4
)
  2OVER 2OVER
;

 3DUP
Duplication des trois nombres situ‚s au sommet de la
pile de donn‚es.
@SYNTAXE = Syntaxe : n1 n2 n3 3DUP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 3DUP  ( n1 n2 n3 --- n1 n2 n3 n1 n2 n3 )
  AX POP
  DX POP
  BX POP
  BX PUSH
  DX PUSH
  AX PUSH
  BX PUSH
  2PUSH
END-CODE

 2OVER
Duplication de l'avant dernier nombre double de la
pile de donn‚es.
@SYNTAXE = Syntaxe : d1 d2 2OVER
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 2OVER  ( d1 d2 --- d1 d2 d1 )
  CX POP
  BX POP
  AX POP
  DX POP
  DX PUSH
  AX PUSH
  BX PUSH
  CX PUSH
  2PUSH
END-CODE

 2SWAP
Permutation des deux nombres double, situ‚s au sommet
de la pile de donn‚es.
@SYNTAXE = Syntaxe : d1 d2 2SWAP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 2SWAP  ( d1 d2 --- d2 d1 )
  CX POP
  BX POP
  AX POP
  DX POP
  BX PUSH
  CX PUSH
  2PUSH
END-CODE

 2DUP
Duplication du nombre double, situ‚ au sommet de la
pile de donn‚es.
@SYNTAXE = Syntaxe : d 2DUP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 2DUP  ( d --- d d )
  AX POP
  DX POP
  DX PUSH
  AX PUSH
  2PUSH
END-CODE

 2DROP
Suppression du nombre double, situ‚ au sommet de la
pile de donn‚es.
@SYNTAXE = Syntaxe : d 2DROP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 2DROP  ( d --- )
  AX POP
  AX POP
  NEXT
END-CODE

 R@
Copie le sommet de la pile de retour, au sommet de la
pile de donn‚es.
@SYNTAXE = Syntaxe : R@
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE R@  ( --- n )
  0 [RP] AX MOV
  1PUSH
END-CODE

 >>R
TransfŠre le nombre situ‚ au sommet de la pile de
donn‚es, au sommet de la pile de retour.
@SYNTAXE = Syntaxe : n >>R
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE >>R  ( n --- )
  AX POP
  RP DEC
  RP DEC
  AX 0 [RP] MOV
  NEXT
END-CODE

 R>>
TransfŠre le nombre situ‚ au sommet de la pile de
retour, au sommet de la pile de donn‚es.
@SYNTAXE = Syntaxe : R>>
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE R>>  ( --- n )
  0 [RP] AX MOV
  RP INC
  RP INC
  1PUSH
END-CODE

 FLIP
Permute les octets fort et faible du nombre situ‚ au
sommet de la pile de donn‚es.
@SYNTAXE = Syntaxe : n FLIP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE FLIP  ( n1 --- n2 )
  AX POP
  AL AH XCHG
  1PUSH
END-CODE

 NIP
Suppression de l'avant dernier nombre de la pile de
donn‚es.
@SYNTAXE = Syntaxe : n1 n2 NIP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE NIP  ( n1 n2 --- n2 )
  AX POP
  DX POP
  1PUSH
END-CODE

 TUCK
Duplique le nombre situ‚ au sommet de la pile de
donn‚es, sous les deux premiers nombres de celle-ci.
@SYNTAXE = Syntaxe : n1 n2 TUCK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE TUCK  ( n1 n2 --- n2 n1 n2 )
  AX POP
  DX POP
  AX PUSH
  2PUSH
END-CODE

 ROLL
Permutation des n premiers nombres de la pile de
donn‚es.
@SYNTAXE = Syntaxe : n1 ... ni n ROLL
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ROLL  ( n1 ... ni n --- ni ... n1 )
  >>R R@ PICK
  SP@ SSEGMENT SWAP
  2DUP 2+ R>> 1+ 2*
  LCMOVE>> DROP
;

 PICK
Duplication du niŠme nombre de la pile de donn‚es.
@SYNTAXE = Syntaxe : n1 ... ni n PICK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE PICK  ( n1 ... ni n --- n1 ... ni n1 )
  BX POP
  BX SHL
  SP BX ADD
  SS:
  0 [BX] AX MOV
  1PUSH
END-CODE

 -ROT
Rotation inverse des trois premiers nombre de la pile
de donn‚es.
@SYNTAXE = Syntaxe : n1 n2 n3 -ROT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE -ROT  ( n1 n2 n3 --- n3 n1 n2 )
  BX POP
  AX POP
  DX POP
  BX PUSH
  2PUSH
END-CODE

 ROT
Rotation des trois premiers nombres de la pile de
donn‚es.
@SYNTAXE = Syntaxe : n1 n2 n3 ROT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE ROT  ( n1 n2 n3 --- n2 n3 n1 )
  DX POP
  BX POP
  AX POP
  BX PUSH
  2PUSH
END-CODE

 OVER
Duplication de l'avant dernier nombre de la pile de
donn‚es.
@SYNTAXE = Syntaxe : n1 n2 OVER
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE OVER  ( n1 n2 --- n1 n2 n1 )
  DX POP
  AX POP
  AX PUSH
  2PUSH
END-CODE

 SWAP
Permutation des deux premiers nombres de la pile de
donn‚es.
@SYNTAXE = Syntaxe : n1 n2 SWAP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE SWAP  ( n1 n2 --- n2 n1 )
  DX POP
  AX POP
  2PUSH
END-CODE

 ?DUP
Duplication du nombre situ‚ au sommet de la pile de
donn‚es, si celui-ci n'est pas nul.
@SYNTAXE = Syntaxe : n ?DUP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE ?DUP  ( n --- n n )
  AX POP
  AX AX OR
  0<<>>
  IF
    AX PUSH
  THEN
  1PUSH
END-CODE

 DUP
Duplication du nombre situ‚ au sommet de la pile de
donn‚es.
@SYNTAXE = Syntaxe : n DUP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE DUP  ( n --- n n )
  AX POP
  AX PUSH
  1PUSH
END-CODE

 DROP
Suppression du nombre situ‚ au sommet de la pile de
donn‚es.
@SYNTAXE = Syntaxe : n DROP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE DROP  ( n --- )
  AX POP
  NEXT
END-CODE

 RDEPTH
Empile la profondeur de la pile de retour.
@SYNTAXE = Syntaxe : RDEPTH
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : RDEPTH  ( --- n )
  RP0 @ RP@ -
  2/ 1-
;

 DEPTH
Empile la profondeur de la pile de donn‚es.
@SYNTAXE = Syntaxe : DEPTH
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DEPTH
  SP0 @ SP@ - 2/ 1-
;

 RP!
Initialisation du pointeur de la pile de retour.
@SYNTAXE = Syntaxe : n RP!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE RP!  ( n --- )
  RP POP
  NEXT
END-CODE
La pile de retour ‚tant utilis‚e par PGForth pour
stocker l'adresse de retour de la d‚finition en cours
d'‚x‚cution, la modification de celle-ci doit se faire en
connaissance de cause...

 RP@
Empile la valeur du pointeur de la pile de retour.
@SYNTAXE = Syntaxe : RP@
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE RP@
  RP AX MOV
  1PUSH
END-CODE

 SP!
Initialise le pointeur de la pile de donn‚es.
@SYNTAXE = Syntaxe : n SP!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE SP!  ( n --- )
  SP POP
  NEXT
END-CODE

 SP@
Empile la valeur du pointeur de la pile de donn‚es.
@SYNTAXE = Syntaxe : SP@
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE SP@
  SP AX MOV
  1PUSH
END-CODE

 ((STDIN))
Variable.
Buffer temporaire utilis‚ par les primitives d'entr‚es /
sorties.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE ((STDIN)) 0 C,

 BUFFERS
Varaible.
Adresse des zones m‚moires o— sont stock‚es les donn‚es lue ou
… ‚crire dans les fichiers.
Pour chaque fichier, un espace de 256 octets est r‚serv‚ pour
l'‚change des informations avec la m‚moire.
Cet espace est suivi de 2 octets pour stocker le num‚ro de
ligne courante.
Vient s'ajouter juste aprŠs une zone de 64 octets pour stocker
le "pathname" ( [u:][chemin] nom_fichier.ext ) du ficher.
@SYNTAXE = Syntaxe : BUFFERS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE BUFFERS
256 ALLOT ," CON:"  59 ALLOT 0 ,   ( Correspond … STDIN )
256 ALLOT ," CON:"  59 ALLOT 0 ,   ( Correspond … STDOUT )
256 ALLOT ," CON:"  59 ALLOT 0 ,   ( Correspond … STDERR )
256 ALLOT ," COM1:" 58 ALLOT 0 ,   ( Correspond … STDAUX )
256 ALLOT ," PRN:"  59 ALLOT 0 ,   ( Correspond … STDPRN )
322 15 * ALLOT

 DTA
Variable.
Zone de donn‚es, utilis‚e pour les accŠs disques.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE DTA 512 ALLOT

 ERRMSG
Variable.
Zone de donn‚es contenant les messages d'erreurs des
diff‚rentes fonctions DOS.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE ERRMSG
," num‚ro de fonction invalide                      "
," fichier introuvable                              "
," chemin introuvable                               "
," trop de fichiers ouverts                         "
," accŠs refus‚                                     "
," num‚ro de fichier invalide                       "
," blocs de contr“le de m‚moire d‚truits            "
," m‚moire insuffisante                             "
," adresse de bloc m‚moire invalide                 "
," environnement invalide                           "
," format invalide                                  "
," mode d'accŠs invalide                            "
," donn‚es invalides                                "
," unit‚ invalide                                   "
," tentative de suppression du r‚pertoire en cours  "
," pas la mˆme unit‚                                "
," plus de fichier                                  "
," disquette prot‚g‚e en ‚criture                   "
," unit‚ de disque invalide                         "
," unit‚ non prˆte                                  "
," commande de disque invalide                      "
," erreur de CRC                                    "
," longueur invalide (disque)                       "
," erreur de recherche (seek sur disque)            "
," disque non DOS                                   "
," secteur introuvable                              "
," plus de papier                                   "
," erreur d'‚criture                                "
," erreur de lecture                                "
," d‚faillance g‚n‚rale                             "
," problŠme de partage de fichier                   "
," problŠme de verrouillage                         "
," mauvais disque                                   "
," pas de FCB                                       "
," erreur DOS                                       "

 $PAD
Variable.
Zone de donn‚es adress‚e par PAD, utilis‚e comme tampon
temporaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE $PAD 256 ALLOT

 C-C-F
Variable.
Zone de donn‚es contenant la table des vecteurs des caractŠres
de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE C-C-F
]
  NOOP     ( Code 0  : action de CTRL + @ )
  NOOP     ( Code 1  : action de CTRL + A )
  NOOP     ( Code 2  : action de CTRL + B )
  RES-IN   ( Code 3  : action de CTRL + C )
  NOOP     ( Code 4  : action de CTRL + D )
  NOOP     ( Code 5  : action de CTRL + E )
  NOOP     ( Code 6  : action de CTRL + F )
  BEEP     ( Code 7  : action de CTRL + G )
  DEL-IN   ( Code 8  : action de CTRL + H )
  NOOP     ( Code 9  : action de CTRL + I )
  NOOP     ( Code 10 : action de CTRL + J )
  NOOP     ( Code 11 : action de CTRL + K )
  NOOP     ( Code 12 : action de CTRL + L )
  CR-IN    ( Code 13 : action de CTRL + M )
  NOOP     ( Code 14 : action de CTRL + N )
  NOOP     ( Code 15 : action de CTRL + O )
  P-IN     ( Code 16 : action de CTRL + P )
  NOOP     ( Code 17 : action de CTRL + Q )
  NOOP     ( Code 18 : action de CTRL + R )
  NOOP     ( Code 19 : action de CTRL + S )
  NOOP     ( Code 20 : action de CTRL + T )
  BACK-UP  ( Code 21 : action de CTRL + U )
  NOOP     ( Code 22 : action de CTRL + V )
  NOOP     ( Code 23 : action de CTRL + W )
  BACK-UP  ( Code 24 : action de CTRL + X )
  BYE      ( Code 25 : action de CTRL + Y )
  NOOP     ( Code 26 : action de CTRL + Z )
  NOOP     ( Code 27 : action de CTRL + [ )
  NOOP     ( Code 28 : action de CTRL + \ )
  NOOP     ( Code 29 : action de CTRL + ] )
  NOOP     ( Code 30 : action de CTRL + ^ )
  NOOP     ( Code 31 : action de CTRL + _ )
[

 TIB
Constante.
Adresse du tampon clavier (Terminal Input Buffer).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = BUFFERS 3 + CONSTANT TIB

 STDPRN
Constante.
Contient le handler du p‚riph‚rique standard d'impression.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 4 CONSTANT STDPRN

 AUXOUT
Constante.
Contient le handler du p‚riph‚rique de sortie auxiliaire
standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 3 CONSTANT AUXOUT

 AUXIN
Constante.
Contient le handler du p‚riph‚rique d'entr‚e auxiliaire
standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 3 CONSTANT AUXIN

 STDOUT
Constante.
Contient le handler du p‚riph‚rique de sortie standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 1 CONSTANT STDOUT

 STDIN
Constante.
Contient le handler du p‚riph‚rique d'entr‚e standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0 CONSTANT STDIN

 PAD
Constante.
Contient l'adresse du tampon temporaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = $PAD 257 + CONSTANT PAD

 C/L
Constante.
Contient le nombre maximum de caractŠres par ligne.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 255 CONSTANT C/L

 BELL
Constante.
Contient le code du caractŠre correspondant … l'‚mission d'un
beep.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 7 CONSTANT BELL

 BS
Constante.
Contient le code du caractŠre correspondant au retour arriŠre.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 8 CONSTANT BS

 BL
Constante.
Contient le code du caractŠre blanc (espace).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 32 CONSTANT BL

 #THREADS
Constante.
Contient le nombre de brins (THREADS) d'un vocabulaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 4 CONSTANT #THREADS

 #VOCS
Constante.
Contient le nombre maximum de vocabulaires de CONTEXT.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 8 CONSTANT #VOCS

 READ-WRITE
Constante.
Attribut pr‚d‚fini pour l'ouverture d'un fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 2 CONSTANT READ-WRITE

 WRITE
Constante.
Attribut pr‚d‚fini pour l'ouverture d'un fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 1 CONSTANT WRITE

 READ
Constante.
Attribut pr‚d‚fini pour l'ouverture d'un fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0 CONSTANT READ

 C/PATH
Constante.
Contient la longueur maximum d'un chemin d'accŠs.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 64 CONSTANT C/PATH

 LBUF
Constante.
Contient la longueur maximum d'un buffer.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 256 CONSTANT LBUF

 #FILES
Constante.
Contient le nombre de fichiers ouverts actuellement par
PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 5 CONSTANT #FILES

 FILES
Constante.
Contient le nombre maximum de fichiers ouvrables par PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 20 CONSTANT FILES

 #TIB
Constante.
Contient la longueur de la chaine stock‚e dans le TIB.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = BUFFERS 2+ CONSTANT #TIB

 FENCE
Variable.
Contient le NFA du dernier mot du dictionnaire … prot‚ger
contre l'effacement.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE FENCE
Initialisation :
LAST @ FENCE !

 C-C
Variable.
Contient l'adresse de la table des vecteurs des caractŠres de
contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE C-C
Initialisation :
C-C-F 2+ C-C !

 RP0
Variable.
Contient la valeur initiale du pointeur de la pile de retour.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE RP0
Initialisation :
IBASE HEX
07FFE RP0 !

 SP0
Variable.
Contient la valeur initiale du pointeur de la pile de donn‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE SP0
Initialisation :
IBASE HEX
0FFFE SP0 !

 STATUS?
Variable.
Son ‚tat indique si il faut ou non afficher le STATUS du
systŠme.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE STATUS?
Initialisation :
STATUS? OFF

 ATTRIBUTS
Variable.
Son ‚tat indique l'utilisation ou l'inhibition des attributs
vid‚o ANSI.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE ATTRIBUTS
Initialisation :
ATTRIBUTS OFF

 >>IN
Variable.
Contient l'adresse du caractŠre … lire dans le flux d'entr‚e.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE >>IN
Initialisation :
>>IN OFF

 'TIB
Variable.
Contient l'adresse du tampon d'entr‚e TIB.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE 'TIB
Initialisation :
BUFFERS 3 + 'TIB !

 PRINTING
Variable.
Son ‚tat indique l'autorisation ou l'inhibition de
l'impression.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE PRINTING
Initialisation :
PRINTING OFF

 #LINE
Variable.
Contient le nombre de lignes actuellement ‚mises.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE #LINE
Initialisation :
#LINE OFF

 #OUT
Variable.
Contient le nombre de caractŠres actuellement ‚mis.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE #OUT
Initialisation :
#OUT OFF

 SPAN
Variable.
Contient le nombre de caractŠres actuellement saisis.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE SPAN

 WIDTH
Variable.
Contient la longueur maximum du nom d'une d‚finition.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE WIDTH
Initialisation :
31 WIDTH !

 END?
Variable.
Contient l'‚tat du flux d'entr‚e ( VRAI = flux d'entr‚e vide ).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE END?

 PRIOR
Variable.
Contient l'adresse du vocabulaire de la derniŠre recherche.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE PRIOR

 LAST
Variable.
Contient le NFA du dernier mot d‚fini, qui n'est pas forc‚ment
une d‚finition valide.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE LAST

 VOC-LINK
Variable.
Permet la liaison des diff‚rents vocabulaires.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE VOC-LINK

 CONTEXT
Variable.
Contient les adresses des huits vocabulaires de CONTEXT.
@DEF_FORTH = D‚finition en FORTH
@PROGRAMME = VARIABLE CONTEXT 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

 CURRENT
Variable.
Contient l'adresse du vocabulaire CURRENT.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE CURRENT

 CAPS
Variable.
Son ‚tat indique l'autorisation ou l'inhibition des minuscules.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE CAPS
Initialisation :
CAPS OFF

 HLD
Variable.
Contient le dernier chiffre converti dans le tampon PAD.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE HLD
Initialisation :
HLD OFF

 DPL
Variable.
Contient la position du point d‚cimal dans une chaine.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE DPL
Initialisation :
DPL OFF

 OBASE
Variable.
Contient la valeur de la base de sortie courante.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE OBASE
Initialisation :
OBASE DECIMAL

 IBASE
Variable.
Contient la valeur de la base d'entr‚e courante.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE IBASE
Initialisation :
IBASE DECIMAL

 WARNING
Variable.
Son ‚tat indique si il faut ‚mmettre un message en cas de
d‚finition d‚ja existante.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE WARNING
Initialisation :
WARNING ON

 DP
Variable.
Contient l'adresse de la premiŠre position libre du
dictionnaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE DP
Initialisation :
HERE DP !

 CSP
Variable.
Contient la profondeur de la pile de donn‚es, en cours de
compilation.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE CSP

 STATE
Variable.
Son ‚tat reflŠte celui du systŠme PGForth.
VRAI = Compilation.
FAUX = Interpr‚tation.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE STATE
Initialisation :
STATE OFF

 ECHO
Variable.
Son ‚tat autorise ou non l'affichage des lignes lues, pendant
l'inclusion d'un fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE ECHO
Initialisation :
ECHO OFF

 HANDLE
Variable.
Contient le handler du fichier d'entr‚e standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE HANDLE
Initialisation :
STDIN HANDLE !

 EOF?
Variable.
Son ‚tat indique le status du fichier courant ( VRAI = fichier
vide ).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE EOF?
Initialisation :
EOF? OFF

 TOS
Variable.
Contient l'adresse du sommet de la pile de donn‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE TOS

 COMMAND.COM
Zone de donn‚es utilis‚e pour le stockage de
l'emplacement de COMMAND.COM (COMSPEC).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE COMMAND.COM 80 ALLOT

 STARTUP-FILE
Variable.
Contient le nom d'un fichier qui est inclu automatiquement au
d‚marrage de PGForth.
Initialis‚ au d‚part avec le nom 'STARTUP.FTH'.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 15 STRING STARTUP-FILE
Initialisation :
STARTUP-FILE STRLEN ERASE
" STARTUP.FTH" STARTUP-FILE !"

 EXEHDR
Zone de donn‚es utilis‚e pour g‚n‚rer l'entˆte d'un
fichier ‚x‚cutable.
Utilis‚e par le mot HDR!.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE EXEHDR 512 ALLOT

 AVOC
Variable.
Utilis‚e par CODE, pour sauvegarder le vocabulaire de contexte.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE AVOC

 PARAM-BLOCK
Block de paramŠtres utilis‚ par le mot SHELL".
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE PARAM-BLOCK
  0  ,             ( Environnement par d‚faut. )
  0  ,  0 ,        ( Pointeur sur la commande. )
  -1 , -1 ,        ( Pas de FCB1. )
  -1 , -1 ,        ( Pas de FCB2. )
  0  ,  0 ,        ( Pointeur de pile. )

 SEGMENT>>
Variable.
Contient l'adresse de segment utilis‚e par les mots DUMP et
LDUMP.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE SEGMENT>>

 SEED
Variable.
Utilis‚e par le g‚n‚rateur de nombres al‚atoires.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE SEED

 LMARGIN
Variable.
Utilis‚e par le mot WORDS.
Contient la marge d'affichage gauche.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE LMARGIN
Initialisation :
1 IS LMARGIN

 RMARGIN
Variable.
Utilis‚e par le mot WORDS.
Contient la marge d'affichage droite.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE RMARGIN
Initialisation :
72 IS RMARGIN

 #WORDS
Variable.
Utilis‚e par le mot WORDS.
Contient le nombre de d‚finitions list‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE #WORDS

 #TAB
Variable.
Utilis‚e par le mot WORDS.
Contient la largeur de la tabulation.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE #TAB
Initialisation :
12 IS #TAB

 STR$
Constante.
Utilis‚e par le mot $EXECUTE.
Contient l'adresse de la chaine … interpr‚ter.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0. 2CONSTANT STR$

 #STRING
Variable.
Utilis‚e par le mot $EXECUTE.
Contient le nombre de chaines imbriqu‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE #STRING

 SS-REG
Constante.
Contient la valeur du registre de segment de pile SS,
avant le lancement de PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0 CONSTANT SS-REG

 SP-REG
Constante.
Contient la valeur du registre pointeur de pile SP,
avant le lancement de PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0 CONSTANT SP-REG

 BP-REG
Constante.
Contient la valeur du registre pointeur de pile BP,
avant le lancement de PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0 CONSTANT BP-REG

 (INCLUDE)
Primitive.
  ‚x‚cution d'une s‚quence de mots FORTH, provenants
  d'un fichier de texte, dont le handler est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : handle (INCLUDE)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (INCLUDE)  ( handle --- )
  HANDLE @ >>R  >>IN @ >>R  ( Sauvegarde du contexte actuel )
  HANDLE !
  BEGIN
    GETLINE
    >>IN OFF RUN            ( Interpr‚tation de la ligne lue )
    EOF? @
  UNTIL                     ( jusqu'… la fin du fichier )
  CLOSE
  R>> >>IN ! R>> HANDLE !   ( restitution du contexte )
;

 INCLUDE
Le mot INCLUDE sert … ‚x‚cuter une s‚quence de mots
Forth enregistr‚es dans un fichier de texte.
Le texte est interpr‚t‚ comme s'il ‚tait entr‚ au clavier.
Le fichier texte peut lui-mˆme contenir le mot INCLUDE, cette
imbrication pouvant s'‚tendre dans la limite de la pile de
retour.
@SYNTAXE = Syntaxe : INCLUDE [u:][chemin] Nom_fichier.ext
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : INCLUDE  ( adr_fichier --- )
  READ OPEN
  (INCLUDE)
;
IMMEDIATE

 (GETLINE)
Primitive.
Saisie une ligne de texte, termin‚ par CR, dans le fichier
num‚ro [handle] et la stocke … l'adresse [adresse].
A cette adresse se trouve une chaine standard, c'est … dire, 1
octet pour la
longueur de la chaine suivi de la chaine elle-mˆme. Si la
longueur de la chaine saisie d‚passe 255 octets, le fichier
n'est plus du texte, il est alors fini.
[eof] est vrai pour indiquer une fin de fichier.
Les caractŠres de contr“le (codes ASCII inf‚rieurs … 32) sont
remplac‚s par des espaces.
@SYNTAXE = Syntaxe : adresse handle (GETLINE)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (GETLINE)  ( adresse handle --- eof )
  BX POP
  DX POP
  DX DI MOV
  0 # 0 [DI] MOV     ( On initialise la longueur … 0 )
  BEGIN
    0 [DI] AL MOV
    255 # AL CMP     ( A-t'on lu 255 caractŠres ? )
    0=
    IF
      -1 # AX MOV
      1PUSH
    THEN
    DX INC
    1 # CX MOV
    63 # AH MOV
    33 INT
    U<<
    IF
      -1 # AX MOV
      1PUSH
    THEN
    CX AX CMP        ( Est-on … la fin du fichier ? )
    0<<>>
    IF
      -1 # AX MOV
      1PUSH
    THEN
    DI CX MOV
    DX DI MOV
    0 [DI] AL MOV
    AH AH SUB
    10 # AX CMP      ( Est-ce la fin de la ligne ? )
    0<<>>
  WHILE
    32 # AX CMP      ( Le caractŠre lu est-il un caractŠre de
contr“le ? )
    0<<
    IF
      32 # AL MOV    ( Oui, on le remplace par un espace )
      AL 0 [DI] MOV
    THEN
    CX DI MOV
    0 [DI] INC
  REPEAT
  AX AX XOR
  1PUSH
END-CODE

 GETLINE
Pour lire une ligne de texte dans le fichier courant.
La ligne est stock‚e dans le BUFFER courant. Le compteur de
ligne est incr‚ment‚ (avec LINE#).
Si la variable ECHO est ON la ligne est affich‚e … l'‚cran.
@SYNTAXE = Syntaxe : GETLINE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : GETLINE  ( --- )
  BUFFER HANDLE @
  (GETLINE) EOF? !
  ECHO @
  IF
    .LINE
  THEN
  LINE# 1+!
;

 .LINE
Affiche la ligne de texte qui vient d'ˆtre lue dans
le fichier courant (avec GETLINE).
@SYNTAXE = Syntaxe : .LINE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : .LINE  ( --- )
  BUFFER COUNT CR TYPE
;

 GET
Pour lire un caractŠre dans le fichier courant.
Le caractŠre est stock‚ dans le premier octet du BUFFER
courant.
@SYNTAXE = Syntaxe : GET
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : GET  ( --- )
  HANDLE @ 0=                 ( le handle 0 est le clavier )
  IF
    (KEY)
  ELSE
    BUFFER 1 HANDLE @ (GET)   ( lecture d'un caractŠre )
    0<<>>
    IF
      DROP EOF 13
    ELSE
      1 =
      IF
        BUFFER C@
      ELSE
        EOF 13
      THEN
    THEN
  THEN
;

 OPEN
Ouverture d'un fichier.
Le num‚ro (handle) du fichier est renvoy‚ sur la pile.
@SYNTAXE = Syntaxe : mode OPEN [u:][chemin] Nom_fichier.ext
'mode' est le mode d'accŠs du fichier … ouvrir.
On peut utiliser les trois constantes pr‚d‚finies suivantes :
READ       : Ouverture du fichier en lecture seulement
WRITE      : Ouverture du fichier en ‚criture seulement
READ-WRITE : Ouverture du fichier en lecture et/ou ‚criture
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : OPEN ( mode adr_fichier --- handle )
  ?OPEN ASCII0
  SWAP (OPEN) ?DOSERR
  HANDLE @ >>R          ( sauvegarde du handle courant )
  HANDLE ! BUFFER OFF
  'WORD PATHNAME!       ( sauvegarde du nom du fichier )
  LINE# OFF
  HANDLE @ R>> HANDLE !
;

 ?OPEN
Avant une ouverture de fichier, ?OPEN contr“le le
nombre de fichiers ouverts.
Si le nombre est trop important, l'interprŠteur ABORT avec
le message " Trop de fichiers ouverts ".
@SYNTAXE = Syntaxe : ?OPEN
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?OPEN  ( --- )
  #FILES 1- FILES
  = ABORT" Trop de fichiers ouverts"
;

 PATHNAME
Renvoi l'adresse du nom du fichier courant.
@SYNTAXE = Syntaxe : PATHNAME
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : PATHNAME  ( --- adr )
  BUFFER LBUF +
;

 PATHNAME!
Stocke une chaine de caractŠre dans le PATHNAME
courant.
L'ancien PATHNAME est d'abord mis … BLANK.
@SYNTAXE = Syntaxe : adr_chaine PATHNAME!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : PATHNAME!  ( adr_chaine --- )
  PATHNAME DUP C/PATH ERASE
  OVER C@ 1+ C/PATH MIN CMOVE
;

 ALLCLOSE
Ferme tous les fichiers ouverts, sauf les 5 fichiers
standards ouverts par le systŠme DOS.
@SYNTAXE = Syntaxe : ALLCLOSE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ALLCLOSE  ( --- )
  FILES 1+ 5
  DO
    I (CLOSE)
  LOOP
;

 CLOSE
Ferme le fichier courant, dont le handler est contenu
dans la variable HANDLE.
@SYNTAXE = Syntaxe : CLOSE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CLOSE  ( --- )
  HANDLE @ (CLOSE)
  EOF? OFF
;

 DEL
Efface un ou plusieurs fichier.
@SYNTAXE = Syntaxe : DEL [u:][chemin] Nom_fichier.ext
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DEL ( adr_fichier --- )
  ASCII0
  65 DOS ?DOSERR
;

 CHDIR
Changement de r‚pertoire courant.
@SYNTAXE = Syntaxe : CHDIR [u:] chemin
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CHDIR  ( adr_chemin --- )
  ASCII0
  59 DOS ?DOSERR
;

 RMDIR
Suppression d'un r‚pertoire vide.
@SYNTAXE = Syntaxe : RMDIR [u:] chemin
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : RMDIR  ( adr_chemin --- )
  ASCII0
  58 DOS ?DOSERR
;

 MKDIR
Cr‚ation d'un r‚pertoire.
@SYNTAXE = Syntaxe : MKDIR [u:] chemin
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : MKDIR  ( adr_chemin --- )
  ASCII0
  57 DOS ?DOSERR
;

 DRIVE?
Renvoi le num‚ro de l'unit‚ courante.
Le code renvoy‚ est ‚gal … 0 pour le lecteur A:,
1 pour le lecteur B:, 2 pour le lecteur C:, etc...
@SYNTAXE = Syntaxe : DRIVE?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE DRIVE?  ( --- nødrv )
  25 # AH MOV
  33 INT
  AH AH SUB
  1PUSH
END-CODE

 ASCII0
Saisit une chaine, correspondant … un nom de fichier,
et
la transfŠre … l'adresse renvoy‚e [adr] sous la forme
standard en la faisant suivre d'un z‚ro, terminateur
des noms de fichier pour le systŠme d'exploitation.
Une chaine ASCII0 ainsi cr‚‚e peut ˆtre compos‚e
des noms d'unit‚ et de r‚pertoires et se termine
par le nom du fichier.
[adr] est l'adresse renvoy‚e par 'WORD.
@SYNTAXE = Syntaxe : ASCII0 chaine
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ASCII0  ( chaine --- adr )
  BL WORD
  COUNT OVER +
  0 SWAP C!
;

 GET-DTA
Renvoi l'adresse de la zone DTA, utilis‚e pour les
accŠs disque.
@SYNTAXE = Syntaxe : GET-DTA
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE GET-DTA  ( --- adr )
  47 # AH MOV
  33 INT
  BX PUSH
  NEXT
END-CODE

 SET-DTA
Fixe l'adresse de la zone DTA, utilisable pour les
accŠs disque.
@SYNTAXE = Syntaxe : adresse_dta SET-DTA
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE SET-DTA  ( adr --- )
  DX POP
  26 # AH MOV
  33 INT
  NEXT
END-CODE

 LINE#
Renvoi le num‚ro de la ligne lue dans le fichier
courant.
@SYNTAXE = Syntaxe : LINE#
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : LINE#  ( --- n )
  PATHNAME C/PATH +
;

 BUFFER
Renvoi la zone de 256 octets o— sont stock‚es les
donn‚es re‡ue ou … envoyer vers le fichier courant.
@SYNTAXE = Syntaxe : BUFFER
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BUFFER  ( --- adr )
  LBUF C/PATH + 2+
  HANDLE @ * BUFFERS +
;

 EOF
Provoque artificiellement la fin du fichier courant.
Permet, entre autre, de commenter abondament un source.
@SYNTAXE = Syntaxe : EOF
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : EOF  ( --- )
  EOF? ON
;

 A:
initialise A comme le lecteur courant.
@SYNTAXE = Syntaxe : A:
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : A:  ( --- )
  1 SELECT
;

 B:
initialise B comme le lecteur courant.
@SYNTAXE = Syntaxe : B:
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : B:  ( --- )
  2 SELECT
;

 C:
initialise C comme le lecteur courant.
@SYNTAXE = Syntaxe : C:
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : C:  ( --- )
  3 SELECT
;

 D:
initialise D comme le lecteur courant.
@SYNTAXE = Syntaxe : D:
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D:  ( --- )
  4 SELECT
;

 E:
initialise E comme le lecteur courant.
@SYNTAXE = Syntaxe : E:
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : E:  ( --- )
  5 SELECT
;

 SELECT
S‚lection d'une unit‚ de disque.
@SYNTAXE = Syntaxe : nødrv SELECT
nødrv = 0 pour le lecteur A, 1 pour le lecteur B,
etc...
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SELECT  ( nødrv --- )
  1- 14 DOS ?DOSERR
;

 ?DOSERR
Si le nombre pr‚sent sur la pile est sup‚rieur …
z‚ro,
c'est un num‚ro d'erreur de fonction DOS et l'interprŠteur
ABORT avec le message correspondant.
@SYNTAXE = Syntaxe : flag ?DOSERR
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?DOSERR  ( flag --- )
  ?DUP
  IF
    'WORD COUNT 2DUP UPPER
    BOLD TYPE SPACE
    1- 35 MIN 50 * ERRMSG +
    COUNT TYPE ATTOFF ABORT
  THEN
;

 DOS
Appel simple d'une fonction de l'interruption 21h.
Le num‚ro de fonction est charg‚ dans le registre AH et
l'argument est
charg‚ dans le registre DX avant l'appel de l'interruption.
Le code de retour de l'interruption est un num‚ro d'erreur.
DOS est utilis‚ pour les entr‚es/sorties vers les fichiers.
@SYNTAXE = Syntaxe : argument nøfonction DOS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE DOS  ( arg fon --- flag )
  AX POP
  AL AH MOV
  DX POP
  33 INT
  U>>=
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … z‚ro, pas d'erreur )
  THEN
  1PUSH
END-CODE

 (SEEK)
AccŠs direct dans un fichier par modification du
pointeur.
@SYNTAXE = Syntaxe : d‚pl_d handle mode (SEEK)
d‚pl_d est le d‚placement du pointeur (entier
double).
handle est le num‚ro du fichier.
mode   d‚termine le type de d‚placement:
  0 : d‚placement … partir du d‚but de fichier.
  1 : d‚placement … partir de la position courante.
  2 : d‚placement … partir de la fin de fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (SEEK)  ( d‚pl_d handle mode --- pos_d code )
  AX POP
  BX POP
  CX POP
  DX POP
  66 # AH MOV
  33 INT
  AX PUSH
  DX PUSH
  U>>=
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … z‚ro, pas d'erreur )
  THEN
  1PUSH
END-CODE
Informations renvoy‚es :
pos_d est la nouvelle position du pointeur (entier double).
code  est le code d'erreur :
  0 : pas d'erreur.
  6 : num‚ro de fichier invalide.

 (FREE)
Renvoi des informations concernant l'espace
disponible sur un disque.
@SYNTAXE = Syntaxe : nødrv (FREE)
nødrv est le num‚ro d'unit‚; 0=unit‚ courante, 1=A:,
etc...
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (FREE)  ( nødrv --- clu sec/clu oct/sec )
  DX POP
  54 # AH MOV
  33 INT
  U<<
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … un, alors erreur )
    1PUSH
  THEN
  BX PUSH
  AX PUSH
  CX PUSH
  NEXT
END-CODE
Informations renvoy‚es :
clu     est le nombre de clusters libres.
sec/clu est le nombre de secteurs par cluster.
oct/sec est le nombre d'octets par secteur.

 (SEARCH0)
Recherche dans un r‚pertoire le premier fichier
correspondant … un nom g‚n‚rique et … un attribut.
Le nom g‚n‚rique peut contenir des sp‚cifications
d'unit‚ et de r‚pertoire et les traditionels jokers
de recherche "*" et "?".
@SYNTAXE = Syntaxe : adr attribut (SEARCH0)
adr      est l'adresse de la chaine ASCII0 du nom
g‚n‚rique.
attribut est l'atribut de recherche :
  XXXXXXXX      - Nombre binaire (6 bits significatifs)
    ::::::
    :::::+->>  0 - Fichier ne pouvant ˆtre que lu donc
    :::::         non modifiable et non effa‡able.
    :::::
    ::::+-->>  1 - Fichier invisible avec la commande DIR.
    ::::
    :::+--->>  2 - Fichier systeme, invisible avec la commande
DIR.
    :::
    ::+---->>  3 - Fichier contenant le nom du volume dans
    ::            ses onze premier octets.
    ::
    :+----->>  4 - Entr‚e d'un r‚pertoire.
    :
    +------>>  5 - Fichier modifi‚ et ferm‚ (archivage).
L'attributs 0 d‚signe un fichier normal.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (SEARCH0)  ( adr attribut --- flag )
  CX POP
  DX POP
  78 # AH MOV
  33 INT
  -1 # AX MOV
  U<<
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … un, fichier trouv‚ )
  THEN
  1PUSH
END-CODE
flag est vrai si un fichier … ‚t‚ trouv‚.

 (SEARCH)
Poursuite de la recherche commenc‚e par (SEARCH0).
@SYNTAXE = Syntaxe : (SEARCH)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (SEARCH)  ( --- flag )
  79 # AH MOV
  33 INT
  -1 # AX MOV
  U<<
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … un, fichier trouv‚ )
  THEN
  1PUSH
END-CODE

 (REN)
Primitive de changement de nom et/ou de d‚placement
d'un fichier.
@SYNTAXE = Syntaxe : adr_src adr_dest (REN)
adr_src  est l'adresse de la chaine ASCII0 du fichier
source.
adr_dest est l'adresse de la chaine ASCII0 du fichier
destination.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (REN)  ( adr_src adr_dest --- code )
  DI POP
  DX POP
  DS AX MOV
  AX ES MOV
  86 # AH MOV
  33 INT
  U>>=
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … z‚ro, pas d'erreur )
  THEN
  1PUSH
END-CODE
code est le code d'erreur renvoy‚ :
  0 : pas d'erreur.
  3 : chemin introuvable.
  5 : accŠs refus‚.
 17 : pas la mˆme unit‚.

 (OPEN)
Primitive d'ouverture d'un fichier.
Utilis‚e, entre autre, par OPEN.
@SYNTAXE = Syntaxe : adr_fic mode (OPEN)
adr_fic est l'adresse de la chaine ASCII0 du nom du
fichier.
mode    est le mode d'accŠs du fichier … ouvrir.
On peut utiliser les trois constantes pr‚d‚finies suivantes :
READ       : Ouverture du fichier en lecture seulement
WRITE      : Ouverture du fichier en ‚criture seulement
READ-WRITE : Ouverture du fichier en lecture et/ou ‚criture
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (OPEN)  ( adr_fic mode --- handle flag )
  AX POP
  DX POP
  61 # AH MOV
  33 INT
  AX PUSH
  U>>=
  IF
    0 # AX MOV              ( Si le 'Carry flag' est … z‚ro,
pas d'erreur )
    ' #FILES >>BODY # BX MOV
    1 # 0 [BX] ADD          ( Un fichier ouvert de plus )
  THEN
  1PUSH
END-CODE
Informations renvoy‚es :
handle est le num‚ro du fichier ouvert ou un code d'erreur si
flag est diff‚rent de z‚ro :
  2 : fichier introuvable.
  4 : trop de fichiers ouverts.
  5 : accŠs refus‚.
 12 : mode d'accŠs invalide.

 (MAKE)
Primitive de cr‚ation d'un fichier.
Si le fichier est d‚j… existant, il est ‚cras‚.
@SYNTAXE = Syntaxe : adr_fic attribut (MAKE)
adr_fic est l'adresse de la chaine ASCII0 du nom du
fichier.
attribut est l'atribut du fichier cr‚‚ :
  XXXXXXXX      - Nombre binaire (6 bits significatifs)
    ::::::
    :::::+->>  0 - Fichier ne pouvant ˆtre que lu donc
    :::::          non modifiable et non effa‡able.
    :::::
    ::::+-->>  1 - Fichier invisible avec la commande DIR.
    ::::
    :::+--->>  2 - Fichier systeme, invisible avec la commande
DIR.
    :::
    ::+---->>  3 - Fichier contenant le nom du volume dans
    ::            ses onze premier octets.
    ::
    :+----->>  4 - Entr‚e d'un r‚pertoire.
    :
    +------>>  5 - Fichier modifi‚ et ferm‚ (archivage).
L'attributs 0 d‚signe un fichier normal.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (MAKE)  ( adr_fic attribut --- hdl flag )
  CX POP
  DX POP
  60 # AH MOV
  33 INT
  AX PUSH
  U>>=
  IF
    0 # AX MOV              ( Si le 'Carry flag' est … z‚ro,
pas d'erreur )
    ' #FILES >>BODY # BX MOV
    1 # 0 [BX] ADD          ( Un fichier ouvert de plus )
  THEN
  1PUSH
END-CODE
Informations renvoy‚es :
hdl est le num‚ro du fichier cr‚‚ ou un code d'erreur
si flag est diff‚rent de z‚ro :
  4 : trop de fichiers ouverts.
  5 : accŠs refus‚.
 12 : mode d'accŠs invalide.

 (CLOSE)
Primitive de fermeture d'un fichier.
@SYNTAXE = Syntaxe : handle (CLOSE)
handle est le num‚ro du fichier … fermer.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (CLOSE)
  BX POP
  62 # AH MOV
  33 INT
  ' #FILES >>BODY # BX MOV
  0 [BX] AX MOV
  5 # AX CMP
  >>
  IF
    1 # 0 [BX] SUB    ( Un fichier ouvert de moins )
  THEN
  NEXT
END-CODE

 (PUT)
Primitive d'‚criture d'une chaine dans un fichier.
@SYNTAXE = Syntaxe : seg_buf off_buf long handle (PUT)
seg_buf est l'adresse de segment de la chaine.
off_buf est l'adresse d'offset de la chaine.
long    est la longueur de la chaine.
handle  est le num‚ro du fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (PUT)  ( seg_buf off_buf long handle ---
lon/err flag )
  DS AX MOV
  AX ES MOV
  BX POP
  CX POP
  DX POP
  DS POP
  64 # AH MOV
  33 INT
  AX PUSH
  ES BX MOV
  BX DS MOV
  U>>=
  IF
    0 # AX MOV ( Si le 'Carry flag' est … z‚ro, pas d'erreur )
  THEN
  1PUSH
END-CODE
Informations renvoy‚es :
lon/err est le nombre d'octets ‚crits ou un code d'erreur
si flag est diff‚rent de z‚ro :
  5 : accŠs refus‚.
  6 : num‚ro de fichier invalide.

 (GET)
Primitive de lecture d'une chaine dans un fichier.
@SYNTAXE = Syntaxe : seg_buf off_buf long handle (GET)
seg_buf est l'adresse de segment de la chaine.
off_buf est l'adresse d'offset de la chaine.
long    est la longueur de la chaine.
handle  est le num‚ro du fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (GET)  ( seg_buf off_buf long handle ---
lon/err flag )
  DS AX MOV
  AX ES MOV
  BX POP
  CX POP
  DX POP
  DS POP
  63 # AH MOV
  33 INT
  AX PUSH
  ES BX MOV
  BX DS MOV
  U>>=
  IF
    0 # AX MOV ( Si le 'Carry flag' est … z‚ro, pas d'erreur )
  THEN
  1PUSH
END-CODE
Informations renvoy‚es :
lon/err est le nombre d'octets ‚crits ou un code d'erreur
si flag est diff‚rent de z‚ro :
  5 : accŠs refus‚.
  6 : num‚ro de fichier invalide.

 ((STDIN))
Variable.
Buffer temporaire utilis‚ par les primitives d'entr‚es /
sorties.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE ((STDIN)) 0 C,

 (AUXOUT)
Primitive de sortie vers le p‚riph‚rique auxiliaire
standard, en g‚n‚ral 'COM1:'.
@SYNTAXE = Syntaxe : car (AUXOUT)
car est l'octet … envoyer.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (AUXOUT)  ( car --- )
  AX POP
  ' ((STDIN)) >>BODY # DX MOV
  AL 0 [DX] MOV
  AUXOUT # BX MOV
  1 # CX MOV
  64 # AH MOV
  33 INT
  NEXT
END-CODE

 (AUXIN)
Primitive de lecture du p‚riph‚rique auxiliaire
standard,
en g‚n‚ral 'COM1:'.
@SYNTAXE = Syntaxe : (AUXIN)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (AUXIN)
  AX AX XOR
  ' EOF? >>BODY # BX MOV
  AX 0 [BX] MOV
  ' ((STDIN)) >>BODY # DX MOV
  AL 0 [DX] MOV
  AUXIN # BX MOV
  1 # CX MOV
  63 # AH MOV
  33 INT
  U<<
  IF
    -1 # BX MOV
    ' EOF? >>BODY # DX MOV  ( Si le 'Carry flag' est … un,
alors fin )
    BX 0 [DX] MOV          ( du fichier. )
    3 # BX MOV
    ' AUXIN >>BODY # DX MOV
    BX 0 [DX] MOV
  THEN
  ' ((STDIN)) >>BODY # DX MOV
  0 [DX] AL MOV
  AH AH XOR
  1PUSH
END-CODE
empile l'octet lu.

 (STDPRN)
Primitive de sortie vers le p‚riph‚rique d'impression
standard,
en g‚n‚ral 'PRN:'.
@SYNTAXE = Syntaxe : car (STDPRN)
car est l'octet … envoyer.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (STDPRN)  ( car --- )
  AX POP
  ' ((STDIN)) >>BODY # DX MOV
  AL 0 [DX] MOV
  STDPRN # BX MOV
  1 # CX MOV
  64 # AH MOV
  33 INT
  NEXT
END-CODE

 (STDOUT)
Primitive de sortie vers le p‚riph‚rique de sortie
standard,
en g‚n‚ral 'CON:'.
@SYNTAXE = Syntaxe : car (STDOUT)
car est l'octet … envoyer.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (STDOUT)  ( car --- )
  STDOUT # CX MOV
  1 # AX CMP
  0=
  IF
    AX POP      ( Le handler 1 correspond … l'‚cran )
    AL AH MOV
    DX POP
    33 INT
    NEXT
  THEN
  AX POP
  AX POP
  ' ((STDIN)) >>BODY # DX MOV
  AL 0 [DX] MOV
  STDOUT # BX MOV
  1 # CX MOV
  64 # AH MOV
  33 INT
  NEXT
END-CODE

 (STDIN)
Primitive de lecture du p‚riph‚rique d'entr‚e
standard,
en g‚n‚ral le clavier.
@SYNTAXE = Syntaxe : (STDIN)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (STDIN)  ( --- car )
  AX AX XOR
  ' EOF? >>BODY # BX MOV
  AX 0 [BX] MOV
  STDIN # CX MOV
  CX AX CMP
  0=
  IF
    AX POP      ( Le handler z‚ro correspond au clavier )
    AL AH MOV
    33 INT
    AH AH XOR
    1PUSH
  THEN
  ' ((STDIN)) >>BODY # DX MOV
  AL 0 [DX] MOV
  AX POP
  CX BX MOV
  1 # CX MOV
  63 # AH MOV
  33 INT
  U<<
  IF
    -1 # BX MOV
    ' EOF? >>BODY # DX MOV  ( Si le 'Carry flag' est … un,
alors fin )
    BX 0 [DX] MOV          ( du fichier. )
    BX BX XOR
    ' STDIN >>BODY # DX MOV
    BX 0 [DX] MOV
  THEN
  ' ((STDIN)) >>BODY # DX MOV
  0 [DX] AL MOV
  AH AH XOR
  1PUSH
END-CODE
Empile l'octet lu.

 VOCABULARY
Cr‚ation d'un vocabulaire dans le vocabulaire
CURRENT.
@SYNTAXE = Syntaxe : VOCABULARY nom_vocabulaire
Quand <<nom_vocabulaire>> est utilis‚, les mots qui
lui sont attach‚s
d‚finissent le vocabulaire de CONTEXT.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : VOCABULARY  ( nom_vocabulaire --- )
  CREATE
  #THREADS 0
  DO
    0 ,              ( Cr‚ation des THREADS )
  LOOP
  HERE VOC-LINK @ ,  ( Mise … jour du chainage des vocabulaires
)
  VOC-LINK !
;USES (VOC) ,

 DEFINITIONS
Le premier vocabulaire de CONTEXT devient le
vocabulaire CURRENT.
@SYNTAXE = Syntaxe : [nom_vocabulaire] DEFINITIONS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DEFINITIONS  ( --- )
  CONTEXT @
  CURRENT !
;

 HERE
Renvoi l'adresse du prochain octet libre dans le
dictionnaire.
@SYNTAXE = Syntaxe : HERE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : HERE  ( --- adr )
  DP @
;

 STRING
Cr‚ation de chaines de caractŠres.
@SYNTAXE = Syntaxe : longueur_maxi STRING nom_chaine
Cr‚‚ la chaine 'nom_chaine', de longueur
'longueur_maxi'.
… l'‚x‚cution de nom_chaine, l'adresse de d‚but de la
chaine, ainsi que sa longueur actuelle sont renvoy‚s.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : STRING ( longueur_maxi nom_chaine --- )
  CREATE
    DUP C,
    0 C,    ( On r‚serve une place pour la longueur courante )
    ALLOT
  DOES>>
    1+ DUP C@
    SWAP 1+
    SWAP    ( adr+2 long_courante --- )
;

 STRLEN
Renvoi la longueur maximale d'une chaine de
caractŠres cr‚‚e avec STRING.
@SYNTAXE = Syntaxe : nom_chaine STRLEN
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : STRLEN  ( adr_chaine long_courante ---
adr_chaine long_maxi )
  DROP DUP 2- C@
;

 ."
Affichage d'une chaine.
@SYNTAXE = Syntaxe : ." chaine"
Affiche la <<chaine>> termin‚e par un guillemet.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ."  ( chaine --- )
  STATE @
  IF
    COMPILE (.")
    ,"
  ELSE
    ASCII " WORD
    COUNT TYPE
  THEN
;
IMMEDIATE

 !"
Stockage de chaines,cr‚‚es avec STRING.
@SYNTAXE = Syntaxe : adr_chaine_source long adr_dest long !"
Stocke la chaine situ‚e … adr_chaine_source …
l'adresse adr_dest.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : !"  ( adr_chaine_source long adr_dest long --- )
  DROP 2- DUP C@
  ROT MIN SWAP 1+ PLACE
;

 ,"
Compilation d'une chaine.
@SYNTAXE = Syntaxe : ," chaine"
Compile la <<chaine>> … la suite du dictionnaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ,"  ( chaine --- )
  ASCII " PARSE
  TUCK HERE PLACE
  1+ ALLOT
  [COMPILE] ALIGN
;

 "
Compilation d'une chaine dans une d‚finition.
@SYNTAXE = Syntaxe : " chaine"
Compile <<chaine>>.
Son adresse et sa longueur sont renvoy‚s … l'‚x‚cution.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : "  ( chaine --- )
  STATE @
  IF
    COMPILE (")
    ,"
  ELSE
    ASCII " PARSE
  THEN
;
IMMEDIATE

 LITERAL
Compilation d'entiers.
@SYNTAXE = Syntaxe : n LITERAL
Compile n, en tant que nombre, dans une d‚finition.
A l'‚x‚cution le nombre est envoy‚ sur la pile.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : LITERAL  ( n --- )
  COMPILE (LIT)
  ,
;
IMMEDIATE

 DLITERAL
Compilation de doubles.
@SYNTAXE = Syntaxe : d DLITERAL
Compile l'entier double d, en tant que nombre, dans
une d‚finition.
A l'‚x‚cution le nombre est envoy‚ sur la pile.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DLITERAL  ( d --- )
  COMPILE (DLIT)
  SWAP , ,
;
IMMEDIATE

 (IS)
Primitive.
Utilis‚e par IS.
Affectation d'un mot vectoris‚.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (IS)
  R@ @ >>BODY !
  R>> 2+ >>R
;

 IS
Affectation d'un mot vectoris‚.
@SYNTAXE = Syntaxe : cfa_mot IS mot
Stocke cfa_mot dans le PFA de <<mot>>.
Utilis‚ Pour modifier une CONSTANT, une VARIABLE, un CREATE ou
un DEFER.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : IS  ( cfa_mot mot --- )
  STATE @
  IF
    COMPILE (IS)
  ELSE
    ' >>BODY !
  THEN
;
IMMEDIATE

 (DEFER)
Primitive.
Partie ‚x‚cution des mots cr‚‚s avec DEFER.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (DEFER)
  W INC
  W INC
  0 [W] W MOV
  0 [W] JMP
END-CODE

 DEFER
Cr‚ation de mots vectoris‚s.
@SYNTAXE = Syntaxe : DEFER mot
Cr‚ation d'un <<mot>>. Le PFA du mot cr‚‚ contient le
CFA de NOOP.
De sorte que l'‚x‚cution de ce mot ne fait rien.
Le PFA de <<mot>> peut ˆtre initialis‚ avec IS.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DEFER  ( mot --- )
  ' NOOP LITERAL CONSTANT
;USES (DEFER) ,

 2VARIABLE
Cr‚ation d'une variable double.
@SYNTAXE = Syntaxe : 2VARIABLE nom_variable
Cr‚‚ la variable double nom_variable, avec son
contenu initialis‚ … z‚ro.
A l'‚x‚cution, empile l'adresse de nom_variable.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : 2VARIABLE  ( nom_variable --- )
  CREATE
  0 DUP , ,
;USES (2VARIABLE) ,

 (2VARIABLE)
-Primitive.
Partie ‚x‚cution des mots cr‚‚s par 2VARIABLE.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (2VARIABLE)
  W INC
  W INC
  W PUSH
  NEXT
END-CODE

 VARIABLE
Cr‚ation d'une variable simple.
@SYNTAXE = Syntaxe : VARIABLE nom_variable
Cr‚‚ la variable simple nom_variable, avec son
contenu initialis‚ … z‚ro.
A l'‚x‚cution, empile l'adresse de nom_variable.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : VARIABLE  ( nom_variable --- )
  CREATE
  0 ,
;USES (VARIABLE) ,

 (VARIABLE)
Primitive.
Partie ‚x‚cution des mots cr‚‚s avec VARIABLE.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (VARIABLE)
  W INC
  W INC
  W PUSH
  NEXT
END-CODE

 CONSTANT
Cr‚ation d'une constante simple.
@SYNTAXE = Syntaxe : valeur CONSTANT nom_constante
Cr‚‚ la constante simple nom_constante, avec son
contenu initialis‚ avec valeur.
A l'‚x‚cution, empile la valeur de nom_constante.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CONSTANT  ( nom_constante --- )
  CREATE
  ,
;USES (CONSTANT) ,

 (CONSTANT)
Primitive.
Partie ‚x‚cution des mots cr‚‚s avec CONSTANT.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (CONSTANT)
  W INC
  W INC
  0 [W] AX MOV
  1PUSH
END-CODE

 2CONSTANT
Cr‚ation d'une constante double.
@SYNTAXE = Syntaxe : valeur_d 2CONSTANT nom_constante
Cr‚‚ la constante doublee nom_constante, avec son
contenu initialis‚ avec valeur_d.
A l'‚x‚cution, empile la valeur de nom_constante.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : 2CONSTANT  ( nom_constante --- )
  CREATE
  , ,
;USES (2CONSTANT) ,

 (2CONSTANT)
Primitive.
Partie ‚x‚cution des mots cr‚‚s avec 2CONSTANT.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (2CONSTANT)
  2 [W] AX MOV
  4 [W] DX MOV
  2PUSH
END-CODE

 CREATE
Cr‚ation d'un entˆte de d‚finition FORTH.
@SYNTAXE = Syntaxe : CREATE nom_def
cr‚‚ un entˆte de nom <<nom_def>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CREATE  ( nom_def --- )
  BL WORD
  ?UPPERCASE "CREATE
;

 (CREATE)
Primitive. Partie ‚x‚cution des mots cr‚‚s avec
CREATE.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (CREATE)  ( --- w )
  W INC
  W INC
  W PUSH
END-CODE

 "CREATE
Cr‚ation effective d'un entˆte de d‚finition FORTH.
@SYNTAXE = Syntaxe : adr_chaine "CREATE
Cr‚‚ un entˆte avec le nom stock‚ … adr_chaine.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : "CREATE  ( adr_chaine --- )
  COUNT [COMPILE] ALIGN
  HERE 2+ PLACE     ( Transfert du nom dans le dictionnaire )
  0 ,               ( R‚servation du LFA )
  HERE LAST !       ( LAST pointe sur le nouveau NFA )
  WARNING @
  IF
    HERE FIND       ( Le nouveau nom existe-t'il d‚j… ? )
    IF
      BOLD HERE
      COUNT TYPE
      ."  n'est pas unique"
      ATTOFF CR DROP
    THEN
  THEN
  HERE CURENT @     ( Modification des liaisons )
  HASH DUP @
  HERE 2- !         ( LFA cr‚‚ )
  HERE 2- SWAP !    ( THREAD modifi‚ )
  HERE DUP C@
  WIDTH @ MIN
  1+ ALLOT          ( Compilation du NFA )
  160 SWAP CSET     ( Masquage du dernier octet du NFA )
  128 HERE 1- CSET  ( Masquage du premier octet du NFA )
  [COMPILE] ALIGN
  0 ,
;USES (CREATE) ,

 EVEN
Rend un nombre pair, s'il ne l'est pas d‚j….
@SYNTAXE = Syntaxe : n EVEN
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : EVEN  ( n --- n')
  DUP 1 AND +
;

 [']
Permet compiler un CFA dans une d‚finition.
@SYNTAXE = Syntaxe : ['] nom_def
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : [']  ( nom_def --- )
  '
  LITERAL
;
IMMEDIATE

 CONTROL
Permet la compilation d'un caractŠre de contr“le
(code ASCII compris entre 0 et 32).
@SYNTAXE = Syntaxe : CONTROL car
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CONTROL  ( car --- )
  BL WORD 1+ C@
  ASCII @ -
  STATE @
  IF
    LITERAL
  THEN
;
IMMEDIATE

 ASCII
Permet de compiler le code d'un caractŠre dans une
d‚finition.
@SYNTAXE = Syntaxe : ASCII car
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ASCII  ( car --- )
  BL WORD 1+ C@
  STATE @
  IF
    LITERAL
  THEN
;
IMMEDIATE

 [COMPILE]
Permet de compiler le CFA d'un mot IMMEDIAT … la fin
du dictionnaire pendant une d‚finition.
@SYNTAXE = Syntaxe : [COMPILE] nom_def
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : [COMPILE]  ( nom_def --- )
  '
  ,
;
IMMEDIATE

 IMMEDIATE
Rend imm‚diat le dernier mot cr‚‚.
@SYNTAXE = Syntaxe : IMMEDIATE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : IMMEDIATE  ( --- )
  64 LAST @ CTOGGLE
;

 COMPILE
Compile un CFA … la fin du dictionnaire.
@SYNTAXE = Syntaxe : COMPILE nom_def
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : COMPILE  ( nom_def --- )
  R>> DUP 2+ >>R
  @ ,
;

 C,
Alloue un octet … la fin du dictionnaire.
@SYNTAXE = Syntaxe : n C,
place la valeur n (comprise entre 0 et 255) … la fin
du dictionnaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : C,  ( n --- )
  HERE C!
  1 ALLOT
;

 ,
Alloue un mot … la fin du dictionnaire.
@SYNTAXE = Syntaxe : n ,
place la valeur n … la fin du dictionnaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ,  ( n --- )
  HERE !
  2 ALLOT
;

 ALLOT
Alloue un ou plusieurs octets … la fin du
dictionnaire.
@SYNTAXE = Syntaxe : n_octets ALLOT
R‚serve <<n_octets>> octets … la fin du dictionnaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ALLOT  ( n_octets --- )
  DP +!
;

 [
Passage du systŠme FORTH en mode INTERPRETATION (RUN-
TIME).
Les mots qui suivent sont ‚x‚cut‚s imm‚diatement.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : [  ( --- )
  STATE OFF
;
IMMEDIATE

 ]
Passage du systŠme FORTH en mode COMPILATION
(COMPILE-TIME).
Les mots qui suivent sont compil‚s.
Les mots IMMEDIATS sont ‚x‚cut‚s.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ]  ( --- )
  STATE ON
  BEGIN
    ?STACK
    DEFINED DUP
    IF
      0<<          ( Est-ce un mot IMMEDIAT ? )
      IF
        EXECUTE   ( Oui, on l'‚x‚cute )
      ELSE
        ,         ( Non, compilation de son CFA )
      THEN
    ELSE
      DROP NUMBER
      DOUBLE?     ( Est-ce un double ? )
      IF
        DLITERAL  ( Oui, compilation )
      ELSE
        DROP
        LITERAL   ( Non, c'est un simple )
      THEN
    THEN
    TRUE DONE?
  UNTIL
;

 ;
Termine une d‚finition FORTH, et repasse en mode
INTERPRETATION.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ;  ( --- )
  ?CSP
  COMPILE EXIT
  [COMPILE] REVEAL  ( Fait apparaitre la nouvelle d‚finition )
  [COMPILE] [
;USES (:) ,
IMMEDIATE

 :
Cr‚ation d'une d‚finition FORTH.
@SYNTAXE = Syntaxe : : nom_def ...
Cr‚‚ la d‚finition nom_def.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : :  ( nom_def --- )
  !CSP
  CURRENT @
  CONTEXT !
  CREATE
  [COMPILE] HIDE
  ]
;

 (:)
Primitive.
Partie ‚x‚cution des d‚finitions cr‚‚es avec ':'.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (:)  ( --- )
  W INC
  W INC
  RP DEC
  RP DEC
  IP 0 [RP] MOV
  W IP MOV
  NEXT
END-CODE

 (DOES>>)
Primitive.
Utilis‚e par DOES>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = LABEL (DOES>>)
  RP DEC
  RP DEC
  IP 0 [RP] MOV
  IP POP
  IP AX MOV
  1 # AX AND
  AX IP ADD
  W INC
  W INC
  W PUSH
  NEXT

 DOES>>
Permet de d‚finir la partie ‚x‚cution d'un mot de
d‚finition,
cr‚‚ avec CREATE.
@SYNTAXE = Syntaxe : CREATE nom_def ... DOES>> ... ;
Utilisation : nom_def nom_ex
la partie ‚x‚cution de nom_ex correspondra … ce qui suit
DOES>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DOES>>
  COMPILE (;CODE)
  232 C,
  (DOES>>)
  HERE 2+ - ,
  [COMPILE] ALIGN
;
IMMEDIATE

 ;USES
Permet d'ajouter … la fin d'une d‚finition FORTH,
l'appel
… une d‚finition en code machine (cr‚‚e avec CODE ou LABEL).
@SYNTAXE = Syntaxe : : nom_def ... ;USES def_code ,
nom_def peut s'utiliser de la fa‡on suivante :
  nom_def nom_ex
Le CFA de nom_ex pointera sur def_code.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ;USES
  ?CSP
  ['] (:) @ LAST @ NAME>> !  ( La d‚finition cr‚‚e est une
d‚finition ':' )
  COMPILE (;USES)           ( Compilation de la primitive
d'‚x‚cution )
  '                         ( Compilation de def_code )
  [COMPILE] [               ( On repasse en mode interpr‚tation
)
  [COMPILE] REVEAL          ( On montre le mot cr‚‚ )
;
IMMEDIATE

 REVEAL
Rend apparent (pour WORDS ou FIND, par exemple) le
dernier
mot cr‚‚, qui n'est pas n‚c‚ssairement une d‚finition valide.
@SYNTAXE = Syntaxe : REVEAL
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : REVEAL  ( --- )
  LAST @ DUP
  N>>LINK SWAP
  CURRENT @
  HASH !
;
IMMEDIATE

 HIDE
Cache le dernier mot cr‚‚.
@SYNTAXE = Syntaxe : HIDE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : HIDE  ( --- )
  LAST @ DUP
  N>>LINK @
  SWAP CURRENT @
  HASH !
;
IMMEDIATE

 EXIT
Primitive.
Retour … la d‚finition pr‚c‚dente.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE EXIT  ( --- )
  0 [RP] IP MOV
  RP INC
  RP INC
  NEXT
END-CODE

 CODE-REF
Primitive.
R‚f‚rence au segment de code FORTH.
Seule r‚f‚rence relogeable du systŠme.
Utilis‚e par SAVE-SYSTEM pour la g‚n‚ration d'un fichier
‚x‚cutable.
@DEF_FORTH = D‚finition en FORTH
@PROGRAMME = LABEL CODE-REF
    0 # DX MOV        \ 0 est remplac‚ par l'adresse de segment
de CODE
    RET               \ de PGForth, au lancement de celui-ci.

 >>NEXT
Primitive.
Saut vers le point d'entr‚e de l'interpr‚teur FORTH.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE >>NEXT  ( --- )
  _NEXT #) JMP
END-CODE

 APUSH
Empile le contenu du registre AX.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = LABEL APUSH
  AX PUSH

 DPUSH
Empile le contenu du registre DX et du registre AX.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = LABEL DPUSH
  DX PUSH
LABEL APUSH
  AX PUSH

 EXECUTE
Ex‚cute le mot dont le CFA est sur la pile.
@SYNTAXE = Syntaxe : cfa EXECUTE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE EXECUTE  ( cfa --- )
  W POP
  0 [W] JMP
END-CODE

 FORGET
Efface une d‚finition du dictionnaire, ainsi que
celles qui suivent.
@SYNTAXE = Syntaxe : FORGET nom_def
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : FORGET  ( nom_def --- )
  BL WORD ?UPPERCASE
  DUP CURRENT @
  HASH @ (FIND) 0=
  ?MISSING
  >>LINK 2- (FORGET)
;

 (FORGET)
Primitive.
Utilis‚e par FORGET.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (FORGET)
  DUP FENCE @
  U<< ABORT" Zone prot‚g‚e par FENCE"
  DUP VOC-LINK @
  BEGIN
    2DUP U<<
  WHILE
    @
  REPEAT
  DUP VOC-LINK !
  NIP
  BEGIN
    DUP
  WHILE
    2DUP #THREADS
    2* - TRIM @
  REPEAT
  DROP 2+ DP !
;

 TRIM
Primitive.
Utilis‚e par (FORGET)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : TRIM
  #THREADS 0
  DO
    2DUP @
    BEGIN
      2DUP U>> NOT
    WHILE
      @
    REPEAT
    NIP OVER ! 2+
  LOOP
  2DROP
;

 ?MISSING
Vecteur.
Fait r‚f‚rence au mot (?MISSING).
Affiche un message d'erreur si le flag pr‚sent sur la pile est
VRAI.
@SYNTAXE = Syntaxe : flag ?MISSING
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER ?MISSING

 (?MISSING)
Affiche un message d'erreur si le flag pr‚sent sur la
pile est VRAI.
Mot vectoris‚ par ?MISSING.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (?MISSING)  ( flag --- )
  IF
    BOLD 'WORD
    COUNT TYPE ATTOFF
    TRUE ABORT"  est inexistant"
  THEN
;

 ' ( TICK )
Empile le CFA d'un mot.
@SYNTAXE = Syntaxe : ' mot
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : '  ( mot --- )
  DEFINED
  0= ?MISSING
;

 DEFINED
Permet de savoir si un mot est d‚fini.
@SYNTAXE = Syntaxe : DEFINED mot
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DEFINED ( mot --- adr flag )
  BL WORD
  ?UPPERCASE
  FIND
;
Informations renvoy‚es :
Si le mot n'existe pas, adr correspond … 'WORD et flag = 0.
Si le mot existe, mais n'est pas imm‚diat, adr correspond … son
CFA et flag = 1.
Si le mot existe et est imm‚diat, adr correspond … son CFA et
flag = -1.

 ?UPPERCASE
Conversion conditionnelle en majuscules.
@SYNTAXE = Syntaxe : adr_chaine ?UPPERCASE
Si le contenu de la variable CAPS est VRAI,
la chaine stock‚e … adr_chaine sera convertie en majuscules.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?UPPERCASE  ( adr_chaine --- )
  CAPS @
  IF
    DUP COUNT UPPER
  THEN
;

 (FIND)
Primitive.
Utilis‚e par FIND.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (FIND)
  DX POP
  DX DX OR
  0=
  IF
    AX AX SUB
    1PUSH
  THEN
  BEGIN
    DX BX MOV
    BX INC
    BX INC
    DI POP
    DI PUSH
    0 [BX] AL MOV
    0 [DI] AL XOR
    31 # AL AND
    0=
    IF
      BEGIN
        BX INC
        DI INC
        0 [BX] AL MOV
        0 [DI] AL XOR
        0<<>>
      UNTIL
      127 # AL AND
      0=
      IF
        DI POP
        BX INC
        BX AX MOV
        1 # AX AND
        AX BX ADD
        BX PUSH
        DX BX MOV
        BX INC
        BX INC
        0 [BX] AL MOV
        64 # AL AND
        0<<>>
        IF
          -1 # AX MOV
        ELSE
          1 # AX MOV
        THEN
        1PUSH
      THEN
    THEN
    DX BX MOV
    0 [BX] DX MOV
    DX DX OR
    0=
  UNTIL
  AX AX SUB
  1PUSH
END-CODE

 FIND
Recherche d'un mot.
@SYNTAXE = Syntaxe : FIND mot
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : FIND  ( mot --- cfa flag )
  DUP C@
  IF
    PRIOR OFF
    FALSE #VOCS 0
    DO
      DROP CONTEXT I 2*
      + @ DUP
      IF
        DUP PRIOR @
        OVER PRIOR !
        =
        IF
          DROP FALSE
        ELSE
          OVER SWAP HASH
          @ (FIND)
          DUP ?LEAVE
        THEN
      THEN
    LOOP
  ELSE
    DROP
    END? ON
    NOOP -1
  THEN
;

 HASH
Hashage d'un vocabulaire.
Renvoi le brin (THREAD) dans lequel est situ‚ le mot recherch‚.
@SYNTAXE = Syntaxe : adr_chaine adr_voc HASH
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE HASH  ( adr_chaine adr_voc --- thread )
  CX POP
  BX POP
  0 [BX] AL MOV
  3 # AX AND
  AX SHL
  CX AX ADD
  1PUSH
END-CODE

 INTERPRET
Lance l'interpr‚tation du flux d'entr‚e, d‚fini par
SOURCE.
@SYNTAXE = Syntaxe : INTERPRET
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : INTERPRET  ( --- )
  BEGIN
    ?STACK DEFINED
    IF
      EXECUTE
    ELSE
      NUMBER DOUBLE?
      NOT
      IF
        DROP
      THEN
    THEN
    FALSE
    DONE?
  UNTIL
;

 RUN
Interpr‚tation du flux d'entr‚e, d‚fini par SOURCE.
@SYNTAXE = Syntaxe : RUN
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : RUN  ( --- )
  STATE @
  IF
    ]
    STATE @ NOT
    IF
      INTERPRET
    THEN
  ELSE
    INTERPRET
  THEN
;

 >>LINK
Empile le LFA du mot dont le CFA est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : cfa >>LINK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : >>LINK  ( cfa --- lfa )
  >>NAME N>>LINK
;

 >>NAME
Empile le NFA du mot dont le CFA est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : cfa >>NAME
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : >>NAME  ( cfa --- nfa )
  -1 TRAVERSE
  -1 TRAVERSE
;

 >>BODY
Empile le PFA du mot dont le CFA est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : cfa >>BODY
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : >>BODY  ( cfa --- pfa )
  2+
;

 LINK>>
Empile le CFA du mot dont le LFA est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : lfa LINK>>
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : LINK>>  ( lfa --- cfa )
  L>>NAME NAME>>
;

 NAME>>
Empile le CFA du mot dont le NFA est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : nfa NAME>>
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : NAME>>  ( nfa --- cfa )
  1 TRAVERSE
  1+ EVEN
;

 BODY>>
Empile le CFA du mot dont le PFA est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : pfa BODY>>
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BODY>>  ( pfa --- cfa )
  2-
;

 L>>NAME
Empile le NFA du mot dont le LFA est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : lfa L>>NAME
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : L>>NAME  ( lfa --- nfa )
  2+
;

 N>>LINK
Empile le LFA du mot dont le NFA est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : nfa N>>LINK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : N>>LINK  ( nfa --- lfa )
  2-
;

 TRAVERSE
Primitive.
d‚placements dans un en-tˆte de d‚finition FORTH.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE TRAVERSE  ( adresse sens --- adresse' )
  CX POP
  BX POP
  CX BX ADD
  BEGIN
    0 [BX] AL MOV
    128 # AL AND
    0=
  WHILE
    CX BX ADD
  REPEAT
  BX PUSH
  NEXT
END-CODE

 DONE?
Teste la fin du flux d'entr‚e, ou le changement
d'‚tat du systŠme
FORTH, d‚fini par la variable STATE.
@SYNTAXE = Syntaxe : n DONE?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DONE?  ( n --- flag )
  STATE @ <<>>
  END? @ OR
  END? OFF
;

 ?STACK
Contr“le des piles FORTH.
@SYNTAXE = Syntaxe : ?STACK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?STACK  ( --- )
  SP@ SP0 @
  >> ABORT" La pile est vide"
  RP@ RP0 @
  >> ABORT" La pile de retour est vide"
  SP@ RP0 @ 256 +
  << ABORT" La pile est pleine"
  RP@ 256
  << ABORT" La pile de retour est pleine"
;

 (STATUS)
Affichage du statut du systŠme si la variable STATUS?
est … ON.
Vectoris‚ par STATUS.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (STATUS)  ( --- )
  CR STATUS? @
  IF
    OBASE @ IBASE @
    OBASE DECIMAL
    ." SP = "
    DEPTH 2- . CR
    ." RP = "
    RDEPTH 1- . CR
    2DUP 2 0
    DO
      I
      IF
        ." Base de sortie "
      ELSE
        ." Base d' entr‚e "
      THEN
      DUP 2 =
      IF
        ." binaire"
      ELSE
        DUP 8 =
        IF
          ." octale"
        ELSE
          DUP 10 =
          IF
            ." d‚cimale"
          ELSE
            DUP 16 =
            IF
              ." hexad‚cimale"
            ELSE
              DUP .
            THEN
          THEN
        THEN
      THEN
      CR DROP
    LOOP
    IBASE ! OBASE !
  THEN
;

 STATUS
Vecteur.
Affiche le statut du systŠme.
@SYNTAXE = Syntaxe : STATUS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER STATUS

 QUIT
Boucle g‚n‚rale d'interpr‚tation FORTH.
Initialise le systŠme et interprŠte le flux d'entr‚e.
@SYNTAXE = Syntaxe : QUIT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : QUIT  ( --- )
  TIB 'TIB !
  [
  BEGIN
    RP0 @ RP!
    STATUS
    QUERY RUN
    STATE @ NOT
    IF
      BOLD ." Ok"
      ATTOFF
    THEN
  AGAIN
;

 BOOT
Vecteur.
Mot ‚x‚cut‚ automatiquement au lancement de PGForth.
@SYNTAXE = Syntaxe : BOOT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER BOOT

 BYE
Sort de FORTH et retourne au DOS.
@SYNTAXE = Syntaxe : BYE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
CODE BYE
  SS-REG # AX MOV   ( Restitution du contexte )
  AX SS MOV
  SP-REG # AX MOV
  AX SP MOV
  BP-REG # AX MOV
  AX BP MOV
  DS POP
  4C00 # AX MOV
  21 INT
END-CODE
IBASE DECIMAL

 COLD
D‚marrage … froid du systŠme.
@SYNTAXE = Syntaxe : COLD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : COLD  ( --- )
  DTA SET-DTA
  BOOT         ( Ex‚cution du vecteur BOOT )
  WARM QUIT
;

 WARM
D‚marrage … chaud du systŠme.
@SYNTAXE = Syntaxe : WARM
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : WARM  ( --- )
  TRUE
  ABORT" D‚marrage du systŠme"
;

 ABORT"
Restitution du contexte et affichage d'un message
d'erreur.
@SYNTAXE = Syntaxe : ABORT" message"
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ABORT"  ( --- )
  COMPILE (ABORT")
  ,"
;
IMMEDIATE

 (ABORT")
Primitive.
Utilis‚e par ABORT".
Affiche un message et restitue le contexte si le flag est VRAI.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (ABORT")  ( flag --- )
  R@ COUNT
  ROT ?ERROR
  R>> COUNT +
  EVEN >>R
;

 (?ERROR)
Primitive.
Vectoris‚e par ?ERROR.
Affichage d'un message, en fonction du flag pr‚sent sur la
pile,
Restitution du contexte FORTH, fermeture des fichiers ouverts.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (?ERROR)  ( adr n flag --- )
  IF
    PRINTING OFF
    BOLD TYPE ATTOFF
    SP0 @ SP!
    HANDLE @
    IF
      ." dans le fichier "
      PATHNAME COUNT
      BOLD TYPE ATTOFF
      ." , ligne "
      LINE# @ BOLD . ATTOFF
      HANDLE OFF
    THEN
    ALLCLOSE
    QUIT
  ELSE
    2DROP
  THEN
;

 ?ERROR
Vecteur.
Affiche un message d'erreur, ainsi que la ligne de celle-ci
(dans le cas d'une erreur survenue pendant la lecture d'un
fichier),
si le flag pr‚sent sur la pile est VRAI.
@SYNTAXE = Syntaxe : adr n flag ?ERROR
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER ?ERROR

 (ABORT)
Primitive.
Vectoris‚e par ABORT.
Restitution de la pile de donn‚es, fermeture des fichiers,
r‚assignation du clavier et retour au mode interpr‚tation.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (ABORT)  ( --- )
  SP0 @ SP!
  ALLCLOSE
  HANDLE OFF
  QUIT
;

 ABORT
Vecteur.
Restitution de la pile de donn‚es, fermeture des fichiers,
r‚assignation du clavier et retour au mode interpr‚tation.
@SYNTAXE = Syntaxe : ABORT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER ABORT

 NOOP
Ne fait rien.
Utilis‚, entre autre, pour initialiser les mots vectoris‚s.
@SYNTAXE = Syntaxe : NOOP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE NOOP  ( --- )
  NEXT
END-CODE

 >>TYPE
Affichage d'une chaine.
Equivalent … TYPE.
@SYNTAXE = Syntaxe : adresse long >>TYPE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : >>TYPE  ( adresse long --- )
  TUCK $PAD SWAP CMOVE
  $PAD SWAP TYPE
;

 .(
Affichage de commentaires.
Affiche le commentaire situ‚ entre parenthŠses.
@SYNTAXE = Syntaxe : .( ... commentaires ... )
La parenthŠse fermente est OBLIGATOIRE et doit Štre
pla‡‚e sur la mˆme ligne.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : .(  ( --- )
  ASCII ) PARSE TYPE
;

 (
Permet l'insertion de Commentaires dans un source.
@SYNTAXE = Syntaxe : ( ... commentaires ... )
La parenthŠse fermente est OBLIGATOIRE et doit Štre
pla‡‚e sur la mˆme ligne.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (  ( --- )
  ASCII ) PARSE 2DROP
;
IMMEDIATE

 \
Ignore le reste de la ligne courante.
@SYNTAXE = Syntaxe : \ ...
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : \   ( --- )
  >>IN @ NEGATE
  C/L MOD  >>IN +!
;
IMMEDIATE

 WORD
Isole du flux d'entr‚e un mot d‚limit‚ par un ou
plusieurs caractŠres.
@SYNTAXE = Syntaxe : s‚parateur WORD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : WORD  ( s‚parateur --- adresse )
  PARSE-WORD 'WORD PLACE
  'WORD DUP COUNT +
  BL SWAP C!
;

 'WORD
Renvoi l'adresse de la zone de donn‚es utilis‚e par
WORD.
@SYNTAXE = Syntaxe : 'WORD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : 'WORD  ( --- adr )
  HERE 256 +
;

 PARSE
Isole un mot d‚limit‚ par un caractŠre, dans le flux
d'entr‚e.
@SYNTAXE = Syntaxe : s‚parateur PARSE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : PARSE  ( s‚parateur --- adresse long )
  >>R SOURCE >>IN @ /STRING
  OVER SWAP R>> SCAN >>R
  OVER - DUP R>> 0<<>> -
  >>IN +!
;
Empile l'adresse du mot, ainsi que sa longueur.

 PARSE-WORD
Primitive.
Isole un mot d‚limit‚ par un s‚parateur, dans le flux d'entr‚e.
Utilis‚e par WORD.
@SYNTAXE = Syntaxe : s‚parateur PARSE-WORD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : PARSE-WORD  ( s‚parateur --- adresse long )
  >>R SOURCE TUCK
  >>IN @ /STRING
  R@ SKIP OVER SWAP
  R>> SCAN >>R OVER -
  ROT R>> DUP 0<<>> + -
  >>IN !
;
Empile l'adresse du mot, ainsi que sa longueur.

 /STRING
Troncature … droite d'une chaine de caractŠres.
@SYNTAXE = Syntaxe : adresse long pos /STRING
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE /STRING  ( adresse long pos --- adresse'
long' )
  BX POP
  AX POP
  DX POP
  AX BX CMP
  >>
  IF
    AX BX MOV
  THEN
  BX DX ADD
  BX AX SUB
  2PUSH
END-CODE

 SCAN
Recherche de la premiŠre occurence dans une chaine.
@SYNTAXE = Syntaxe : adr_chaine longueur car SCAN
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = ASSEMBLER
LABEL DONE
  CX PUSH
  NEXT
CODE SCAN  ( adr_chaine longueur car --- adr long )
  AX POP
  CX POP
  DONE JCXZ
  DI POP
  CODE-REF #) CALL
  DX ES MOV
  CX BX MOV
  REP BYTE SCAS
  0=
  IF
    CX INC
    DI DEC
  THEN
  DI PUSH
  CX PUSH
  NEXT
END-CODE
Informations renvoy‚es :
adr  est l'adresse du caractŠre recherch‚
long est la longueur de la chaine restante, ou 0 si le
caractŠre n'a pas ‚t‚ trouv‚.

 SKIP
Recherche de la sous-chaine restante.
@SYNTAXE = Syntaxe : adr_chaine longueur car SKIP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE SKIP  ( adr_chaine longueur car --- adr long
)
  AX POP
  CX POP
  DONE JCXZ
  DI POP
  CODE-REF #) CALL
  DX ES MOV
  REPZ BYTE SCAS
  0<<>>
  IF
    CX INC
    DI DEC
  THEN
  DI PUSH
  CX PUSH
  NEXT
END-CODE
Empile l'adresse de la sous-chaine restante aprŠs le
caractŠre car.

 (SOURCE)
Primitive.
Vectoris‚e par SOURCE.
Renvoi l'adresse et la longueur du flux d'entr‚e.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (SOURCE)  ( --- adr long )
  BUFFER COUNT
;

 SOURCE
Vecteur.
Renvoi l'adresse du flux d'entr‚e.
@SYNTAXE = Syntaxe : SOURCE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER SOURCE

 QUERY
Saisie au clavier d'une chaine, et stockage de celle-
ci dans le tampon TIB.
@SYNTAXE = Syntaxe : QUERY
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : QUERY  ( --- )
  'TIB @ C/L EXPECT
  SPAN @ #TIB C!
  >>IN OFF
;

 EXPECT
Attend l'entr‚e d'une chaine de longueur d‚termin‚e.
@SYNTAXE = Syntaxe : adr_chaine longueur EXPECT
La fin de la chaine est d‚termin‚e, soit par
l'atteinte de la longueur,
soit par appui sur la touche <<Entr‚e>>.
Stocke la chaine saisie … adr_chaine.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : EXPECT  ( adr_chaine longueur --- )
  DUP SPAN !
  SWAP 0
  BEGIN
    2 PICK
    OVER -
  WHILE
    KEY DUP
    BL <<          ( Est-ce un caractŠre de contr“le ? )
    IF
      2* C-C @ +  ( Oui, ‚x‚cution du vecteur correspondant )
      PERFORM
    ELSE
      DUP 127 =
      IF
        DROP DEL-IN
      ELSE
        CHAR
      THEN
    THEN
  REPEAT
  2DROP DROP
;

 CHAR
Vecteur.
Place un caractŠre dans un tampon.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER CHAR

 (CHAR)
Primitive.
Vectoris‚e par CHAR.
Place un caractŠre dans un tampon.
@SYNTAXE = Syntaxe : adresse long car (CHAR)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (CHAR)  ( adresse long car --- adresse long+1 )
  3DUP EMIT +
  C! 1+
;

 CR-IN
Vecteur.
Correspond … l'action de la touche <<Entr‚e>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CR-IN  ( adresse long --- adresse long' )
  SPAN ! OVER BL EMIT
;

 P-IN
Vecteur.
Correspond … l'action du switch d'impression (CTRL+P).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : P-IN
  PRINTING @ NOT
  PRINTING !
;

 RES-IN
Vecteur.
R‚initialisation du systŠme FORTH.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : RES-IN
  FORTH TRUE
  ABORT" Initialisation"
;

 BACK-UP
Vecteur.
Correspond … l'action de CTRL+U et CTRL+X.
Annulation de la saisie dans un tampon.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BACK-UP  ( adresse long --- adresse 0 )
  DUP BACKSPACES DUP
  SPACES BACKSPACES 0
;

 DEL-IN
Vecteur.
Correspond … l'action de CTRL+H.
Annulation du dernier caractŠre saisi.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DEL-IN  ( adresse long --- adresse long' )
  DUP
  IF
    1- BS EMIT
    SPACE BS
  ELSE
    BELL
  THEN
  EMIT
;

 BS-IN
Vecteur.
Correspond … l'action de la touche <<- (Backspace).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BS-IN
  DROP DUP
  IF
    1- BS
  ELSE
    BELL
  THEN
  EMIT
;

 BEEP
Emet un bip.
@SYNTAXE = Syntaxe : BEEP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BEEP  ( --- )
  BELL EMIT
;

 BACKSPACES
Emet un ou plusieurs espaces arriŠres.
@SYNTAXE = Syntaxe : n BACKSPACES
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BACKSPACES  ( n --- )
  BS REPLICATE
;

 SPACES
Emet un ou plusieurs espaces.
@SYNTAXE = Syntaxe : n SPACES
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SPACES  ( n --- )
  BL REPLICATE
;

 SPACE
Emet un espace.
@SYNTAXE = Syntaxe : SPACE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SPACE  ( --- )
  BL EMIT
;

 PERFORM
Ex‚cution indirecte.
@SYNTAXE = Syntaxe : adr_cfa PERFORM
Ex‚cute le mot dont le CFA est … l'adresse adr_cfa.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE PERFORM  ( adr_cfa --- )
  W POP
  0 [W] W MOV
  0 [W] JMP
END-CODE

 REPLICATE
R‚p‚tition de caractŠres.
@SYNTAXE = Syntaxe : n car REPLICATE
Emet n caractŠres car.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : REPLICATE  ( n car --- )
  SWAP 0 MAX 0
  DO
    DUP EMIT
  LOOP
  DROP
;

 TYPE
Affichage d'une chaine de caractŠres.
@SYNTAXE = Syntaxe : adr_chaine long TYPE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : TYPE  ( adr_chaine long --- )
  0
  DO
    COUNT EMIT
  LOOP
  DROP
;

 CR
Vecteur.
Emet un retour chariot.
@SYNTAXE = Syntaxe : CR
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER CR

 (CR)
Emet un retour chariot.
Vectoris‚ par CR.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (CR)  ( --- )
  13 EMIT 10 EMIT
  #OUT OFF #LINE @ 1+
  24 MAX #LINE !
;

 HOME
Positionne le curseur en haut et … gauche.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : HOME  ( --- )
  27 (CONS) ASCII [ (CONS)
  ASCII f (CONS)
;
HOME n‚c‚ssite l'installation du driver ANSI.SYS.

 DARK
Efface l'‚cran, et positionne le curseur en haut et …
gauche.
@SYNTAXE = Syntaxe : DARK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DARK  ( --- )
  27 (CONS) ASCII [ (CONS)
  ASCII 2 (CONS) ASCII J (CONS)
  #OUT OFF #LINE OFF
;
DARK n‚c‚ssite l'installation du driver ANSI.SYS.

 INVERS
Passage en vid‚o inverse.
@SYNTAXE = Syntaxe : INVERS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : INVERS  ( --- )
  7 (ATTRIB)
;
INVERS n‚c‚ssite l'installation du driver ANSI.SYS.

 BLINK
Passage en mode clignotant.
@SYNTAXE = Syntaxe : BLINK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BLINK  ( --- )
  5 (ATTRIB)
;
BLINK n‚c‚ssite l'installation du driver ANSI.SYS.

 UNDERL
Passage en mode soulign‚.
@SYNTAXE = Syntaxe : UNDERL
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : UNDERL  ( --- )
  4 (ATTRIB)
;
UNDERL n‚c‚ssite l'installation du driver ANSI.SYS.

 BOLD
Passage en mode surimppression ( gras ).
@SYNTAXE = Syntaxe : BOLD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BOLD  ( --- )
  1 (ATTRIB)
;
BOLD n‚c‚ssite l'installation du driver ANSI.SYS.

 ATTOFF
Inibition des attributs d'affichage.
@SYNTAXE = Syntaxe : ATTOFF
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ATTOFF  ( --- )
  0 (ATTRIB)
;

 (ATTRIB)
Changement d'attributs.
@SYNTAXE = Syntaxe : n (ATTRIB)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (ATTRIB)  ( n --- )
  ATTRIBUTS @
  IF
    27 (CONS) ASCII [ (CONS)
    ASCII 0 + (CONS)
    ASCII m (CONS)
  ELSE
    DROP
  THEN
;
(ATTRIB) n‚c‚ssite l'installation du driver ANSI.SYS.

 EMIT
Vecteur.
Emission d'un caractŠre.
@SYNTAXE = Syntaxe : car EMIT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER EMIT

 (EMIT)
Primitive.
Emission d'un caractŠre.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (EMIT)  ( car --- )
  PRINTING @
  IF
    DUP (PRINT)
    #OUT 1-!
  THEN
  (CONSOLE)
;

 (PRINT)
Primitive.
Emission d'un caractŠre vers le p‚riph‚rique d'impression.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (PRINT)  ( car --- )
  (PRN) #OUT 1+!
;

 (CONSOLE)
Primitive.
Emission d'un caractŠre vers le p‚riph‚rique de sortie
standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (CONSOLE)  ( car --- )
  (CONS) #OUT 1+!
;

 (CONS)
Primitive.
Emission d'un caractŠre vers le p‚riph‚rique de sortie
standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (CONS)  ( car --- )
  6 (OUT)
;

 KEY?
Vecteur.
Renvoi VRAI si une touche a ‚t‚ actionn‚e.
@SYNTAXE = Syntaxe : KEY?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER KEY?

 KEY
Vecteur.
Renvoi le code de la touche actionn‚e.
@SYNTAXE = Syntaxe : KEY
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER KEY

 (KEY)
Primitive.
Vectoris‚e par KEY.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (KEY)  ( --- car )
  BEGIN
    (KEY?)
  UNTIL
  7 (IN)
;

 (KEY?)
Primitive.
Vectoris‚e par KEY?.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (KEY?)  ( --- flag )
  11 (IN) 0<<>>
;

 .ID
Affiche le nom du mot dont le NFA est sur la pile de
donn‚es.
@SYNTAXE = Syntaxe : nfa .ID
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : .ID  ( nfa --- )
  DUP 1+ DUP C@ ROT
  C@ 31 AND 0
  ?DO
    DUP 127 AND EMIT
    128 AND
    IF
      ASCII _ 128 OR
    ELSE
      1+ DUP C@
    THEN
  LOOP
  2DROP SPACE
;

 H.
Affiche le nombre pr‚sent sur la pile en
repr‚sentation h‚xad‚cimale,
sans modifier la base de sortie courante.
@SYNTAXE = Syntaxe : n H.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : H.  ( n --- )
  OBASE DUP @ >>R HEX
  . R>> OBASE !
;

 B.
Affiche le nombre pr‚sent sur la pile en
repr‚sentation binaire,
sans modifier la base de sortie courante.
@SYNTAXE = Syntaxe : n B.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : B.  ( n --- )
  OBASE DUP @ >>R BINARY
  . R>> OBASE !
;

 O.
Affiche le nombre pr‚sent sur la pile en
repr‚sentation octale,
sans modifier la base de sortie courante.
@SYNTAXE = Syntaxe : n O.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : O.  ( n --- )
  OBASE DUP @ >>R OCTAL
  . R>> OBASE !
;

 ?
Affichage du contenu d'une variable.
@SYNTAXE = Syntaxe : nom_variable ?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?  ( adr --- )
  @ .
;

 D.R
Affichage d'un double cadr‚ … droite.
@SYNTAXE = Syntaxe : d n D.R
Affiche le double d cadr‚ … droite sur n chiffres,
compl‚t‚s ‚ventuellement avec des espaces.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D.R  ( d n --- )
  >>R (D.) R>>
  OVER - SPACES TYPE
;

 D.
Affichage d'un double.
@SYNTAXE = Syntaxe : d D.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D.  ( d --- )
  (D.) TYPE SPACE
;

 (D.)
Primitive.
Affichage d'un double.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (D.)  ( d --- )
  TUCK DABS
  <<# #S ROT SIGN #>>
;

 UD.R
Affichage d'un double non sign‚ cadr‚ … droite.
@SYNTAXE = Syntaxe : ud n UD.R
Affiche le double non sign‚ ud cadr‚ … droite sur n
chiffres,
compl‚t‚s ‚ventuellement avec des espaces.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : UD.R  ( ud n --- )
  >>R (UD.) R>>
  OVER - SPACES TYPE
;

 UD.
Affichage d'un double non sign‚.
@SYNTAXE = Syntaxe : ud UD.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : UD.  ( ud --- )
  (UD.) TYPE SPACE
;

 (UD.)
Primitive.
Affichage d'un double non sign‚.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (UD.)  ( ud --- )
  <<# #S #>>
;

 .R
Affichage d'un entier cadr‚ … droite.
@SYNTAXE = Syntaxe : int n .R
Affiche l'entier int cadr‚ … droite sur n chiffres,
compl‚t‚s ‚ventuellement avec des espaces.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : .R  ( int n --- )
  >>R (.) R>>
  OVER - SPACES TYPE
;

 .
Affichage d'un entier.
@SYNTAXE = Syntaxe : n .
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : .  ( n --- )
  (.) TYPE SPACE
;

 (.)
Primitive.
Affichage d'un entier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (.)  ( n --- )
  DUP ABS 0
  <<# #S ROT SIGN #>>
;

 U.R
Affichage d'un entier non sign‚ cadr‚ … droite.
@SYNTAXE = Syntaxe : u n U.R
Affiche l'entier non sign‚ u, cadr‚ … droite sur n
chiffres,
compl‚t‚s ‚ventuellement avec des espaces.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : U.R  ( u n --- )
  >>R (U.) R>>
  OVER - SPACES TYPE
;

 U.
Affichage d'un entier non sign‚.
@SYNTAXE = Syntaxe : u U.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : U.  ( u --- )
  (U.) TYPE SPACE
;

 (U.)
Primitive.
Affichage d'un entier non sign‚.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (U.)  ( u --- )
  0 <<# #S #>>
;

 #S
Primitive.
formattage des n chiffres non nuls d'un nombre en texte, pour
affichage.
La conversion s'effectue en fonction de la base de sortie
courante.
Ce mot n'est utilisable qu'entre <<# et #>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : #S  ( d --- 0 0 )
  BEGIN
    # 2DUP OR 0=
  UNTIL
;

 #
Primitive.
Conversion d'un nombre en caractŠre ASCII.
La conversion s'effectue en fonction de la base de sortie
courante.
Ce mot n'est utilisable qu'entre <<# et #>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : #  ( n1 --- n2 )
  OBASE @ MU/MOD
  ROT 9 OVER <<
  IF
    7 +
  THEN
  ASCII 0 + HOLD
;

 SIGN
Insertion ‚ventuelle du signe du nombre en cours de
formattage, si le nombre est n‚gatif.
Ce mot ne s'utilise qu'entre <<# et #>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SIGN  ( n --- )
  0<<
  IF
    ASCII - HOLD
  THEN
;

 <<#
Initialisation du formattage d'un nombre, pour
affichage.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : <<#  ( --- )
  PAD HLD !
;

 #>>
Fin du formattage d'un nombre, pour affichage.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : #>>  ( d --- adr n )
  2DROP HLD @
  PAD OVER -
;
Renvoi l'adresse de la chaine, ainsi que sa longueur,
prˆt pour TYPE.

 HOLD
Insertion d'un caractŠre pendant un formatage.
Ce mot ne s'utilise qu'entre <<# et #>>.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : HOLD  ( car --- )
  HLD 1-! HLD @ C!
;

 NUMBER
Vecteur.
Conversion d'une chaine en un nombre double.
@SYNTAXE = Syntaxe : adresse NUMBER
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = DEFER NUMBER

 (NUMBER)
Primitive.
Vectoris‚ par NUMBER.
Conversion d'une chaine en un nombre double.
@SYNTAXE = Syntaxe : adresse (NUMBER)
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (NUMBER)  ( adresse --- d )
  NUMBER?
  NOT ?MISSING
;

 NUMBER?
Conversion d'une chaine en un nombre double.
@SYNTAXE = Syntaxe : adresse NUMBER?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : NUMBER?  ( adresse --- d flag )
  FALSE OVER COUNT
  BOUNDS
  DO
    I C@ IBASE @
    DIGIT NIP
    IF
      DROP TRUE
      LEAVE
    THEN
  LOOP
  IF
    (NUMBER?)
  ELSE
    DROP 0 0
    FALSE
  THEN
;
Si le flag empil‚ est VRAI, le nombre double qui suit
est valide.

 BOUNDS
Renvoi l'adresse de d‚but et de fin d'une chaine.
@SYNTAXE = Syntaxe : adresse long BOUNDS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE BOUNDS  ( adresse long --- adresse1 adresse2
)
  BX POP
  AX POP
  AX DX MOV
  BX DX ADD
  2PUSH
END-CODE

 (NUMBER?)
Primitive.
Utilis‚e par NUMBER?
Conversion d'une chaine en un nombre double.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (NUMBER?)  ( adresse --- d flag )
  0 0 ROT DUP 1+ C@
  ASCII - = DUP
  >>R - -1 DPL !
  BEGIN
    CONVERT DUP C@
    ASCII , ASCII /
    BETWEEN
  WHILE
    0 DPL !
  REPEAT
  -ROT R>>
  IF
    DNEGATE
  THEN
  ROT C@ BL =
;

 CONVERT
Conversion d'une chaine en un nombre.
@SYNTAXE = Syntaxe : ud1 adresse CONVERT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CONVERT  ( ud1 adresse --- ud2 adresse2 )
  BEGIN
    1+ DUP >>R C@
    IBASE @ DIGIT
  WHILE
    SWAP IBASE @ UM*
    DROP ROT IBASE @
    UM* D+ DOUBLE?
    IF
      DPL 1+!
    THEN
    R>>
  REPEAT
  DROP R>>
;

 DOUBLE?
Renvoi un flag VRAI si la derniŠre conversion d'une
chaine en un nombre double a aboutie.
@SYNTAXE = Syntaxe : DOUBLE?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DOUBLE?  ( --- flag )
  DPL @ 1+ 0<<>>
;

 DIGIT
Conversion d'un caractŠre en un nombre.
@SYNTAXE = Syntaxe : car base DIGIT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = ASSEMBLER
LABEL FAIL
  AX AX SUB
  1PUSH
CODE DIGIT  ( car base --- n flag )
  DX POP
  AX POP
  AX PUSH
  ASCII 0 # AL SUB
  FAIL JB
  9 # AL CMP
  >>
  IF
    17 # AL CMP
    FAIL JB
    7 # AL SUB
  THEN
  DL AL CMP
  FAIL JAE
  AL DL MOV
  AX POP
  TRUE # AX MOV
  2PUSH
END-CODE

 ESEGMENT
Renvoi l'adresse de l'extra segment ES.
@SYNTAXE = Syntaxe : ESEGMENT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE ESEGMENT  ( --- adr )
  CODE-REF #) CALL
  8192 # DX ADD
  DX PUSH
  NEXT
END-CODE

 SSEGMENT
Renvoi l'adresse du segment de pile SS.
@SYNTAXE = Syntaxe : SSEGMENT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE SSEGMENT  ( --- adr )
  CODE-REF #) CALL
  4096 # DX ADD
  DX PUSH
  NEXT
END-CODE

 DSEGMENT
Renvoi l'adresse du segment de donn‚es SS.
@SYNTAXE = Syntaxe : DSEGMENT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE DSEGMENT  ( --- adr )
  CODE-REF #) CALL
  DX PUSH
  NEXT
END-CODE

 CSEGMENT
Renvoi l'adresse du segment de code CS.
@SYNTAXE = Syntaxe : CSEGMENT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE CSEGMENT  ( --- adr )
  CODE-REF #) CALL
  DX PUSH
  NEXT
END-CODE

 UPPER
Conversion d'une chaine en majuscules.
@SYNTAXE = Syntaxe : adr_chaine longueur UPPER
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = LABEL >>UPPER
  ASCII a # AL CMP
  0>>=
  IF
    ASCII z 1+ # AL CMP
    0<<
    IF
      32 # AL SUB
    THEN
  THEN
  RET
CODE UPPER  ( adr_chaine longueur --- )
  CX POP
  BX POP
  BEGIN
    CX CX OR
    0<<>>
  WHILE
    0 [BX] AL MOV
    >>UPPER #) CALL
    AL 0 [BX] MOV
    BX INC
    CX DEC
  REPEAT
  NEXT
END-CODE

 UPC
Conversion d'un caractŠre en majuscule.
@SYNTAXE = Syntaxe : car UPC
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE UPC  ( car --- car' )
  AX POP
  >>UPPER #) CALL
  1PUSH
END-CODE

 -TRAILING
Suppression des espaces en fin de chaine.
@SYNTAXE = Syntaxe : adresse long -TRAILING
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : -TRAILING  ( adresse long --- adresse long2 )
  DUP 0
  DO
    2DUP + 1- C@
    BL <<>> ?LEAVE
    1-
  LOOP
;

 ?CHAR
Conversion conditionnelle d'un caractŠre en
majuscule.
@SYNTAXE = Syntaxe : car ?CHAR
Si la variable CAPS est ON, le caractŠre est converti
en majuscule.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?CHAR  ( car --- car' )
  CAPS @
  IF
    UPC
  THEN
;

 LENGTH
Renvoi la longueur d'une chaine.
Celle-ci peut d‚passer 255 caractŠres.
@SYNTAXE = Syntaxe : adr_chaine LENGTH
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE LENGTH  ( adr_chaine --- adr_chaine+2
longueur )
  BX POP
  0 [BX] AX MOV
  BX INC
  BX INC
  BX PUSH
  1PUSH
END-CODE

 COUNT
Renvoi la longueur d'une chaine.
Celle-ci ne peut d‚passer 255 caractŠres.
@SYNTAXE = Syntaxe : adr_chaine COUNT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE COUNT  ( adr_chaine --- adr_chaine+1 longueur
)
  BX POP
  0 [BX] AL MOV
  AH AH XOR
  BX INC
  BX PUSH
  1PUSH
END-CODE

 BLANK
Remplissage d'une zone m‚moire avec des espaces.
@SYNTAXE = Syntaxe : adr n BLANK
Remplis la zone commencant … l'adresse adr, de
longueur n avec des espaces.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BLANK  ( adr n --- )
  BL FILL
;

 ERASE
Remplissage d'une zone m‚moire avec des z‚ros.
@SYNTAXE = Syntaxe : adr n ERASE
Remplis la zone commencant … l'adresse adr, de
longueur n avec des z‚ros.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ERASE  ( adr n --- )
  0 FILL
;

 FILL
Remplissage d'une zone m‚moire.
@SYNTAXE = Syntaxe : adr n oct FILL
Remplis la zone commencant … l'adresse adr, de
longueur n avec l'octet de code oct.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE FILL  ( adr n oct --- )
  CLD
  DS AX MOV
  AX ES MOV
  AX POP
  CX POP
  DI POP
  REP AL STOS
  NEXT
END-CODE

 MOVE
Mouvements de mots (16 bits) intra-segment.
@SYNTAXE = Syntaxe : adr_src adr_dst long MOVE
Copie la zone d'adresse adr_src vers la zone
d'adresse adr_dst, sur une longueur long.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE MOVE  ( adr_src adr_dst long --- )
  AX POP
  BX POP
  CX POP
  DS PUSH
  CX PUSH
  DS PUSH
  BX PUSH
  AX PUSH
  ' LMOVE # BX MOV
  0 [BX] JMP
END-CODE

 CMOVE>>
Mouvements d'octets (8 bits) intra-segment.
@SYNTAXE = Syntaxe : adr_src adr_dst long CMOVE>>
Copie la zone d'adresse adr_src vers la zone
d'adresse adr_dst,
sur une longueur long, en commencant par l' adresse haute.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE CMOVE>>  ( adr_src adr_dst long --- )
  AX POP
  BX POP
  CX POP
  DS PUSH
  CX PUSH
  DS PUSH
  BX PUSH
  AX PUSH
  ' LCMOVE>> # BX MOV
  0 [BX] JMP
END-CODE

 CMOVE
Mouvements d'octets (8 bits) intra-segment.
@SYNTAXE = Syntaxe : adr_src adr_dst long CMOVE
Copie la zone d'adresse adr_src vers la zone
d'adresse adr_dst, sur une longueur long.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE CMOVE  ( adr_src adr_dst long --- )
  AX POP
  BX POP
  CX POP
  DS PUSH
  CX PUSH
  DS PUSH
  BX PUSH
  AX PUSH
  ' LCMOVE # BX MOV
  0 [BX] JMP
END-CODE

 LCMOVE>>
Mouvements d'octets (8 bits) extra-segment.
@SYNTAXE = Syntaxe : seg_src off_src seg_dst off_dst long
LCMOVE>>
Copie la zone d'adresse seg_src adr_src vers la zone
d'adresse seg-dst adr_dst,
sur une longueur long, en commencant par l' adresse haute.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE LCMOVE>>  ( seg_src off_src seg_dst off_dst
long --- )
  STD
  IP BX MOV
  DS DX MOV
  CX POP
  DI POP
  ES POP
  IP POP
  DS POP
  CX CX OR
  0<<>>
  IF
    CX DEC
    CX DI ADD
    CX IP ADD
    CX INC
    REP BYTE MOVS
  THEN
  BX IP MOV
  DX DS MOV
  CLD
  NEXT
END-CODE

 LCMOVE
Mouvements d'octets (8 bits) extra-segment.
@SYNTAXE = Syntaxe : seg_src off_src seg_dst off_dst long
LCMOVE
Copie la zone d'adresse seg_src adr_src vers la zone
d'adresse seg-dst adr_dst, sur une longueur long.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE LCMOVE  ( seg_src off_src seg_dst off_dst
long --- )
  CLD
  IP BX MOV
  DS DX MOV
  CX POP
  DI POP
  ES POP
  IP POP
  DS POP
  CX CX OR
  0<<>>
  IF
    REP BYTE MOVS
  THEN
  BX IP MOV
  DX DS MOV
  NEXT
END-CODE

 LMOVE
Mouvements de mots (16 bits) extra-segments.
@SYNTAXE = Syntaxe : seg_src off_src seg_dst off_dst long LMOVE
Copie la zone d'adresse seg_src off_src vers la zone
d'adresse seg_dst off_dst, sur une longueur long.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : LMOVE  ( seg_src off_src seg_dst off_dst long --
- )
  3 PICK 2 PICK
  U<<
  IF
    LCMOVE>>
  ELSE
    LCMOVE
  THEN
;

 PLACE
TransfŠre d'une chaine.
@SYNTAXE = Syntaxe : adresse1 long adresse2 PLACE
TransfŠre la chaine d'adresse adresse1, de longueur
long, … l'adresse adresse2.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : PLACE  ( adresse1 long adresse2 --- )
  3DUP 1+
  SWAP MOVE
  C! DROP
;

 S>>D
Conversion d'un entier simple en entier double.
@SYNTAXE = Syntaxe : n S>>D
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE S>>D  ( n --- d )
  AX POP
  CWD
  DX AX XCHG
  2PUSH
END-CODE

 1-!
D‚cr‚mentation du contenu d'une adresse.
@SYNTAXE = Syntaxe : adr 1-!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 1-!  ( adr --- )
  BX POP
  0 [BX] DEC
  NEXT
END-CODE

 1+!
Incr‚mentation du contenu d'une adresse.
@SYNTAXE = Syntaxe : adr 1+!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 1+!  ( adr --- )
  BX POP
  0 [BX] INC
END-CODE

 -!
D‚cr‚mentation du contenu d'une adresse, avec une
valeur d‚termin‚e.
@SYNTAXE = Syntaxe : n adr -!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE -!  ( n adr --- )
  BX POP
  AX POP
  AX 0 [BX] SUB
  NEXT
END-CODE

 +!
Incr‚mentation du contenu d'une adresse, avec une
valeur d‚termin‚e.
@SYNTAXE = Syntaxe : n adr +!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE +!  ( n adr --- )
  BX POP
  AX POP
  AX 0 [BX] ADD
  NEXT
END-CODE

 OFF
Mise … OFF (z‚ro) d'une variable.
@SYNTAXE = Syntaxe : adr_var OFF
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE OFF  ( adr_var --- )
  BX POP
  FALSE # 0 [BX] MOV
  NEXT
END-CODE

 ON
Mise … ON (-1) d'une variable.
@SYNTAXE = Syntaxe : adr_var ON
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE ON  ( adr_var --- )
  BX POP
  TRUE # 0 [BX] MOV
  NEXT
END-CODE

 CTOGGLE
Inversion des bits d'une variable, selon un masque
pr‚difini.
@SYNTAXE = Syntaxe : masque adr_var CTOGGLE
Inverse les bits de la variable adr_var,
en fonction des bits … 1 du masque pr‚d‚fini.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE CTOGGLE  ( masque adr_var --- )
  BX POP
  AX POP
  AL 0 [BX] XOR
  NEXT
END-CODE

 CRESET
Mise … z‚ro des bits d'une variable, en fonction d'un
masque pr‚d‚fini.
@SYNTAXE = Syntaxe : masque adr_var CRESET
Met … z‚ro les bits de la variable adr_var,
en fonction des bits … 1 du masque pr‚d‚fini.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE CRESET  ( masque adr_var --- )
  BX POP
  AX POP
  AL 0 [BX] AND
  NEXT
END-CODE

 CSET
Mise … un des bits d'une variable, en fonction d'un
masque pr‚d‚fini.
@SYNTAXE = Syntaxe : masque adr_var CSET
Met … un les bits de la variable adr_var,
en fonction des bits … 1 du masque pr‚d‚fini.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE CSET  ( masque adr_var --- )
  BX POP
  AX POP
  AL 0 [BX] OR
  NEXT
END-CODE

 LC@
Lecture du contenu d'une variable (8 bits) extra-
segment.
@SYNTAXE = Syntaxe : seg_var off_var LC@
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE LC@  ( seg_var off_var --- val8 )
  DS CX MOV
  BX POP
  DS POP
  AX AX XOR
  0 [BX] AL MOV
  CX DS MOV
  1PUSH
END-CODE

 L@
Lecture du contenu d'une variable (16 bits) extra-
segment.
@SYNTAXE = Syntaxe : seg_var off_var L@
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE L@  ( seg_var off_var --- val16 )
  DS CX MOV
  BX POP
  DS POP
  0 [BX] PUSH
  CX DS MOV
  NEXT
END-CODE

 LC!
Initialisation du contenu d'une variable (8 bits)
extra-segment.
@SYNTAXE = Syntaxe : val8 seg_var off_var LC!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE LC!  ( val8 seg_var off_var --- )
  DS CX MOV
  BX POP
  DS POP
  AX POP
  AL 0 [BX] MOV
  CX DS MOV
  NEXT
END-CODE

 L!
Initialisation du contenu d'une variable (16 bits)
extra-segment.
@SYNTAXE = Syntaxe : val16 seg_var off_var L!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE L!  ( val16 seg_var off_var --- )
  DS AX MOV
  BX POP
  DS POP
  0 [BX] POP
  AX DS MOV
  NEXT
END-CODE

 2!
Initialisation d'une variable double (32 bits).
@SYNTAXE = Syntaxe : d adr_var 2!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 2!  ( d adr_var --- )
  BX POP
  2 [BX] POP
  0 [BX] POP
  NEXT
END-CODE

 !
Initialisation d'une variable simple.
@SYNTAXE = Syntaxe : val16 adr !
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE ! ( val16 adr --- )
  BX POP
  0 [BX] POP
  NEXT
END-CODE

 C!
Initialisation d'une variable simple.
@SYNTAXE = Syntaxe : val8 adr C!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE C!  ( val8 adr --- )
  BX POP
  AX POP
  AL 0 [BX] MOV
  NEXT
END-CODE

 2@
Lecture d'une variable double (32 bits) .
@SYNTAXE = Syntaxe : adr 2@
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE 2@  ( adr --- d )
  BX POP
  0 [BX] PUSH
  2 [BX] PUSH
  NEXT
END-CODE

 @
Lecture d'une variable simple.
@SYNTAXE = Syntaxe : adr @
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE @  ( adr --- val16 )
  BX POP
  0 [BX] PUSH
  NEXT
END-CODE

 C@
Lecture d'une variable simple.
@SYNTAXE = Syntaxe : adr C@
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE C@  ( adr --- val8 )
  BX POP
  AH AH XOR
  0 [BX] AL MOV
  1PUSH
END-CODE

 HEX
Passage d'une base en h‚xad‚cimal.
@SYNTAXE = Syntaxe : adr_base HEX
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : HEX  ( adr_base --- )
  16 SWAP !
;

 DECIMAL
Passage d'une base en d‚cimal.
@SYNTAXE = Syntaxe : adr_base DECIMAL
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DECIMAL  ( adr_base --- )
  10 SWAP !
;

 OCTAL
Passage d'une base en octal.
@SYNTAXE = Syntaxe : adr_base OCTAL
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : OCTAL  ( adr_base --- )
  8 SWAP !
;

 BINARY
Passage d'une base en binaire.
@SYNTAXE = Syntaxe : adr_base BINARY
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : BINARY  ( adr_base --- )
  2 SWAP !
;

 BUFFERS
Renvoi l'adresse des zones m‚moires o— sont stock‚es
les donn‚es lue ou … ‚crire dans les fichiers.
Pour chaque fichier, un espace de 256 octets est r‚serv‚ pour
l'‚change des informations avec la m‚moire.
Cet espace est suivi de 2 octets pour stocker le num‚ro de
ligne courante.
Vient s'ajouter juste aprŠs une zone de 64 octets pour stocker
le "pathname" ( [u:][chemin] nom_fichier.ext ) du ficher.
@SYNTAXE = Syntaxe : BUFFERS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE BUFFERS
256 ALLOT ," CON:"  59 ALLOT 0 ,   ( Correspond … STDIN )
256 ALLOT ," CON:"  59 ALLOT 0 ,   ( Correspond … STDOUT )
256 ALLOT ," CON:"  59 ALLOT 0 ,   ( Correspond … STDERR )
256 ALLOT ," COM1:" 58 ALLOT 0 ,   ( Correspond … STDAUX )
256 ALLOT ," PRN:"  59 ALLOT 0 ,   ( Correspond … STDPRN )
322 15 * ALLOT

 DTA
Variable.
Zone de donn‚es, utilis‚e pour les accŠs disques.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE DTA 512 ALLOT

 ERRMSG
Variable.
Zone de donn‚es contenant les messages d'erreurs des
diff‚rentes fonctions DOS.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE ERRMSG
," num‚ro de fonction invalide                      "
," fichier introuvable                              "
," chemin introuvable                               "
," trop de fichiers ouverts                         "
," accŠs refus‚                                     "
," num‚ro de fichier invalide                       "
," blocs de contr“le de m‚moire d‚truits            "
," m‚moire insuffisante                             "
," adresse de bloc m‚moire invalide                 "
," environnement invalide                           "
," format invalide                                  "
," mode d'accŠs invalide                            "
," donn‚es invalides                                "
," unit‚ invalide                                   "
," tentative de suppression du r‚pertoire en cours  "
," pas la mˆme unit‚                                "
," plus de fichier                                  "
," disquette prot‚g‚e en ‚criture                   "
," unit‚ de disque invalide                         "
," unit‚ non prˆte                                  "
," commande de disque invalide                      "
," erreur de CRC                                    "
," longueur invalide (disque)                       "
," erreur de recherche (seek sur disque)            "
," disque non DOS                                   "
," secteur introuvable                              "
," plus de papier                                   "
," erreur d'‚criture                                "
," erreur de lecture                                "
," d‚faillance g‚n‚rale                             "
," problŠme de partage de fichier                   "
," problŠme de verrouillage                         "
," mauvais disque                                   "
," pas de FCB                                       "
," erreur DOS                                       "

 $PAD
Variable.
Zone de donn‚es adress‚e par PAD, utilis‚e comme tampon
temporaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE $PAD 256 ALLOT

 C-C-F
Variable.
Zone de donn‚es contenant la table des vecteurs des caractŠres
de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE C-C-F
]
  NOOP     ( Code 0  : action de CTRL + @ )
  NOOP     ( Code 1  : action de CTRL + A )
  NOOP     ( Code 2  : action de CTRL + B )
  RES-IN   ( Code 3  : action de CTRL + C )
  NOOP     ( Code 4  : action de CTRL + D )
  NOOP     ( Code 5  : action de CTRL + E )
  NOOP     ( Code 6  : action de CTRL + F )
  BEEP     ( Code 7  : action de CTRL + G )
  DEL-IN   ( Code 8  : action de CTRL + H )
  NOOP     ( Code 9  : action de CTRL + I )
  NOOP     ( Code 10 : action de CTRL + J )
  NOOP     ( Code 11 : action de CTRL + K )
  NOOP     ( Code 12 : action de CTRL + L )
  CR-IN    ( Code 13 : action de CTRL + M )
  NOOP     ( Code 14 : action de CTRL + N )
  NOOP     ( Code 15 : action de CTRL + O )
  P-IN     ( Code 16 : action de CTRL + P )
  NOOP     ( Code 17 : action de CTRL + Q )
  NOOP     ( Code 18 : action de CTRL + R )
  NOOP     ( Code 19 : action de CTRL + S )
  NOOP     ( Code 20 : action de CTRL + T )
  BACK-UP  ( Code 21 : action de CTRL + U )
  NOOP     ( Code 22 : action de CTRL + V )
  NOOP     ( Code 23 : action de CTRL + W )
  BACK-UP  ( Code 24 : action de CTRL + X )
  BYE      ( Code 25 : action de CTRL + Y )
  NOOP     ( Code 26 : action de CTRL + Z )
  NOOP     ( Code 27 : action de CTRL + [ )
  NOOP     ( Code 28 : action de CTRL + \ )
  NOOP     ( Code 29 : action de CTRL + ] )
  NOOP     ( Code 30 : action de CTRL + ^ )
  NOOP     ( Code 31 : action de CTRL + _ )
[

 TIB
Constante.
Adresse du tampon clavier (Terminal Input Buffer).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = BUFFERS 3 + CONSTANT TIB

 STDPRN
Constante.
Contient le handler du p‚riph‚rique standard d'impression.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 4 CONSTANT STDPRN

 AUXOUT
Constante.
Contient le handler du p‚riph‚rique de sortie auxiliaire
standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 3 CONSTANT AUXOUT

 AUXIN
Constante.
Contient le handler du p‚riph‚rique d'entr‚e auxiliaire
standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 3 CONSTANT AUXIN

 STDOUT
Constante.
Contient le handler du p‚riph‚rique de sortie standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 1 CONSTANT STDOUT

 STDIN
Constante.
Contient le handler du p‚riph‚rique d'entr‚e standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0 CONSTANT STDIN

 PAD
Constante.
Contient l'adresse du tampon temporaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = $PAD 257 + CONSTANT PAD

 C/L
Constante.
Contient le nombre maximum de caractŠres par ligne.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 255 CONSTANT C/L

 BELL
Constante.
Contient le code du caractŠre correspondant … l'‚mission d'un
beep.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 7 CONSTANT BELL

 BS
Constante.
Contient le code du caractŠre correspondant au retour arriŠre.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 8 CONSTANT BS

 BL
Constante.
Contient le code du caractŠre blanc (espace).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 32 CONSTANT BL

 #THREADS
Constante.
Contient le nombre de brins (THREADS) d'un vocabulaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 4 CONSTANT #THREADS

 #VOCS
Constante.
Contient le nombre maximum de vocabulaires de CONTEXT.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 8 CONSTANT #VOCS

 READ-WRITE
Constante.
Attribut pr‚d‚fini pour l'ouverture d'un fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 2 CONSTANT READ-WRITE

 WRITE
Constante.
Attribut pr‚d‚fini pour l'ouverture d'un fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 1 CONSTANT WRITE

 READ
Constante.
Attribut pr‚d‚fini pour l'ouverture d'un fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0 CONSTANT READ

 C/PATH
Constante.
Contient la longueur maximum d'un chemin d'accŠs.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 64 CONSTANT C/PATH

 LBUF
Constante.
Contient la longueur maximum d'un buffer.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 256 CONSTANT LBUF

 #FILES
Constante.
Contient le nombre de fichiers ouverts actuellement par
PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 5 CONSTANT #FILES

 FILES
Constante.
Contient le nombre maximum de fichiers ouvrables par PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 20 CONSTANT FILES

 #TIB
Constante.
Contient la longueur de la chaine stock‚e dans le TIB.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = BUFFERS 2+ CONSTANT #TIB

 FENCE
Variable.
Contient le NFA du dernier mot du dictionnaire … prot‚ger
contre l'effacement.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE FENCE
Initialisation :
LAST @ FENCE !

 C-C
Variable.
Contient l'adresse de la table des vecteurs des caractŠres de
contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE C-C
Initialisation :
C-C-F 2+ C-C !

 RP0
Variable.
Contient la valeur initiale du pointeur de la pile de retour.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE RP0
Initialisation :
IBASE HEX
07FFE RP0 !

 SP0
Variable.
Contient la valeur initiale du pointeur de la pile de donn‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE SP0
Initialisation :
IBASE HEX
0FFFE SP0 !

 STATUS?
Variable.
Son ‚tat indique si il faut ou non afficher le STATUS du
systŠme.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE STATUS?
Initialisation :
STATUS? OFF

 ATTRIBUTS
Variable.
Son ‚tat indique l'utilisation ou l'inhibition des attributs
vid‚o ANSI.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE ATTRIBUTS
Initialisation :
ATTRIBUTS OFF

 >>IN
Variable.
Contient l'adresse du caractŠre … lire dans le flux d'entr‚e.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE >>IN
Initialisation :
>>IN OFF

 'TIB
Variable.
Contient l'adresse du tampon d'entr‚e TIB.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE 'TIB
Initialisation :
BUFFERS 3 + 'TIB !

 PRINTING
Variable.
Son ‚tat indique l'autorisation ou l'inhibition de
l'impression.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE PRINTING
Initialisation :
PRINTING OFF

 #LINE
Variable.
Contient le nombre de lignes actuellement ‚mises.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE #LINE
Initialisation :
#LINE OFF

 #OUT
Variable.
Contient le nombre de caractŠres actuellement ‚mis.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE #OUT
Initialisation :
#OUT OFF

 SPAN
Variable.
Contient le nombre de caractŠres actuellement saisis.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE SPAN

 WIDTH
Variable.
Contient la longueur maximum du nom d'une d‚finition.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE WIDTH
Initialisation :
31 WIDTH !

 END?
Variable.
Contient l'‚tat du flux d'entr‚e ( VRAI = flux d'entr‚e vide ).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE END?

 PRIOR
Variable.
Contient l'adresse du vocabulaire de la derniŠre recherche.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE PRIOR

 LAST
Variable.
Contient le NFA du dernier mot d‚fini, qui n'est pas forc‚ment
une d‚finition valide.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE LAST

 VOC-LINK
Variable.
Permet la liaison des diff‚rents vocabulaires.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE VOC-LINK

 CONTEXT
Variable.
Contient les adresses des huits vocabulaires de CONTEXT.
@DEF_FORTH = D‚finition en FORTH
@PROGRAMME = VARIABLE CONTEXT 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

 CURRENT
Variable.
Contient l'adresse du vocabulaire CURRENT.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE CURRENT

 CAPS
Variable.
Son ‚tat indique l'autorisation ou l'inhibition des minuscules.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE CAPS
Initialisation :
CAPS OFF

 HLD
Variable.
Contient le dernier chiffre converti dans le tampon PAD.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE HLD
Initialisation :
HLD OFF

 DPL
Variable.
Contient la position du point d‚cimal dans une chaine.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE DPL
Initialisation :
DPL OFF

 OBASE
Variable.
Contient la valeur de la base de sortie courante.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE OBASE
Initialisation :
OBASE DECIMAL

 IBASE
Variable.
Contient la valeur de la base d'entr‚e courante.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE IBASE
Initialisation :
IBASE DECIMAL

 WARNING
Variable.
Son ‚tat indique si il faut ‚mmettre un message en cas de
d‚finition d‚ja existante.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE WARNING
Initialisation :
WARNING ON

 DP
Variable.
Contient l'adresse de la premiŠre position libre du
dictionnaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE DP
Initialisation :
HERE DP !

 CSP
Variable.
Contient la profondeur de la pile de donn‚es, en cours de
compilation.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE CSP

 STATE
Variable.
Son ‚tat reflŠte celui du systŠme PGForth.
VRAI = Compilation.
FAUX = Interpr‚tation.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE STATE
Initialisation :
STATE OFF

 ECHO
Variable.
Son ‚tat autorise ou non l'affichage des lignes lues, pendant
l'inclusion d'un fichier.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE ECHO
Initialisation :
ECHO OFF

 HANDLE
Variable.
Contient le handler du fichier d'entr‚e standard.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE HANDLE
Initialisation :
STDIN HANDLE !

 EOF?
Variable.
Son ‚tat indique le status du fichier courant ( VRAI = fichier
vide ).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE EOF?
Initialisation :
EOF? OFF

 TOS
Variable.
Contient l'adresse du sommet de la pile de donn‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE TOS

 FORTH
S‚lection du vocabulaire FORTH comme premier
vocabulaire de CONTEXT.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VOCABULARY FORTH

 PSP
Empile l'adresse de segment du PSP.
@SYNTAXE = Syntaxe : PSP
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : PSP  ( --- adr )
  CSEGMENT 16 -
;

 SEG-ENV
Empile l'adresse de segment du bloc d'environnement
de PGForth.
@SYNTAXE = Syntaxe : SEG-ENV
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SEG-ENV  ( --- adr )
  PSP 44 LC@
;

 COMMAND.COM
Zone de donn‚es utilis‚e pour le stockage de
l'emplacement de COMMAND.COM (COMSPEC).
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE COMMAND.COM 80 ALLOT

 COMSPEC!
R‚cup‚ration de l'emplacement de COMMAND.COM
(COMSPEC), dans l'environnement de PGForth.
Utilis‚ par le mot SHELL".
@SYNTAXE = Syntaxe : COMSPEC!
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : COMSPEC!  ( --- )
  COMMAND.COM 1+ >>R
  SEG-ENV 8          ( On passe la chaine "COMSPEC=" )
  BEGIN
    2DUP LC@         ( seg off car --- )
    SWAP 1+ SWAP     ( seg off+1 car --- )
    DUP 0<<>>
  WHILE
    R@ C! R>> 1+ >>R
  REPEAT
  R>> C!
  9 - COMMAND.COM C! ( Calcule et stocke la longueur de COMSPEC
)
  DROP
;

 CMDLINE?
Renvoi un flag VRAI si la ligne de commande pass‚e
avec PGForth n'est pas vide.
@SYNTAXE = Syntaxe : CMDLINE?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CMDLINE?  ( --- flag )
  PSP 128 LC@
  0<<>>
;

 CMDLINE
Interpr‚tation de la ligne de commande.
InterprŠte les ‚ventuelles commandes pass‚es … PGForth, au
lancement de celui-ci.
@SYNTAXE = Syntaxe : CMDLINE
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CMDLINE  ( --- )
  PSP 128 2DUP LC@ 2+          ( seg_psp off long+2 --- )
  DSEGMENT BUFFERS ROT LCMOVE
  >>IN OFF RUN
;

 HERALD
Affiche la banniŠre du systŠme.
Au d‚part, vectoris‚ par BOOT.
@SYNTAXE = Syntaxe : HERALD
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : HERALD  ( --- )
  ATTRIBUTS @ ATTRIBUTS ON
  ATTOFF DARK
  BOLD
  ." +-------------------------------------+" CR
  ." |        PGForth Version 1.00         |" CR
  ." |-------------------------------------|" CR
  ." |       Auteur : P.Guillaumaud        |" CR
  ." +-------------------------------------+" CR
  CR
  ATTOFF
  ATTRIBUTS !
;

 STARTUP-FILE
Variable.
Contient le nom d'un fichier qui est inclu automatiquement au
d‚marrage de PGForth.
Initialis‚ au d‚part avec le nom 'STARTUP.FTH'.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 15 STRING STARTUP-FILE
Initialisation :
STARTUP-FILE STRLEN ERASE
" STARTUP.FTH" STARTUP-FILE !"

 STARTUP
Inclusion automatique d'un ‚ventuel fichier STARTUP.
Si un fichier dont le nom est stock‚ dans la variable STARTUP-
FILE existe dans le r‚pertoire courant,
il est inclu automatiquement au d‚marrage de PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : STARTUP
  STARTUP-FILE DROP
  READ (OPEN) 0=    ( Le fichier STARTUP existe-t'il ? )
  IF
    (INCLUDE)       ( Oui, inclusion de celui-ci )
  ELSE
    DROP
  THEN
;

 START
Mot ‚x‚cut‚ au d‚marrage de PGForth.
Vectoris‚ au d‚part par BOOT.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : START
  STARTUP     ( Inclusion d'un ‚ventuel fichier STARTUP )
  CMDLINE?    ( Ligne de commande non vide ? )
  IF
    CMDLINE   ( Oui, interpr‚tation de celle-ci )
  ELSE
    HERALD    ( Non, affichage de la banniŠre )
  THEN
;

 IFNDEF
Directive.
Permet l'‚x‚cution conditionnelle d'une s‚quence de mots FORTH,
pendant l'inclusion d'un fichier.
@SYNTAXE = Syntaxe : IFNDEF nom_mot commandes...
Si le mot <<nom_mot>> n'existe pas dans le
dictionnaire, les <<commandes>> seront ‚x‚cut‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : IFNDEF  ( nom_mot commandes --- )
  DEFINED NIP
  IF
    [COMPILE] \
  THEN
;
IMMEDIATE

 IFDEF
Directive.
Permet l'‚x‚cution conditionnelle d'une s‚quence de mots FORTH,
pendant l'inclusion d'un fichier.
@SYNTAXE = Syntaxe : IFDEF nom_mot commandes...
Si le mot <<nom_mot>> existe dans le dictionnaire,
les <<commandes>> seront ‚x‚cut‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : IFDEF  ( nom_mot commandes --- )
  DEFINED NIP 0=
  IF
    [COMPILE] \
  THEN
;
IMMEDIATE

 AT
Positionnement du curseur … l'‚cran.
@SYNTAXE = Syntaxe : colonne ligne AT
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE AT  ( colonne ligne --- )
  AX POP
  DX POP
  AL DH MOV
  BH BH XOR
  2 # AH MOV
  16 INT
  NEXT
END-CODE

 ALIGN
Force l'alignement sur une frontiŠre de mots.
@SYNTAXE = Syntaxe : ALIGN
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ALIGN  ( --- )
  HERE 1 AND
  IF
    BL C,
  THEN
;
IMMEDIATE

 (LIT)
Primitive.
Partie ‚x‚cution du mot LITERAL.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (LIT)
  AX LODS
  1PUSH
END-CODE

 (DLIT)
Primitive.
Partie ‚x‚cution du mot DLITERAL.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (DLIT)
  AX LODS
  AX PUSH
  AX LODS
  1PUSH
END-CODE

 (.")
Primitive.
Partie ‚x‚cution du mot .".
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (.")
  R>> COUNT 2DUP +
  EVEN >>R TYPE
;

 (;USES)
Primitive.
Partie ‚x‚cution du mot ;USES.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (;USES)
  R>> @ @ LAST
  @ NAME>> !
;

 (;CODE)
Primitive.
Partie ‚x‚cution du mot ;CODE.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (;CODE)
  R>> LAST @ NAME>> !
;

 (VOC)
Primitive.
Partie ‚x‚cution du mot VOCABULARY.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (VOC)
  W INC
  W INC
  CONTEXT # DI MOV
  W 0 [DI] MOV
  NEXT
END-CODE

 ?CONDITION
Assure le bon appariement d'une structure de
contr“le.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?CONDITION  ( flag --- )
  NOT ABORT" Structures mal imbriqu‚es"
;

 >>MARK
Marque le d‚but d'un branchement avant
inconditionnel.
Utilis‚ par les structures de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : >>MARK  ( --- adr )
  HERE 0 ,
;

 >>RESOLVE
R‚solution d'un branchement avant inconditionnel.
Utilis‚ par les structures de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : >>RESOLVE  ( adr --- )
  HERE SWAP !
;

 <<MARK
Marque le d‚but d'un branchement arriŠre
inconditionnel.
Utilis‚ par les structures de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : <<MARK  ( --- adr )
  HERE
;

 <<RESOLVE
R‚solution d'un branchement arriŠre inconditionnel.
Utilis‚ par les structures de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : <<RESOLVE  ( adr --- )
  ,
;

 ?>>MARK
Marque le d‚but d'un branchement avant conditionel.
Utilis‚ par les structures de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?>>MARK  ( --- flag adr )
  TRUE >>MARK
;

 ?>>RESOLVE
R‚solution d'un branchement avant conditionnel.
Utilis‚ par les structures de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?>>RESOLVE  ( flag adr --- )
  SWAP ?CONDITION >>RESOLVE
;

 ?<<MARK
Marque le d‚but d'un branchement arriŠre conditionel.
Utilis‚ par les structures de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?<<MARK  ( --- flag adr )
  TRUE <<MARK
;

 ?<<RESOLVE
R‚solution d'un branchement arriŠre conditionnel.
Utilis‚ par les structures de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?<<RESOLVE  ( flag adr --- )
  SWAP ?CONDITION <<RESOLVE
;

 BRANCH
Branchement inconditionnel.
Utilis‚ par les structures de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE BRANCH
LABEL BRAN
  0 [IP] IP MOV
  NEXT
END-CODE

 ?BRANCH
Branchement conditionnel.
Utilis‚ par les structures de contr“les.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE ?BRANCH  ( flag --- )
  AX POP
  AX AX OR
  BRAN JE
  IP INC
  IP INC
  NEXT
END-CODE

 (DO)
Primitive.
Partie ‚x‚cution du mot DO.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
CODE (DO)
  AX POP
  BX POP
LABEL PD0
  RP DEC
  RP DEC
  0 [IP] DX MOV
  DX 0 [RP] MOV
  IP INC
  IP INC
  8000 # BX ADD
  RP DEC
  RP DEC
  BX 0 [RP] MOV
  BX AX SUB
  RP DEC
  RP DEC
  AX 0 [RP] MOV
  NEXT
END-CODE

 (?DO)
Primitive.
Partie ‚x‚cution du mot ?DO.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (?DO)
  AX POP
  BX POP
  AX BX CMP
  PD0 JNE
  0 [IP] IP MOV
  NEXT
END-CODE

 (LOOP)
Primitive.
Partie ‚x‚cution du mot LOOP.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = LABEL PLOOP1
  6 # RP ADD
  IP INC
  IP INC
  NEXT
CODE (LOOP)
  1 # AX MOV
LABEL PLOOP0
  AX 0 [RP] ADD
  PLOOP1 JO
  BRAN #) JMP
END-CODE

 (+LOOP)
Primitive.
Partie ‚x‚cution du mot +LOOP.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CODE (+LOOP)
  AX POP
  PLOOP0 #) JMP
END-CODE

 'BUFFER
Empile l'adresse du buffer du fichier dont le handler
est sur la pile de donn‚es.
@SYNTAXE = Syntaxe : handle 'BUFFER
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : 'BUFFER  ( handle --- adr )
  LBUF C/PATH + 2+ * BUFFERS +
;

 EXEHDR
Zone de donn‚es utilis‚e pour g‚n‚rer l'entˆte d'un
fichier ‚x‚cutable.
Utilis‚e par le mot HDR!.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE EXEHDR 512 ALLOT

 HDR!
Primitive.
G‚n‚ration d'un entˆte de fichier ‚x‚cutable.
Utilis‚e par le mot SAVE-SYSTEM.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
: HDR!
  4D EXEHDR C!               ( Obligatoire pour fichier exe )
  5A EXEHDR 1+ C!            ( Obligatoire pour fichier exe )
  HERE 0FF AND EXEHDR 2+ !   ( Calcul de la taille du fichier )
  HERE 200 / 2+ EXEHDR 4 + !
  01    EXEHDR 6 + C!        ( Nombre d'entr‚es relogeables )
  20    EXEHDR 8 + C!        ( Taille de l'entˆte en
paragraphes )
  0001  EXEHDR 0A + !        ( Nombre de paragraphes minimum
requis par le fichier )
  3000  EXEHDR 0C + !        ( Nombre de paragraphes maximum
requis par le fichier )
  ENTRY EXEHDR 14 + !        ( Adresse du point d'entr‚e
initial )
  22    EXEHDR 18 + C!       ( Adresse de la table de
relocation )
  1     EXEHDR 1C + C!
  20FB  EXEHDR 1E + !
  6A72  EXEHDR 20 + !
  CODE-REF 1+ EXEHDR 22 + !  ( adresse de la r‚f‚rence
relogeable )
;
IBASE DECIMAL

 SAVE-SYSTEM
Sauvegarde du systŠme PGForth, sous forme d'un
fichier ‚x‚cutable.
@SYNTAXE = Syntaxe : SAVE-SYSTEM fichier_dest.ext
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SAVE-SYSTEM ( <<fichier_dest.ext>> )
  EXEHDR 512 ERASE
  HDR!
  ?OPEN ASCII0 0 (MAKE) ?DOSERR >>R
  DSEGMENT EXEHDR 512 R@ (PUT) ?DOSERR DROP
  R>>
  DSEGMENT
  CODE-REF 1+ DUP @ >>R OFF
  HANDLE DUP @ >>R OFF
  OVER 0 SWAP HERE SWAP (PUT) ?DOSERR DROP
  R>> HANDLE !
  R>> CODE-REF 1+ !
  (CLOSE)
;

 ASM[
Pr‚cŠde une s‚quence assembleur dans une d‚finition
FORTH.
S'utilise avec ]FORTH.
@SYNTAXE = Syntaxe : : mot ... ASM[ code... ]FORTH
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ASM[
  IBASE @ OBASE @
  CONTEXT @ HERE 6 + ,
  COMPILE BRANCH HERE 0 , HERE 2+ ,
  ALSO ASSEMBLER [COMPILE] [
;
IMMEDIATE

 ]FORTH
Termine une s‚quence assembleur dans une d‚finition
FORTH.
S'utilise avec ASM[.
@SYNTAXE = Syntaxe : : mot ... ASM[ code... ]FORTH
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ]FORTH
  [COMPILE] ALIGN
  HERE SWAP ! CONTEXT !
  OBASE ! IBASE !
  [COMPILE] ]
  PREVIOUS
;

 ;CODE
Permet de faire suivre une d‚finition FORTH de code
machine.
@SYNTAXE = Syntaxe : : mot ... ;CODE code...
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ;CODE
  ?CSP
  COMPILE (;CODE)
  [COMPILE] [
  [COMPILE] REVEAL
  ASSEMBLER
;
IMMEDIATE

 CODE
Cr‚ation d'une d‚finition en assembleur.
@SYNTAXE = Syntaxe : CODE nom_mot ... END-CODE | C;
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CODE
  CREATE
  [COMPILE] HIDE
  HERE DUP 2- !
  CONTEXT @ AVOC !     ( Sauvegarde du contexte             )
  ASSEMBLER            ( S‚lection du vocabulaire ASSEMBLER )
;

 END-CODE
Termine une d‚finition en assembleur.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : END-CODE
  AVOC @ CONTEXT !
  [COMPILE] REVEAL
;

 C;
Termine une d‚finition en assembleur.
Equivalent … END-CODE.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : C;
  END-CODE
;

 AVOC
Variable.
Utilis‚e par CODE, pour sauvegarder le vocabulaire de contexte.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE AVOC

 DOES?
Empile un flag VRAI si le code op‚rateur pr‚sent sur
la pile est un call.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DOES? ( IP --- IP' fl )
  DUP 3 +
  SWAP C@ 232 =
;

 LABEL
Cr‚ation d'un label assembleur.
@SYNTAXE = Syntaxe : LABEL nom_label
Le label cr‚‚ est accessible par JMP ou CALL.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : LABEL
  CREATE
  ASSEMBLER
;

 ASSEMBLER
S‚lection du vocabulaire ASSEMBLER comme premier
vocabulaire de CONTEXT.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VOCABULARY ASSEMBLER

 MEM-BLOCK
Empile l'adresse de segment du Memory Control Block
de PGForth.
@SYNTAXE = Syntaxe : MEM-BLOCK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
: MEM-BLOCK  ( --- adr )
  CSEGMENT 11 -
;

 LAST-BLOCK?
Empile un flag VRAI si le Memory Control Block de
PGForth est le dernier allou‚ par le systŠme DOS.
@SYNTAXE = Syntaxe : LAST-BLOCK?
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
: LAST-BLOCK?  ( --- flag )
  MEM-BLOCK 0 LC@ 5A =
;

 SEG-BLOCK
Empile l'adresse de segment du PSP correspondant au
Memory Control Block de PGForth.
Equivalent au mot PSP.
@SYNTAXE = Syntaxe : SEG-BLOCK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SEG-BLOCK  ( --- adr )
  MEM-BLOCK 1 L@
;

 SIZE-BLOCK
Empile le nombre de paragraphes (block de 16 octets),
allou‚ … PGForth.
@SYNTAXE = Syntaxe : SIZE-BLOCK
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SIZE-BLOCK  ( --- nb_par )
  MEM-BLOCK 3 L@
;

 SET-SIZE
Allocation m‚moire.
@SYNTAXE = Syntaxe : nb_paragraphe SET-SIZE
nb_paragraphe est le nombre de paragraphes (groupe de
16 octets) … allouer.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
: SET-SIZE  ( nb_paragraphe --- )
  DUP 3000 << ABORT" SET-SIZE: Violation de l'espace m‚moire."
  (SET-SIZE)
;

 COMMAND"
Primitive.
Pr‚paration des paramŠtres du mot SHELL".
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
: COMMAND"
  02 PSP 80 LC!
  ASCII / PSP 81 LC!
  ASCII C PSP 82 LC!
  ASCII " WORD       ( --- chn )
  DUP C@             ( chn --- lon&3F )
  OVER C!            ( chn --- )
  DUP DUP C@ + 1+    ( chn --- chn+lon+1 )
  13 SWAP C!         ( chn --- )
  DSEGMENT OVER      ( chn --- DS chn )
  DUP 1+ SWAP        ( chn DS --- chn+1 chn )
  PSP 83             ( chn DS chn+1 chn --- PSP 83 )
  ROT C@ 1+          ( chn DS chn+1 PSP 83 --- lon+1 )
  LMOVE              ( chn --- )
  C@ PSP 80 LC@ +
  PSP 80 LC!         ( lon=lon+3 --- )
  PSP 80
  PARAM-BLOCK 2 + !
  PARAM-BLOCK 4 + !
;

 SHELL"
Ex‚cution d'une commande DOS.
@SYNTAXE = Syntaxe : SHELL" commande"
Passe le contr“le au systŠme DOS, ‚x‚cute la
commande,
puis repasse le contr“le … PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SHELL"
  COMMAND"
  DSEGMENT COMSPEC!
  COMMAND.COM COUNT DROP
  PARAM-BLOCK
  (COMMAND) ?DOSERR
;

 (SET-SIZE)
Primitive.
Utilis‚e par SET-SIZE.
Allocation m‚moire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
CODE (SET-SIZE)
  BX POP
  ES PUSH
  CS AX MOV
  17 # AX SUB
  AX ES MOV
  4A # AH MOV
  21 INT
  ES POP
  NEXT
END-CODE

 PARAM-BLOCK
Block de paramŠtres utilis‚ par le mot SHELL".
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = CREATE PARAM-BLOCK
  0  ,             ( Environnement par d‚faut. )
  0  ,  0 ,        ( Pointeur sur la commande. )
  -1 , -1 ,        ( Pas de FCB1. )
  -1 , -1 ,        ( Pas de FCB2. )
  0  ,  0 ,        ( Pointeur de pile. )

 (COMMAND)
Primitive.
Ex‚cution d'une commande DOS.
Utilis‚e par le mot SHELL".
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
CODE (COMMAND)  ( seg_fic off_fic param_blk --- flag )
  BX POP
  DX POP
  AX POP
  DI PUSH
  SI PUSH
  BP PUSH
  ES PUSH
  DS PUSH
  DS PUSH
  ES POP
  AX DS MOV
  ' PARAM-BLOCK # DI MOV
  CS:
  SP 10 [DI] MOV
  SS AX MOV
  CS:
  AX 12 [DI] MOV
  4B00 # AX MOV
  21 INT
  ' PARAM-BLOCK # DI MOV
  CS:
  12 [DI] DX MOV
  DX SS MOV
  CS:
  10 [DI] SP MOV
  DS POP
  ES POP
  BP POP
  SI POP
  DI POP
  U>>=
  IF
    0 # AX MOV  ( Si le 'Carry flag' est … z‚ro, pas d'erreur )
  THEN
  1PUSH
END-CODE
IBASE DECIMAL

 SEGMENT>>
Variable.
Contient l'adresse de segment utilis‚e par les mots DUMP et
LDUMP.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE SEGMENT>>

 D.2
Affichage d'un nombre cadr‚ sur 2 caractŠres.
Utilis‚ par le mot DUMP.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : D.2
  BOUNDS
  ?DO
    SEGMENT>> @ I LC@ 0
    <<# # # #>> TYPE SPACE
  LOOP
;

 DUMP
Dumping d'une zone m‚moire.
@SYNTAXE = Syntaxe : adr long DUMP
Affiche le contenu de la zone commencant … l'adresse
adr,
sur une longueur long, en repr‚sentation h‚xad‚cimale et ASCII.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : DUMP  ( adr long --- )
  OBASE @ -ROT
  OBASE HEX
  SWAP DUP -16 AND SWAP 15 AND
  CR ."  Adresse   "
  8 0
  DO
    I 2 .R SPACE
  LOOP SPACE
  16 8
  DO
    I 2 .R SPACE
  LOOP SPACE
  16 0
  DO
    I 1 .R
  LOOP CR
  9 ASCII - REPLICATE 2 SPACES
  23 ASCII - REPLICATE 2 SPACES
  23 ASCII - REPLICATE 2 SPACES
  16 ASCII - REPLICATE
  ROT + BOUNDS
  DO
    CR SEGMENT>> @ 4 U.R
    ASCII : EMIT
    I DUP 4 U.R
    2 SPACES
    8 2DUP   D.2 SPACE
    OVER + 8 D.2 SPACE
    16 BOUNDS
    ?DO
      SEGMENT>> @ I LC@ 127 AND
      DUP BL 126 BETWEEN NOT
      IF
        DROP ASCII .
      THEN
      EMIT
    LOOP
    STOP? ?LEAVE
    16
  +LOOP
  OBASE ! CR
;

 LDUMP
Dumping d'une zone m‚moire extra-segment.
@SYNTAXE = Syntaxe : seg off long DUMP
Affiche le contenu de la zone commencant … l'adresse
seg off,
sur une longueur long, en repr‚sentation h‚xad‚cimale et ASCII.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : LDUMP ( seg off long --- )
  SEGMENT>> @ >>R
  ROT SEGMENT>> ! DUMP
  R>> SEGMENT>> !
;

 SEED
Variable.
Utilis‚e par le g‚n‚rateur de nombres al‚atoires.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE SEED

 SEEDON
Initialise le g‚n‚rateur de nombres al‚atoires.
@SYNTAXE = Syntaxe : SEEDON
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SEEDON
  SEED @ 75 UM* 75 0 D+
  2DUP U<< - -
  1- DUP SEED !
;

 RND
G‚nŠre un nombre al‚atoire.
@SYNTAXE = Syntaxe : n RND
Empile un nombre compris entre 0 et n-1.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : RND ( n --- [0..n-1] )
  SEEDON UM* SWAP DROP
;

 CARRAY
Cr‚ation de matrices d'octets … deux dimensions.
@SYNTAXE = Syntaxe : dimX dimY CARRAY
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : CARRAY        ( dimX dimY --- )
  CREATE
    2DUP SWAP
    ,           ( dimX dans PFA   )
    ,           ( dimY dans PFA+2 )
    * ALLOT     ( reserve dimX * dimY octets )
  DOES>>         ( X Y [PFA] --- )
    >>R
    OVER R@ @   ( X Y --- X dimX )
    U<< NOT ABORT" CARRAY : Indice X hors limites"
    DUP R@ 2+ @ ( X Y --- Y dimY )
    U<< NOT ABORT" CARRAY : Indice Y hors limites"
    R>>
    DUP @       ( X Y [PFA] --- dimX )
    ROT *       ( X [PFA] --- dimX*Y )
    + + 4 +     ( --- [PFA]+4+dimX*Y+X )
;

 ARRAY
Cr‚ation de matrices de mots … deux dimensions.
@SYNTAXE = Syntaxe : dimX dimY ARRAY
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ARRAY         ( dimX dimY --- )
  CREATE
    2DUP SWAP
    ,           ( dimX dans PFA   )
    ,           ( dimY dans PFA+2 )
    * 2* ALLOT  ( reserve dimX * dimY mots )
  DOES>>         ( X Y [PFA] --- )
    >>R
    OVER R@ @   ( X Y --- X dimX )
    U<< NOT ABORT" ARRAY : Indice X hors limites"
    DUP R@ 2+ @ ( X Y --- Y dimY )
    U<< NOT ABORT" ARRAY : Indice Y hors limites"
    R>>
    DUP @       ( X Y [PFA] --- dimX )
    ROT * 2*    ( X [PFA] --- dimX*Y )
    + SWAP 2* + ( --- [PFA]+dimX*2Y+2X )
    4 +         ( --- [PFA]+dimX*2Y+2X+4 )
;

 LMARGIN
Variable.
Utilis‚e par le mot WORDS.
Contient la marge d'affichage gauche.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE LMARGIN
Initialisation :
1 IS LMARGIN

 RMARGIN
Variable.
Utilis‚e par le mot WORDS.
Contient la marge d'affichage droite.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE RMARGIN
Initialisation :
72 IS RMARGIN

 #WORDS
Variable.
Utilis‚e par le mot WORDS.
Contient le nombre de d‚finitions list‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE #WORDS

 #TAB
Variable.
Utilis‚e par le mot WORDS.
Contient la largeur de la tabulation.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE #TAB
Initialisation :
12 IS #TAB

 ?LINE
Primitive.
Utilis‚e par le mot WORDS.
Teste si un passage … la ligne est n‚c‚ssaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?LINE  ( pos --- )
  #OUT @ + RMARGIN @ >>
  IF
    CR LMARGIN @ SPACES
  THEN
;

 ?CR
Primitive.
Utilis‚e par le mot WORDS.
Teste si un retour chariot est n‚c‚ssaire.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?CR  ( --- )
  0 ?LINE
;

 ?TAB
Primitive.
Utilis‚e par le mot WORDS.
G‚nŠre une tabulation … la prochaine colonne multiple de pos.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?TAB  ( pos --- )
  RMARGIN @ #OUT @ - SWAP MOD SPACES
;

 LARGEST
Primitive.
Utilis‚e par le mot WORDS.
Empile la plus adresse d'une s‚rie.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : LARGEST  ( adr1 n1 --- adr2 n2 )
  OVER 0 SWAP ROT 0
  DO
    2DUP @ U<<
    IF
      -ROT 2DROP DUP @ OVER
    THEN
    2+
  LOOP
  DROP
;

 WORDS
Affiche la liste des mots du premier vocabulaire de
CONTEXT.
@SYNTAXE = Syntaxe : WORDS
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : WORDS
  #WORDS OFF
  CR LMARGIN @ SPACES
  CONTEXT @ 'WORD #THREADS 2* CMOVE
  BEGIN
    'WORD #THREADS LARGEST
    DUP STOP? NOT AND
  WHILE
    DUP L>>NAME #TAB @ ?TAB
    DUP C@ 31 AND ?LINE
    DUP LINK>> DUP @ ['] (VOC) @ =
    SWAP ['] (VOC) <<>> AND
    IF
      ATTRIBUTS @ >>R ATTRIBUTS ON
      ATTOFF BOLD .ID ATTOFF       ( Affichage des vocabulaires
en surbrillance )
      R>> ATTRIBUTS !
    ELSE
      .ID
    THEN
    #WORDS 1+!
    @ SWAP !
  REPEAT
  2DROP
  CR #WORDS @ . ." D‚finitions" CR
;

 ROOT
S‚lection du vocabulaire ROOT comme premier
vocabulaire de CONTEXT.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VOCABULARY ROOT

 (")
Primitive.
Partie ‚x‚cution utilis‚e par le mot ".
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : (")
  R>> COUNT 2DUP +
  EVEN >>R
;

 STR$
Constante.
Utilis‚e par le mot $EXECUTE.
Contient l'adresse de la chaine … interpr‚ter.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0. 2CONSTANT STR$

 #STRING
Variable.
Utilis‚e par le mot $EXECUTE.
Contient le nombre de chaines imbriqu‚es.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = VARIABLE #STRING

 SOURCE$
Primitive.
Redirection du flux d'entr‚e par le mot $EXECUTE.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : SOURCE$ ( --- adr len )
  HANDLE @ 0<<
  IF
    STR$
  ELSE
    (SOURCE)
  THEN
;

 ?ERROR$
Primitive.
Redirection de la gestion des erreurs par le mot $EXECUTE.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : ?ERROR$ ( adr len flg --- )
  DUP
  IF
    ['] (SOURCE) IS SOURCE
    ['] (?ERROR) IS ?ERROR
    HANDLE @ 0<<
    IF
      HANDLE OFF
      CR ." Chaine '" STR$ TYPE ." ' : "
    THEN
    #STRING OFF
  THEN
  (?ERROR)
;

 $EXECUTE
Interpr‚tation de chaines de caractŠres.
@SYNTAXE = Syntaxe : adr_chaine long $EXECUTE
InterprŠte la chaine adr_chaine, de longueur long.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = : $EXECUTE ( adr_chaine long --- )
  2DUP
  #STRING 1+!
  ['] SOURCE$ IS SOURCE
  ['] ?ERROR$ IS ?ERROR
  STR$ >>R >>R
  SWAP ['] STR$ >>BODY 2!
  >>IN @ >>R
  >>IN OFF
  HANDLE @ >>R
  #STRING @ NEGATE HANDLE !         \ Le Handler principal
devient n‚gatif
  DSEGMENT -ROT >>R                  \ Transfert de la chaine
et de sa
  DSEGMENT BUFFERS                  \ longueur dans flux
d'entr‚e
  DUP 1+ SWAP R@ SWAP C! R>> LCMOVE
  RUN
  #STRING 1-!
  #STRING @ 0=                      \ Est-ce la derniŠre chaine
?
  IF
    ['] (?ERROR) IS ?ERROR          \ Oui, restitution du flux
    ['] (SOURCE) IS SOURCE          \ d'entr‚e original
  THEN
  R>> HANDLE !
  R>> >>IN !
  R>> R>> SWAP ['] STR$ >>BODY 2!
;

 SS-REG
Constante.
Contient la valeur du registre de segment de pile SS,
avant le lancement de PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0 CONSTANT SS-REG

 SP-REG
Constante.
Contient la valeur du registre pointeur de pile SP,
avant le lancement de PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0 CONSTANT SP-REG

 BP-REG
Constante.
Contient la valeur du registre pointeur de pile BP,
avant le lancement de PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = 0 CONSTANT BP-REG

 CONTROL-C
Remplacement de l'interruption CONTROL C.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
LABEL CONTROL-C
  CODE-REF #) CALL
  DX DS MOV
  DX AX MOV
  1000 # AX ADD
  AX SS MOV
  STI
  PUSHF
  DX PUSH
  ' ABORT # BX MOV
  0 [BX] PUSH
  20 # AL MOV
  AL 20 # OUT
  IRET
IBASE DECIMAL

 ENTRY
Label de branchement initial au lancement de
PGForth.
@DEF_FORTH = D‚finition en FORTH :
@PROGRAMME = IBASE HEX
LABEL ENTRY
  DS PUSH
  DX DX XOR
  DX DS MOV
  4 23 * # BX MOV         ( Remplacement de l'interruption
CONTROL C )
  CONTROL-C # 0 [BX] MOV
  CODE-REF #) CALL
  DX 2 [BX] MOV
  CODE-REF #) CALL        ( Initialisation de PGForth )
  DX DS MOV
  SS AX MOV
  ' SS-REG >>BODY # BX MOV ( Sauvegarde du contexte )
  AX 0 [BX] MOV
  SP AX MOV
  ' SP-REG >>BODY # BX MOV
  AX 0 [BX] MOV
  BP AX MOV
  ' BP-REG >>BODY # BX MOV
  AX 0 [BX] MOV
  1000 # DX ADD           ( Initialisation des segments et des
piles )
  DX SS MOV
  0FFFE # SP MOV
  07FFE # BP MOV
  ' COLD # BX MOV
  0 [BX] JMP              ( D‚marrage avec COLD )
IBASE DECIMAL

